module Darklang.Stdlib.Http


/// HTTP methods for routing
type Method =
  | GET
  | POST
  | PUT
  | DELETE
  | PATCH
  | HEAD
  | OPTIONS
  | TRACE
  | CONNECT


type Request =
  { method: Method
    url: String
    headers: List<String * String>
    body: List<UInt8> }

module Request =
  let queryParams (req: Stdlib.Http.Request) : List<String * String> =
    match req.url |> Stdlib.String.split "?" with
    | [] -> []
    | _ :: queryParts ->
      (Stdlib.String.join queryParts "")
      |> Stdlib.String.split "&"
      |> Stdlib.List.map (fun param ->
        match Stdlib.String.split param "=" with
        | [ key; value ] -> (key, value)
        | _ -> (param, ""))

  let queryParam
    (req: Stdlib.Http.Request)
    (key: String)
    : Stdlib.Option.Option<String> =
    let found =
      (Stdlib.Http.Request.queryParams req)
      |> Stdlib.List.filterMap (fun pair ->
        match pair with
        | (k, v) ->
          if k == key then
            Stdlib.Option.Option.Some v
          else
            Stdlib.Option.Option.None
        | _ -> Stdlib.Option.Option.None)

    match found with
    | [] -> Stdlib.Option.Option.None
    | [ v ] -> Stdlib.Option.Option.Some v
    // TODO: something else?
    | items -> Stdlib.Option.Option.Some(Stdlib.String.join items ",")


type Response =
  { statusCode: Int64
    headers: List<String * String>
    body: List<UInt8> }

/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with HTTP status <param code> and <param response> body.
let response (body: List<UInt8>) (statusCode: Int64) : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = statusCode
      headers = []
      body = body }

/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with HTTP status <param code>, <param response> body and
/// <param headers>.
let responseWithHeaders
  (body: List<UInt8>)
  (headers: List<String * String>)
  (statusCode: Int64)
  : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = statusCode
      headers = headers
      body = body }

/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with HTTP status 200 and <param response> body.
let success (body: List<UInt8>) : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = 200L
      headers = []
      body = body }

/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with HTTP status 200, <param response> body, with the
/// Content-Type header set to "text/html; charset=utf-8".
let responseWithHtml
  (body: String)
  (statusCode: Int64)
  : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = statusCode
      headers = [ ("Content-Type", "text/html; charset=utf-8") ]
      body = body |> Stdlib.String.toBytes }


/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with HTTP status 200, <param response> body, with the
/// Content-Type header set to "text/plain; charset=utf-8".
let responseWithText
  (text: String)
  (statusCode: Int64)
  : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = statusCode
      headers = [ ("Content-Type", "text/plain; charset=utf-8") ]
      body = Stdlib.String.toBytes text }

/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with HTTP status 200, <param response> body, with the
/// Content-Type header set to "application/json".
let responseWithJson
  (json: String)
  (statusCode: Int64)
  : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = statusCode
      headers = [ ("Content-Type", "application/json") ]
      body = Stdlib.String.toBytes json }

/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with {{302}} status code and redirect to <param url>.
let redirectTo (url: String) : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = 302L
      headers = [ ("Location", url) ]
      body = [] }

/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with {{400}} status code and <param response> body.
let badRequest (error: String) : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = 400L
      headers = []
      body = Stdlib.String.toBytes error }

/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with {{404}} status code.
let notFound () : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = 404L
      headers = []
      body = [] }

/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with {{401}} status code.
let unauthorized () : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = 401L
      headers = []
      body = [] }

/// Returns a <type Response> that can be returned from an HTTP handler to
/// respond with {{403}} status code.
let forbidden () : Stdlib.Http.Response =
  Stdlib.Http.Response
    { statusCode = 403L
      headers = []
      body = [] }

type Cookie =
  { expires: DateTime
    maxAge: Int64
    domain: String
    path: String
    secure: Bool
    httpOnly: Bool
    sameSite: String }

// TODO: this references several things that don't actually exist
// (e.g. Stdlib.DateTime.dayOfWeek)
// /// Returns an HTTP Set-Cookie header <type (String*String)> suitable for use with <fn
// /// Http.responseWithHeaders>, given a cookie <param name>, a <type String>
// /// <param value> for it, and a <type Dict> of Set-Cookie <param params>
// /// ({{Expires}}, {{Max-Age}}, {{Domain}}, {{Path}}, {{Secure}}, {{HttpOnly}},
// /// and/or {{SameSite}}).
// let cookie
//   (name: String)
//   (value: String)
//   (cookie: Cookie)
//   : Stdlib.Result.Result<(String * String), String> =
//   if
//     not (
//       Stdlib.List.contains
//         [ "strict"; "lax"; "none" ]
//         (Stdlib.String.toLowercase cookie.sameSite)
//     )
//   then
//     Error "SameSite must be either \"Strict\" or \"Lax\" or \"None\""
//   else
//     let expires =
//       let e = cookie.expires
//       $"{Stdlib.DateTime.dayOfWeek e}, {Stdlib.DateTime.day e} {Stdlib.DateTime.month e} {Stdlib.DateTime.year e} {Stdlib.DateTime.hour e}:{Stdlib.DateTime.minute e}:{Stdlib.DateTime.second} GMT"

//     let cookie =
//       [ ("Expires", expires)
//         ("Max-Age", cookie.maxAge |> Stdlib.Int64.toString)
//         ("Domain", cookie.domain)
//         ("Path", cookie.path)
//         ("Secure", cookie.secure |> Stdlib.Bool.toString)
//         ("HttpOnly", cookie.httpOnly |> Stdlib.Bool.toString)
//         ("SameSite", cookie.sameSite) ]
//       |> Stdlib.List.filterMap (fun (k, v) -> if v == "" then Stdlib.Option.Option.None else Stdlib.Option.Option.Some(k, v))
//       |> Stdlib.List.map (fun (k, v) -> k ++ "=" ++ v)
//       |> Stdlib.String.join "; "

//     if cookie == "" then
//       Error "Cookie must have at least one parameter"
//     else
//       Ok("Set-Cookie", name ++ "=" ++ value ++ "; " ++ cookie)


// =============================================================================
// HTTP Server / App Types
// =============================================================================

/// A route definition for pattern matching incoming requests
type Route =
  { method: Method
    /// Path pattern with :param placeholders (e.g., "/users/:id/posts/:postId")
    path: String
    /// Handler receives request and extracted path parameters
    handler: Request -> Dict<String> -> Response }


/// HTTP Server application definition
///
/// This allows defining an HTTP server as a Darklang value that can be run
/// with `Builtin.httpRunServer`.
type HttpApp =
  { /// Display name for the server
    name: String

    /// Brief description
    description: String

    /// Host to bind to (e.g., "0.0.0.0" for all interfaces, "127.0.0.1" for localhost)
    host: String

    /// Port to listen on
    port: Int64

    /// Routes to handle - matched in order, first match wins
    routes: List<Route> }


module HttpApp =
  /// Create a simple single-handler HTTP app
  let simple
    (name: String)
    (port: Int64)
    (handler: Request -> Response)
    : HttpApp =
    let wrappedHandler = (fun req _params -> handler req)

    HttpApp
      { name = name
        description = ""
        host = "0.0.0.0"
        port = port
        routes =
          [ Route
              { method = Method.GET
                path = "/*"
                handler = wrappedHandler }
            Route
              { method = Method.POST
                path = "/*"
                handler = wrappedHandler }
            Route
              { method = Method.PUT
                path = "/*"
                handler = wrappedHandler }
            Route
              { method = Method.DELETE
                path = "/*"
                handler = wrappedHandler }
            Route
              { method = Method.PATCH
                path = "/*"
                handler = wrappedHandler } ] }


  /// Add a route to an HttpApp
  let addRoute
    (app: HttpApp)
    (method: Method)
    (path: String)
    (handler: Request -> Dict<String> -> Response)
    : HttpApp =
    let newRoute = Route { method = method; path = path; handler = handler }

    HttpApp { app with routes = Stdlib.List.append app.routes [ newRoute ] }


  /// Add a GET route
  let get
    (app: HttpApp)
    (path: String)
    (handler: Request -> Dict<String> -> Response)
    : HttpApp =
    addRoute app Method.GET path handler


  /// Add a POST route
  let post
    (app: HttpApp)
    (path: String)
    (handler: Request -> Dict<String> -> Response)
    : HttpApp =
    addRoute app Method.POST path handler


  /// Add a PUT route
  let put
    (app: HttpApp)
    (path: String)
    (handler: Request -> Dict<String> -> Response)
    : HttpApp =
    addRoute app Method.PUT path handler


  /// Add a DELETE route
  let delete
    (app: HttpApp)
    (path: String)
    (handler: Request -> Dict<String> -> Response)
    : HttpApp =
    addRoute app Method.DELETE path handler


  /// Create an empty HttpApp builder
  let create (name: String) (port: Int64) : HttpApp =
    HttpApp
      { name = name
        description = ""
        host = "0.0.0.0"
        port = port
        routes = [] }


  /// Set the description
  let withDescription (app: HttpApp) (description: String) : HttpApp =
    HttpApp { app with description = description }


  /// Set the host
  let withHost (app: HttpApp) (host: String) : HttpApp =
    HttpApp { app with host = host }


// =============================================================================
// Magic HTTP Handler Discovery
// =============================================================================

/// An HTTP handler that can be automatically discovered and routed to.
///
/// Define values of this type anywhere in your packages, and they will be
/// automatically discovered when running `Builtin.httpServe`.
///
/// Example:
/// ```
/// let getUserHandler : Stdlib.Http.HttpHandler =
///   Stdlib.Http.HttpHandler {
///     route = "/api/users/:id"
///     method = Stdlib.Http.Method.GET
///     description = "Get a user by ID"
///     handler = fun req params ->
///       let userId = Stdlib.Dict.get params "id"
///       Stdlib.Http.responseWithJson "{\"user\": \"...\"}" 200L
///   }
/// ```
type HttpHandler =
  { /// The route pattern (e.g., "/api/users/:id")
    /// Use :paramName for path parameters
    route: String

    /// HTTP method this handler responds to
    method: Method

    /// Brief description of what this handler does
    description: String

    /// The handler function - receives request and extracted path params
    handler: Request -> Dict<String> -> Response }


module HttpHandler =
  /// Create a GET handler
  let get
    (route: String)
    (description: String)
    (handler: Request -> Dict<String> -> Response)
    : HttpHandler =
    HttpHandler
      { route = route
        method = Method.GET
        description = description
        handler = handler }

  /// Create a POST handler
  let post
    (route: String)
    (description: String)
    (handler: Request -> Dict<String> -> Response)
    : HttpHandler =
    HttpHandler
      { route = route
        method = Method.POST
        description = description
        handler = handler }

  /// Create a PUT handler
  let put
    (route: String)
    (description: String)
    (handler: Request -> Dict<String> -> Response)
    : HttpHandler =
    HttpHandler
      { route = route
        method = Method.PUT
        description = description
        handler = handler }

  /// Create a DELETE handler
  let delete
    (route: String)
    (description: String)
    (handler: Request -> Dict<String> -> Response)
    : HttpHandler =
    HttpHandler
      { route = route
        method = Method.DELETE
        description = description
        handler = handler }

  /// Create a handler for any method
  let any
    (route: String)
    (method: Method)
    (description: String)
    (handler: Request -> Dict<String> -> Response)
    : HttpHandler =
    HttpHandler
      { route = route
        method = method
        description = description
        handler = handler }