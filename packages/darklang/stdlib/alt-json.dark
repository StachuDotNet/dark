module Darklang =
  module Stdlib =
    module AltJson =
      type JsonToken =
        | Null
        | Bool of Bool
        | Number of Float
        | String of String
        | Array of List<JsonToken>
        | Object of List<String * JsonToken>


      module TokenParseError =
        type TokenParseError = | NotJson

        let toString (e: TokenParseError) : String =
          match e with
          | NotJson -> "Not JSON"


      let serializeToken (token: JsonToken) : String =
        Builtin.AltJson.serializeToken token

      let parseToken
        (jsonString: String)
        : Result.Result<JsonToken, TokenParseError.TokenParseError> =
        Builtin.AltJson.parseToken jsonString


      module JsonPath =
        module Part =
          type Part =
            | Root
            | Index of Int
            | Field of String

          let toString (part: Part) : String =
            match part with
            | Root -> "root"
            | Field name -> "." ++ name
            | Index index -> "[" ++ Int.toString index ++ "]"

        type JsonPath = List<Part.Part>

        let toString (path: JsonPath) : String =
          path |> List.reverse |> List.map Part.toString |> String.join ""


      module JsonTokenization =
        type DetokenizationError =
          | DetokenizationError of
            /// where in the JSON could we not detokenize as expected?
            jsonPath: JsonPath.JsonPath *

            /// and what was the token?
            jt: JsonToken


        type JsonTokenizer<'T> = 'T -> JsonToken

        /// The path is needed in reporting the location of failed detokenizations
        type JsonDetokenizer<'T> =
          JsonPath.JsonPath -> JsonToken -> Result.Result<'T, DetokenizationError>


        module Unit =
          /// Tokenizes a Unit as Json `null`
          let tokenize (_unit: Unit) : JsonToken = JsonToken.Null

          /// Detokenizes a Json `null` as a Unit
          let detokenize
            (path: JsonPath.JsonPath)
            (token: JsonToken)
            : Result.Result<Unit, DetokenizationError> =
            match token with
            | Null -> Result.Result.Ok()
            | _ ->
              Result.Result.Error(
                DetokenizationError.DetokenizationError(path, token)
              )


        module Bool =
          /// Tokenizes a Bool as Json `true` or `false`
          let tokenize (value: Bool) : JsonToken = JsonToken.Bool value

          /// Detokenizes a Json `true` or `false` as a Bool
          let detokenize
            (path: JsonPath.JsonPath)
            (token: JsonToken)
            : Result.Result<Bool, DetokenizationError> =
            match token with
            | Bool b -> Result.Result.Ok b
            | _ ->
              Result.Result.Error(
                DetokenizationError.DetokenizationError(path, token)
              )


        module List =
          let tokenize<'Inner>
            (tokenizeInner: JsonTokenizer<'Inner>)
            (l: List<'Inner>)
            : JsonToken =
            //JsonToken.Array(List.map l tokenizeInner)
            JsonToken.Array []

          let detokenize<'Inner>
            (detokenizer: JsonDetokenizer<'Inner>)
            (path: JsonPath.JsonPath)
            (token: JsonToken)
            : Result.Result<List<'Inner>, DetokenizationError> =
            match token with
            | Array tokens ->
              tokens
              |> List.fold
                (fun acc currentToken ->
                  match acc with
                  | Error err -> Result.Result.Error e
                  | Ok values ->
                    let newPath =
                      path
                      |> List.push (JsonPath.JsonPath.Index(List.length values))

                    match detokenizer newPath currentToken with
                    | Ok value -> Result.Result.Ok(List.push values value)
                    | Error e -> Result.Result.Error e)
                (Ok [])
              |> Result.map (fun l -> List.reverse l)
            | _ ->
              Result.Result.Error(
                DetokenizationError.DetokenizationError(path, token)
              )


      type ParseError =
        | TokenParseError of TokenParseError.TokenParseError
        | DetokenizationError of JsonTokenization.DetokenizationError

      let parse<'T>
        (detokenizer: JsonTokenization.JsonDetokenizer<'T>)
        (jsonStr: String)
        : Result.Result<'T, ParseError> =
        match Builtin.AltJson.parseToken jsonStr with
        | Ok jsonToken ->
          (detokenizer [ JsonPath.Part.Part.Root ] jsonToken)
          |> Result.mapError (fun e -> ParseError.DetokenizationError e)

        | Error tokenError ->
          Result.Result.Error(ParseError.TokenParseError tokenError)

      let serialize<'T>
        (tokenizer: JsonTokenization.JsonTokenizer<'T>)
        (value: 'T)
        : String =
        value |> tokenizer |> Builtin.AltJson.serializeToken



      // type-specific helpers

      module Parse =
        let unit (jsonStr: String) : Result.Result<Unit, ParseError> =
          parse<Unit> JsonTokenization.Unit.detokenize jsonStr

        let bool (jsonStr: String) : Result.Result<Bool, ParseError> =
          parse<Bool> JsonTokenization.Bool.detokenize jsonStr

        let list<'Inner>
          (inner: JsonTokenization.JsonDetokenizer<'Inner>)
          (jsonStr: String)
          : Result.Result<List<JsonToken>, ParseError> =
          parse<List<'Inner>>
            (JsonTokenization.List.detokenize<'Inner> inner)
            jsonStr


      module Serialize =
        let unit (u: Unit) : String =
          serialize<Unit> JsonTokenization.Unit.tokenize u

        let bool (b: Bool) : String =
          serialize<Bool> JsonTokenization.Bool.tokenize b

        let list<'Inner>
          (innerTokenizer: JsonTokenization.JsonTokenizer<'Inner>)
          (l: List<'Inner>)
          : String =
          serialize<List<'Inner>>
            (fun l -> JsonTokenization.List.tokenize<'Inner> innerTokenizer l)
            l