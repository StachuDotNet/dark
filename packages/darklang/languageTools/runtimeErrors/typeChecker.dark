module Darklang =
  module LanguageTools =
    module RuntimeErrors =
      // <aliases>
      type Option = PACKAGE.Darklang.Stdlib.Option.Option
      type ID = PACKAGE.Darklang.LanguageTools.ID
      type TLID = PACKAGE.Darklang.LanguageTools.TLID

      // language
      type RTTypeReference =
        PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference

      type RTDval = PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval.Dval

      type RTTypeName = PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.TypeName

      type RTFnName = PACKAGE.Darklang.LanguageTools.RuntimeTypes.FnName.FnName
      type RTParam = PACKAGE.Darklang.LanguageTools.RuntimeTypes.Param

      // RuntimeErrors
      type REErrorOutput = PACKAGE.Darklang.LanguageTools.RuntimeErrors.ErrorOutput

      type ES =
        PACKAGE.Darklang.LanguageTools.RuntimeErrors.ErrorSegment.ErrorSegment
      // </aliases>


      // CLEANUP consider renaming this module to RuntimeTypeChecker
      module TypeChecker =
        type Location = Option<TLID * ID>

        type Context =
          | FunctionCallParameter of
            fnName: RTFnName *
            parameter: RTParam *
            paramIndex: Int *
            location: Location

          | FunctionCallResult of
            fnName: RTFnName *
            returnType: RTTypeReference *
            location: Location

          | RecordField of
            recordTypeName: RTTypeName *
            fieldName: String *
            fieldType: RTTypeReference *
            location: Location

          | EnumField of
            enumTypeName: RTTypeName *
            caseName: String *
            fieldIndex: Int *  // nth argument to the enum constructor
            fieldCount: Int *
            fieldType: RTTypeReference *
            location: Location

          | DBQueryVariable of
            varName: String *
            expected: RTTypeReference *
            location: Location

          | DBSchemaType of
            name: String *
            expectedType: RTTypeReference *
            location: Location

          | FnValResult of returnType: RTTypeReference * location: Location



        type Error =
          | ValueNotExpectedType of
            actualValue: RTDval *
            expectedType: RTTypeReference *
            Context

          | TypeDoesntExist of RTTypeName * Context

        module Error =
          let valuePath (context: Context) : String =
            // match context with
            // | TCK.FunctionCallParameter(_, parameter, _, _) -> parameter.name
            // | TCK.FunctionCallResult(_, _, _) -> "result"
            // | TCK.RecordField(_, fieldName, _, _) -> fieldName
            // | TCK.EnumField(_, caseName, _, _, _, _) -> caseName
            // | TCK.DBSchemaType(dbName, _, _) -> dbName
            // | TCK.DBQueryVariable(varName, _, _) -> varName
            "RTETODO: valuePath"

          let rootContext (context: Context) : Context =
            match context with
            | FunctionCallParameter _ -> context
            | FunctionCallResult _ -> context
            | RecordField _ -> context
            | EnumField _ -> context
            | DBSchemaType _ -> context
            | DBQueryVariable _ -> context
            | FnValResult(_, _) -> context


          /// Return the segments describing the context as a short name, used in the description of errors
          let contextSummary (context: Context) : List<ES> =
            match context with
            | FunctionCallParameter(fnName, parameter, paramIndex, _) ->
              [ ES.FunctionName fnName
                ES.String "'s "
                ES.Ordinal(paramIndex + 1)
                ES.String " argument ("
                ES.ParamName parameter.name
                ES.String ")" ]

            | FunctionCallResult(fnName, returnType, _) ->
              [ ES.FunctionName fnName; ES.String "'s return value" ]

            | RecordField(recordType, fieldName, _, _) ->
              [ ES.TypeName recordType
                ES.String "'s "
                ES.FieldName fieldName
                ES.String " field" ]

            | EnumField(enumType, caseName, fieldIndex, _, _, _) ->
              [ ES.TypeName enumType
                ES.String "."
                ES.InlineFieldName caseName
                ES.String "'s "
                ES.Ordinal(fieldIndex + 1)
                ES.String " argument" ]

            | DBSchemaType(dbName, expectedType, _) ->
              [ ES.String "DB "; ES.DBName dbName; ES.String "'s value" ]

            | DBQueryVariable(varName, _, _) ->
              [ ES.String "Variable "; ES.VarName varName ]

            | FnValResult(_, _) -> [ ES.String "Function return value" ]


          let rec contextAsActualExpected
            (argument: RuntimeTypes.Dval.Dval)
            (context: Context)
            : List<ES> * List<ES> =

            // RTETODO: We do actual and expected in the same function so that we can display
            // them the same way. This hasn't been ported for all Context types, but
            // should be.
            let defaultActual =
              [ ES.IndefiniteArticle
                ES.TypeOfValue argument
                ES.String ": "
                ES.FullValue argument ]

            match context with
            | FunctionCallParameter(fnName, parameter, paramIndex, _) ->
              let segments =
                [ ES.String "("
                  ES.InlineParamName parameter.name
                  ES.String ": "
                  ES.TypeReference parameter.typ
                  ES.String ")" ]

              (defaultActual, segments)


            | FunctionCallResult(fnName, returnType, _) ->
              // format:
              // Option<String>
              let segment = [ ES.TypeReference returnType ]
              (defaultActual, segment)


            | RecordField(recordType, fieldName, fieldType, _) ->
              // format:
              // ({ name : string; ... }) // some description

              // TODO: fetch the type and lookup the field definition as a comment
              let comment = []
              // let comment =
              //   if fieldDef.description = "" then
              //     []
              //   else
              //     [ String " // "; Description fieldDef.description ]

              let segment =
                PACKAGE.Darklang.Stdlib.List.append
                  [ ES.String "({ "
                    ES.InlineFieldName fieldName
                    ES.String ": "
                    ES.TypeReference fieldType
                    ES.String "; ... })" ]
                  comment

              (defaultActual, segment)


            | EnumField(enumType, caseName, fieldIndex, fieldCount, fieldType, _) ->
              // format:
              //   Ok (..., string, ...) // some description
              // RTETODO: extract description from the type definition later

              let prefix = if fieldIndex == 0 then [] else [ ES.String "..., " ]

              let suffix =
                if fieldIndex == fieldCount - 1 then
                  []
                else
                  [ ES.String ", ..." ]

              let openParen = if fieldCount > 0 then [ ES.String "(" ] else []

              let closeParen = if fieldCount > 0 then [ ES.String ")" ] else []

              //CLEANUP de-duplicate these 2 segments a bit
              let fieldTypeSegment =
                [ ES.ShortTypeName enumType
                  ES.String "."
                  ES.InlineFieldName caseName
                  ES.String " " ]
                |> PACKAGE.Darklang.Stdlib.List.append openParen
                |> PACKAGE.Darklang.Stdlib.List.append prefix
                |> PACKAGE.Darklang.Stdlib.List.append [ ES.TypeReference fieldType ]
                |> PACKAGE.Darklang.Stdlib.List.append suffix
                |> PACKAGE.Darklang.Stdlib.List.append closeParen

              let argumentSegment =
                [ ES.ShortTypeName enumType
                  ES.String "."
                  ES.InlineFieldName caseName
                  ES.String " " ]
                |> PACKAGE.Darklang.Stdlib.List.append openParen
                |> PACKAGE.Darklang.Stdlib.List.append prefix
                |> PACKAGE.Darklang.Stdlib.List.append [ ES.TypeOfValue argument ]
                |> PACKAGE.Darklang.Stdlib.List.append suffix
                |> PACKAGE.Darklang.Stdlib.List.append closeParen

              (argumentSegment, fieldTypeSegment)


            | DBSchemaType(dbName, expectedType, _) ->
              let segment = [ ES.TypeReference expectedType ]
              (defaultActual, segment)


            | DBQueryVariable(varName, expected, _) ->
              let segment =
                [ ES.String "("
                  ES.InlineVarName varName
                  ES.String ": "
                  ES.TypeReference expected
                  ES.String ")" ]

              (defaultActual, segment)

            | FnValResult(returnType, _) ->
              defaultActual, [ ES.TypeReference returnType ]


          let contextVerb (context: Context) : String =
            match context with
            | FunctionCallParameter _ -> "passed"
            | FunctionCallResult _ -> "returned"
            | RecordField _ -> "passed"
            | EnumField _ -> "passed"
            | DBSchemaType _ -> "passed"
            | DBQueryVariable _ -> "passed"
            | FnValResult _ -> "returned"

          let toSegments (e: Error) : REErrorOutput =
            match e with


            | TypeDoesntExist(typeName, context) ->
              ErrorOutput
                { summary =
                    [ ES.String "Couldn't find type"; ES.TypeReference typeName ]
                  extraExplanation = []
                  actual = []
                  expected = [] }

            | ValueNotExpectedType(argument, expected, context) ->
              let summary =
                PACKAGE.Darklang.Stdlib.List.append
                  (contextSummary context)
                  [ ES.String " should be "
                    ES.IndefiniteArticle
                    ES.TypeReference expected ]

              let extraExplanation =
                [ ES.String ". However, "
                  ES.IndefiniteArticle
                  ES.TypeOfValue argument
                  ES.String " ("
                  ES.InlineValue argument
                  ES.String ") was "
                  ES.String(contextVerb context)
                  ES.String " instead." ]

              let (actual, expected) = contextAsActualExpected argument context

              ErrorOutput
                { summary = summary
                  extraExplanation = extraExplanation
                  actual = actual
                  expected = expected }