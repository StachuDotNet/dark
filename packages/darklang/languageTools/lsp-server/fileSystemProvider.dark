module Darklang =
  module LanguageTools =
    module LspServer =
      module FileSystemProvider =
        module ReadFile =
          let sendResponse
            (state: LspState)
            (requestId: JsonRPC.RequestId)
            (content: String)
            : LspState =
            let responseJson =
              (LspExtension.FileSystemProvider.ReadFile.ReadFileResponse.ReadFileResponse
                { content = content })
              |> LspExtension.FileSystemProvider.ReadFile.ReadFileResponse.toJson
              |> (fun r ->
                JsonRPC.Response.Ok.make (Stdlib.Option.Option.Some(requestId)) r)
              |> Stdlib.AltJson.format

            logAndSendToClient responseJson
            state


          let handleReadFileRequest
            (state: LspState)
            (requestId: JsonRPC.RequestId)
            (params:
              LspExtension.FileSystemProvider.ReadFile.ReadFileParams.ReadFileParams)
            : LspState =
            // CLEANUP: make the 'remove scheme part of URI' more universal. Maybe be add it to Stdlib eg.`Stdlib.Uri.removeScheme`
            let nameForLookup =
              params.uri
              |> Stdlib.String.dropFirst 8L  // Drop "darkfs:/"
              |> Stdlib.String.dropLast 5L   // Drop ".dark"

            let getContent =
              // Check if this is a script request
              if Stdlib.String.startsWith nameForLookup "script/" then
                let scriptName =
                  nameForLookup
                  |> Stdlib.String.dropFirst 7L  // Drop "script/"

                match Builtin.cliScriptsGet scriptName with
                | Some script -> script.text
                | None -> $"Script not found: {scriptName}"
              // Check if this is a full module request
              elif Stdlib.String.startsWith nameForLookup "module/" then
                let modulePath =
                  nameForLookup
                  |> Stdlib.String.dropFirst 7L  // Drop "module/"
                  |> Stdlib.String.split "."

                // Search for all entities in this module
                let searchQuery =
                  LanguageTools.ProgramTypes.Search.SearchQuery
                    { currentModule = modulePath
                      text = ""
                      searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                      entityTypes = [
                        LanguageTools.ProgramTypes.Search.EntityType.Fn
                        LanguageTools.ProgramTypes.Search.EntityType.Type
                        LanguageTools.ProgramTypes.Search.EntityType.Value
                      ]
                      exactMatch = false }

                let searchResults = LanguageTools.PackageManager.Search.search searchQuery

                let functions =
                  searchResults.fns
                  |> Stdlib.List.map (fun fn -> fn |> PrettyPrinter.ProgramTypes.packageFn)
                  |> Stdlib.String.join "\n\n"

                let types =
                  searchResults.types
                  |> Stdlib.List.map (fun typ -> typ |> PrettyPrinter.ProgramTypes.packageType)
                  |> Stdlib.String.join "\n\n"

                let values =
                  searchResults.values
                  |> Stdlib.List.map (fun v -> v |> PrettyPrinter.ProgramTypes.packageValue)
                  |> Stdlib.String.join "\n\n"

                let allDefinitions =
                  [ types; values; functions ]
                  |> Stdlib.List.filter (fun s -> s != "")
                  |> Stdlib.String.join "\n\n"

                // Build module header with proper nesting
                let moduleHeader =
                  modulePath
                  |> Stdlib.List.indexedMap (fun i name ->
                    let indent = Stdlib.String.repeat "  " i
                    $"{indent}module {name} =")
                  |> Stdlib.String.join "\n"

                let contentIndent = Stdlib.String.repeat "  " (Stdlib.List.length modulePath)
                let indentedContent =
                  allDefinitions
                  |> Stdlib.String.split "\n"
                  |> Stdlib.List.map (fun line ->
                    if line == "" then line else $"{contentIndent}{line}")
                  |> Stdlib.String.join "\n"

                $"{moduleHeader}\n{indentedContent}"
              else
                // Handle package entities
                let pm = LanguageTools.PackageManager.pm ()

                // Try to find the entity in the package manager
                // First try as a type, then function, then value
                // Try to find as a type
                // CLEANUP: use `pm.findType nameForLookup` directly once the parser/interpreter is fixed
                let findType = pm.findType
                let getType = pm.getType
                match findType nameForLookup with
                | Some id ->
                  match getType id with
                  | Some typ -> typ |> PrettyPrinter.ProgramTypes.packageType
                  | None -> "Could not get type"
                | None ->
                  // Try to find as a function
                  // CLEANUP: use `pm.findFn nameForLookup` directly once the parser/interpreter is fixed
                  let findFn = pm.findFn
                  let getFn = pm.getFn
                  match findFn nameForLookup with
                  | Some id ->
                    match getFn id with
                    | Some fn -> fn |> PrettyPrinter.ProgramTypes.packageFn
                    | None -> "Could not get function"
                  | None ->
                    // Try to find as a value
                    // CLEANUP: use `pm.findValue nameForLookup` directly once the parser/interpreter is fixed
                    let findVal = pm.findValue
                    let getVal = pm.getValue
                    match findVal nameForLookup with
                    | Some id ->
                      match getVal id with
                      | Some value ->
                        value |> PrettyPrinter.ProgramTypes.packageValue
                      | None -> "Could not get value"
                    | None -> $"Package element not found: {nameForLookup}"

            sendResponse state requestId getContent


        module WriteFile =
          let handleWriteFileRequest
            (state: LspState)
            (requestId: JsonRPC.RequestId)
            (params:
              LspExtension.FileSystemProvider.WriteFile.WriteFileParams.WriteFileParams)
            : LspState =
            let content = params.content

            // Check if this is a script write request
            let nameForLookup =
              params.uri
              |> Stdlib.String.dropFirst 8L  // Drop "darkfs:/"
              |> Stdlib.String.dropLast 5L   // Drop ".dark"

            if Stdlib.String.startsWith nameForLookup "script/" then
              let scriptName =
                nameForLookup
                |> Stdlib.String.dropFirst 7L  // Drop "script/"

              // Update the script content
              match Builtin.cliScriptsUpdate scriptName content with
              | Ok () -> ()
              | Error _err -> () // TODO: Handle error properly

            let responseJson =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some(requestId))
                (Json.String content))
              |> Stdlib.AltJson.format

            logAndSendToClient responseJson
            state