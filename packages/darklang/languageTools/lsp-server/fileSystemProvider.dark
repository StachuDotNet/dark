module Darklang.LanguageTools.LspServer.FileSystemProvider


module ReadFile =
  let sendResponse
    (state: LspState)
    (requestId: JsonRPC.RequestId)
    (content: String)
    : LspState =
    let responseJson =
      (LspExtension.FileSystemProvider.ReadFile.ReadFileResponse.ReadFileResponse
        { content = content })
      |> LspExtension.FileSystemProvider.ReadFile.ReadFileResponse.toJson
      |> (fun r ->
        JsonRPC.Response.Ok.make (Stdlib.Option.Option.Some(requestId)) r)
      |> Stdlib.AltJson.format

    logAndSendToClient responseJson
    state


  let handleReadFileRequest
    (state: LspState)
    (requestId: JsonRPC.RequestId)
    (params:
      LspExtension.FileSystemProvider.ReadFile.ReadFileParams.ReadFileParams)
    : LspState =

    let branchID = state.branchID

    // CLEANUP: make the 'remove scheme part of URI' more universal. Maybe be add it to Stdlib eg.`Stdlib.Uri.removeScheme`
    let nameForLookup =
      params.uri
      |> Stdlib.String.dropFirst 8L  // Drop "darkfs:/"
      |> Stdlib.String.dropLast 5L   // Drop ".dark"

    let location =
      ProgramTypes.parsePackageLocation nameForLookup


    let getContent =
      // Check if this is a script request
      if Stdlib.String.startsWith nameForLookup "script/" then
        let scriptName =
          nameForLookup
          |> Stdlib.String.dropFirst 7L  // Drop "script/"

        match Builtin.cliScriptsGet scriptName with
        | Some script -> script.text
        | None -> $"Script not found: {scriptName}"
      else
        // Handle package entities
        let pm = LanguageTools.PackageManager.pm ()

        // Try to find as a specific entity (type, function, or value)
        let entityContent =
          match pm.findType branchID location with
          | Some id ->
            match pm.getType id with
            | Some typ -> Stdlib.Option.Option.Some(typ |> PrettyPrinter.ProgramTypes.packageType)
            | None -> Stdlib.Option.Option.None
          | None ->
            match pm.findFn branchID location with
            | Some id ->
              match pm.getFn id with
              | Some fn -> Stdlib.Option.Option.Some(fn |> PrettyPrinter.ProgramTypes.packageFn)
              | None -> Stdlib.Option.Option.None
            | None ->
              match pm.findValue branchID location with
              | Some id ->
                match pm.getValue id with
                | Some value -> Stdlib.Option.Option.Some(value |> PrettyPrinter.ProgramTypes.packageValue)
                | None -> Stdlib.Option.Option.None
              | None -> Stdlib.Option.Option.None

        match entityContent with
        | Some content -> content
        | None ->
          // Not a specific entity, treat as a module
          let modulePath = nameForLookup |> Stdlib.String.split "."

          // Search for all entities in this module
          let searchQuery =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = modulePath
                text = ""
                searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                entityTypes = [
                  LanguageTools.ProgramTypes.Search.EntityType.Fn
                  LanguageTools.ProgramTypes.Search.EntityType.Type
                  LanguageTools.ProgramTypes.Search.EntityType.Value
                ]
                exactMatch = false }

          let searchResults =
            LanguageTools.PackageManager.Search.search state.branchID searchQuery

          let functions =
            searchResults.fns
            |> Stdlib.List.map (fun locatedFn ->
              locatedFn.entity |> PrettyPrinter.ProgramTypes.packageFn)
            |> Stdlib.String.join "\n\n"

          let types =
            searchResults.types
            |> Stdlib.List.map (fun locatedType ->
              locatedType.entity |> PrettyPrinter.ProgramTypes.packageType)
            |> Stdlib.String.join "\n\n"

          let values =
            searchResults.values
            |> Stdlib.List.map (fun locatedValue ->
              locatedValue.entity |> PrettyPrinter.ProgramTypes.packageValue)
            |> Stdlib.String.join "\n\n"

          let allDefinitions =
            [ types; values; functions ]
            |> Stdlib.List.filter (fun s -> s != "")
            |> Stdlib.String.join "\n\n"

          // Build module header with proper nesting
          let moduleHeader =
            modulePath
            |> Stdlib.List.indexedMap (fun i name ->
              let indent = Stdlib.String.repeat "  " i
              $"{indent}module {name} =")
            |> Stdlib.String.join "\n"

          let contentIndent = Stdlib.String.repeat "  " (Stdlib.List.length modulePath)
          let indentedContent =
            allDefinitions
            |> Stdlib.String.split "\n"
            |> Stdlib.List.map (fun line ->
              if line == "" then line else $"{contentIndent}{line}")
            |> Stdlib.String.join "\n"

          if allDefinitions == "" then
            $"Module or package element not found: {nameForLookup}"
          else
            $"{moduleHeader}\n{indentedContent}"

    sendResponse state requestId getContent


module WriteFile =
  let handleWriteFileRequest
    (state: LspState)
    (requestId: JsonRPC.RequestId)
    (params:
      LspExtension.FileSystemProvider.WriteFile.WriteFileParams.WriteFileParams)
    : LspState =
    let content = params.content

    // Check if this is a script write request
    let nameForLookup =
      params.uri
      |> Stdlib.String.dropFirst 8L  // Drop "darkfs:/"
      |> Stdlib.String.dropLast 5L   // Drop ".dark"

    if Stdlib.String.startsWith nameForLookup "script/" then
      let scriptName =
        nameForLookup
        |> Stdlib.String.dropFirst 7L  // Drop "script/"

      // Update the script content
      match Builtin.cliScriptsUpdate scriptName content with
      | Ok () -> ()
      | Error _err -> () // TODO: Handle error properly

    let responseJson =
      (JsonRPC.Response.Ok.make
        (Stdlib.Option.Option.Some(requestId))
        (Json.String content))
      |> Stdlib.AltJson.format

    logAndSendToClient responseJson
    state