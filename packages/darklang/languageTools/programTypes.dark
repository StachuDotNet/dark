module Darklang =
  module LanguageTools =
    module ProgramTypes =

      /// Used to name where type/function/etc lives, eg a User module, or a Package module.
      module FQTypeName =

        /// The name of a thing in the package manager
        // TODO: We plan to use UUIDs for this, but this is a placeholder
        type Package =
          { owner: String
            modules: List<String>
            name: String
            version: Int64 }

        /// Part of the user's program (eg canvas or cli)
        type UserProgram =
          { modules: List<String>
            name: String
            version: Int64 }


        type FQTypeName =
          | Package of Package
          | UserProgram of UserProgram

      module FQFnName =
        type Builtin = { name: String; version: Int64 }

        type Package =
          { owner: String
            modules: List<String>
            name: String
            version: Int64 }

        type UserProgram =
          { modules: List<String>
            name: String
            version: Int64 }

        type FQFnName =
          | Builtin of Builtin
          | Package of Package
          | UserProgram of UserProgram


      module FQConstantName =
        type Builtin = { name: String; version: Int64 }

        type Package =
          { owner: String
            modules: List<String>
            name: String
            version: Int64 }

        type UserProgram =
          { modules: List<String>
            name: String
            version: Int64 }

        type FQConstantName =
          | Builtin of Builtin
          | Package of Package
          | UserProgram of UserProgram


      type NameResolution<'a> =
        Stdlib.Result.Result<'a, RuntimeErrors.NameResolution.Error>


      /// Darklang's available types (int, List<T>, user-defined types, etc.)
      type TypeReference =
        // A named variable, eg `a` in `List<a>`, matches anything
        | TVariable of String

        | TUnit
        | TBool
        | TInt64
        | TUInt64
        | TInt8
        | TUInt8
        | TInt16
        | TUInt16
        | TInt32
        | TUInt32
        | TInt128
        | TUInt128
        | TFloat
        | TChar
        | TString
        | TDateTime
        | TUuid

        | TList of TypeReference
        | TTuple of TypeReference * TypeReference * List<TypeReference>
        | TDict of TypeReference

        | TCustomType of
          NameResolution<FQTypeName.FQTypeName> *
          typeArgs: List<TypeReference>

        | TDB of TypeReference

        // TODO: this should be an NEList
        | TFn of List<TypeReference> * TypeReference


      type Const =
        | CInt64 of Int64
        | CUInt64 of UInt64
        | CInt8 of Int8
        | CUInt8 of UInt8
        | CInt16 of Int16
        | CUInt16 of UInt16
        | CInt32 of Int32
        | CUInt32 of UInt32
        | CInt128 of Int128
        | CUInt128 of UInt128
        | CFloat of Sign * String * String
        | CBool of Bool
        | CChar of Char
        | CString of String
        | CUnit
        | CTuple of Const * Const * List<Const>
        | CEnum of
          NameResolution<FQTypeName.FQTypeName> *
          caseName: String *
          fields: List<Const>
        | CList of List<Const>
        | CDict of List<String * Const>


      type LetPattern =
        | LPVariable of ID * name: String
        | LPTuple of
          ID *
          first: LetPattern *
          second: LetPattern *
          theRest: List<LetPattern>


      /// Used for pattern matching in a match statement
      type MatchPattern =
        | MPVariable of ID * String

        | MPUnit of ID
        | MPBool of ID * Bool
        | MPInt64 of ID * Int64
        | MPUInt64 of ID * UInt64
        | MPInt8 of ID * Int8
        | MPUInt8 of ID * UInt8
        | MPInt16 of ID * Int16
        | MPUInt16 of ID * UInt16
        | MPInt32 of ID * Int32
        | MPUInt32 of ID * UInt32
        | MPInt128 of ID * Int128
        | MPUInt128 of ID * UInt128
        | MPFloat of ID * Sign * String * String
        | MPChar of ID * String
        | MPString of ID * String

        | MPList of ID * List<MatchPattern>
        | MPListCons of ID * head: MatchPattern * tail: MatchPattern

        | MPTuple of ID * MatchPattern * MatchPattern * List<MatchPattern>

        | MPEnum of ID * caseName: String * fieldPats: List<MatchPattern>


      type BinaryOperation =
        | BinOpAnd
        | BinOpOr


      type InfixFnName =
        | ArithmeticPlus
        | ArithmeticMinus
        | ArithmeticMultiply
        | ArithmeticDivide
        | ArithmeticModulo
        | ArithmeticPower
        | ComparisonGreaterThan
        | ComparisonGreaterThanOrEqual
        | ComparisonLessThan
        | ComparisonLessThanOrEqual
        | ComparisonEquals
        | ComparisonNotEquals
        | StringConcat

      type Infix =
        | InfixFnCall of InfixFnName
        | BinOp of BinaryOperation


      type StringSegment =
        | StringText of String
        | StringInterpolation of Expr


      type PipeExpr =
        | EPipeVariable of ID * String * List<Expr>

        | EPipeLambda of ID * List<LetPattern> * Expr

        | EPipeInfix of ID * Infix * Expr

        | EPipeFnCall of
          ID *
          NameResolution<FQFnName.FQFnName> *
          typeArgs: List<TypeReference> *
          args: List<Expr>

        | EPipeEnum of
          ID *
          typeName: NameResolution<FQTypeName.FQTypeName> *
          caseName: String *
          fields: List<Expr>


      type MatchCase =
        { pat: MatchPattern
          whenCondition: Stdlib.Option.Option<Expr>
          rhs: Expr }

      // module PipeExpr =
      //   let toID (expr : PipeExpr) : id =
      //     match expr with
      //     | EPipeVariable (id, _)
      //     | EPipeLambda (id, _, _)
      //     | EPipeInfix (id, _, _)
      //     | EPipeFnCall (id, _, _, _)
      //     | EPipeEnum (id, _, _, _) -> id


      /// Expressions - the main part of the language.
      type Expr =
        | EUnit of ID

        // simple data

        | EBool of ID * Bool

        | EInt64 of ID * Int64

        | EUInt64 of ID * UInt64

        | EInt8 of ID * Int8

        | EUInt8 of ID * UInt8

        | EInt16 of ID * Int16

        | EUInt16 of ID * UInt16

        | EInt32 of ID * Int32

        | EUInt32 of ID * UInt32

        | EInt128 of ID * Int128

        | EUInt128 of ID * UInt128

        // Allow the user to have arbitrarily big numbers, even if they don't make sense as
        // floats. The float is split as we want to preserve what the user entered.
        // Strings are used as numbers lose the leading zeros (eg 7.00007)
        | EFloat of ID * Sign * String * String

        /// A character is an Extended Grapheme Cluster (hence why we use a String). This
        /// is equivalent to one screen-visible "character" in Unicode.
        | EChar of ID * String

        | EString of ID * List<StringSegment>


        // structures of data
        | EList of ID * List<Expr>

        | EDict of ID * List<String * Expr>

        | ETuple of ID * Expr * Expr * List<Expr>

        | ERecord of ID * NameResolution<FQTypeName.FQTypeName> * List<String * Expr>

        | EEnum of
          ID *
          typeName: NameResolution<FQTypeName.FQTypeName> *
          caseName: String *
          fields: List<Expr>

        // declaring and accessing variables
        | ELet of ID * LetPattern * Expr * Expr
        | EFieldAccess of ID * Expr * String
        | EVariable of ID * String
        | EConstant of ID * NameResolution<FQConstantName.FQConstantName>

        // control flow
        | EIf of
          ID *
          cond: Expr *
          thenExpr: Expr *
          elseExpr: Stdlib.Option.Option<Expr>

        | EMatch of ID * arg: Expr * cases: List<MatchCase>

        | EPipe of ID * Expr * List<PipeExpr>


        // function calls

        | EInfix of ID * Infix * Expr * Expr

        | ELambda of ID * List<LetPattern> * Expr

        // TODO do typeArgs actually apply here?
        // they definitely don't _always_ make sense.
        | EApply of ID * Expr * typeArgs: List<TypeReference> * args: List<Expr>

        | EFnName of ID * NameResolution<FQFnName.FQFnName>

        | ERecordUpdate of ID * record: Expr * updates: List<String * Expr>


      module Expr =
        let toID (expr: Expr) : ID =
          match expr with
          | EUnit id -> id
          | EBool(id, _) -> id
          | EInt64(id, _) -> id
          | EUInt64(id, _) -> id
          | EInt8(id, _) -> id
          | EUInt8(id, _) -> id
          | EInt16(id, _) -> id
          | EUInt16(id, _) -> id
          | EInt32(id, _) -> id
          | EUInt32(id, _) -> id
          | EInt128(id, _) -> id
          | EUInt128(id, _) -> id
          | EFloat(id, _, _, _) -> id
          | EChar(id, _) -> id
          | EString(id, _) -> id
          | ELet(id, _, _, _) -> id
          | EIf(id, _, _, _) -> id
          | EInfix(id, _, _, _) -> id
          | ELambda(id, _, _) -> id
          | EFieldAccess(id, _, _) -> id
          | EVariable(id, _) -> id
          | EApply(id, _, _, _) -> id
          | EList(id, _) -> id
          | EDict(id, _) -> id
          | ETuple(id, _, _, _) -> id
          | EPipe(id, _, _) -> id
          | ERecord(id, _, _) -> id
          | EEnum(id, _, _, _) -> id
          | EMatch(id, _, _) -> id
          | ERecordUpdate(id, _, _) -> id


      // Used to mark whether a function/type has been deprecated, and if so,
      // details about possible replacements/alternatives, and reasoning
      type Deprecation<'name> =
        | NotDeprecated

        /// The exact same thing is available under a new, preferred name
        | RenamedTo of 'name

        /// This has been deprecated and has a replacement we can suggest
        | ReplacedBy of 'name

        /// This has been deprecated and not replaced, provide a message for the user
        | DeprecatedBecause of String


      /// A stdlib-, user-, or package- defined type (an alias, record, or enum)
      module TypeDeclaration =
        type RecordField =
          { name: String
            typ: TypeReference
            description: String }

        type EnumField =
          { typ: TypeReference
            label: Stdlib.Option.Option<String>
            description: String }

        type EnumCase =
          { name: String
            fields: List<EnumField>
            description: String }

        type Definition =
          | Alias of TypeReference
          | Record of List<RecordField>
          | Enum of List<EnumCase>

        type TypeDeclaration =
          { typeParams: List<String>
            definition: Definition }


      module Handler =
        type CronInterval =
          | EveryDay
          | EveryWeek
          | EveryFortnight
          | EveryHour
          | Every12Hours
          | EveryMinute

        type Spec =
          | HTTP of route: String * method: String
          | Worker of name: String
          | Cron of name: String * interval: CronInterval
          | REPL of name: String

        type Handler = { tlid: TLID; ast: Expr; spec: Spec }


      type DB =
        { tlid: TLID
          name: String
          version: Int64
          typ: TypeReference }


      /// A type that a User defined within a Canvas
      type UserType =
        { tlid: TLID
          name: FQTypeName.UserProgram
          description: String
          declaration: TypeDeclaration.TypeDeclaration
          deprecated: Deprecation<FQTypeName.FQTypeName> }

      module UserFunction =
        type Parameter =
          { name: String
            typ: TypeReference
            description: String }

        type UserFunction =
          { tlid: TLID
            name: FQFnName.UserProgram
            typeParams: List<String>
            parameters: List<Parameter>
            returnType: TypeReference
            description: String
            deprecated: Deprecation<FQFnName.FQFnName>
            body: Expr }

      type UserConstant =
        { tlid: TLID
          name: FQConstantName.UserProgram
          description: String
          deprecated: Deprecation<FQFnName.FQFnName>
          body: Const }


      // module Toplevel =
      //   type T =
      //     | TLHandler of Handler.Handler
      //     | TLDB of DB
      //     | TLFunction of UserFunction.UserFunction
      //     | TLType of UserType.T

      //   let toTLID (tl : T) : tlid =
      //     match tl with
      //     | TLHandler h -> h.tlid
      //     | TLDB db -> db.tlid
      //     | TLFunction f -> f.tlid
      //     | TLType t -> t.tlid


      type Secret =
        { name: String
          value: String
          version: Int64 }


      type PackageType =
        { tlid: TLID
          id: Uuid
          name: FQTypeName.Package
          declaration: TypeDeclaration.TypeDeclaration
          description: String
          deprecated: Deprecation<FQTypeName.FQTypeName> }

      module PackageFn =
        type Parameter =
          { name: String
            typ: TypeReference
            description: String }

        type PackageFn =
          { tlid: TLID
            id: Uuid
            name: FQFnName.Package
            body: Expr
            typeParams: List<String>
            parameters: List<Parameter>
            returnType: TypeReference
            description: String
            deprecated: Deprecation<FQFnName.FQFnName> }

      type PackageConstant =
        { tlid: TLID
          id: Uuid
          name: FQConstantName.Package
          body: Const
          description: String
          deprecated: Deprecation<FQFnName.FQFnName> }


      module Packages =
        type Packages =
          { types: List<PackageType>
            constants: List<PackageConstant>
            fns: List<PackageFn.PackageFn> }

        let filterToModule
          (p: Packages)
          (owner: String)
          (moduleName: List<String>)
          : Packages =
          Packages
            { types =
                p.types
                |> Stdlib.List.filter (fun t ->
                  t.name.owner == owner && t.name.modules == moduleName)

              constants =
                p.constants
                |> Stdlib.List.filter (fun c ->
                  c.name.owner == owner && c.name.modules == moduleName)

              fns =
                p.fns
                |> Stdlib.List.filter (fun f ->
                  f.name.owner == owner && f.name.modules == moduleName) }


        // helper functions for converting a Packages to a List<Module>,
        // to represent packages in the module hierarchy
        type Module =
          { name: String
            types: List<PackageType>
            constants: List<PackageConstant>
            fns: List<PackageFn.PackageFn>
            submodules: List<Module> }

        let withType (ms: List<Module>) (t: PackageType) : List<Module> =
          match t.name.modules with
          | firstModuleNamePart :: submoduleNames ->
            let (foundModuleMaybe, otherModules) =
              ms |> Stdlib.List.partition (fun m -> m.name == firstModuleNamePart)

            match (foundModuleMaybe, submoduleNames) with
            | [], [] ->
              let newModule =
                Module
                  { name = firstModuleNamePart
                    types =
                      [ { t with
                            name = { t.name with modules = [] } } ]
                    fns = []
                    constants = []
                    submodules = [] }

              Stdlib.List.append otherModules [ newModule ]

            | [], submoduleNames ->
              let typeWithoutFirstModuleNamePartOfModule =
                { t with
                    name = { t.name with modules = submoduleNames } }

              let newModuleWithSubmodule =
                Module
                  { name = firstModuleNamePart
                    types = []
                    fns = []
                    constants = []
                    submodules = withType [] typeWithoutFirstModuleNamePartOfModule }

              Stdlib.List.append otherModules [ newModuleWithSubmodule ]

            | [ foundModule ], [] ->
              let updatedModule =
                { foundModule with
                    types =
                      Stdlib.List.append
                        foundModule.types
                        [ { t with
                              name = { t.name with modules = [] } } ] }

              Stdlib.List.append otherModules [ updatedModule ]

            | [ foundModule ], submoduleNames ->
              let typeWithoutFirstModuleNamePartOfModule =
                { t with
                    name = { t.name with modules = submoduleNames } }

              let updatedModule =
                { foundModule with
                    submodules =
                      withType
                        foundModule.submodules
                        typeWithoutFirstModuleNamePartOfModule }

              Stdlib.List.append otherModules [ updatedModule ]


        let withFn (ms: List<Module>) (f: PackageFn.PackageFn) : List<Module> =
          match f.name.modules with
          | firstModuleNamePart :: submoduleNames ->
            let (foundModuleMaybe, otherModules) =
              ms |> Stdlib.List.partition (fun m -> m.name == firstModuleNamePart)

            match (foundModuleMaybe, submoduleNames) with
            | [], [] ->
              let newModule =
                Module
                  { name = firstModuleNamePart
                    types = []
                    fns =
                      [ { f with
                            name = { f.name with modules = [] } } ]
                    constants = []
                    submodules = [] }

              Stdlib.List.append otherModules [ newModule ]

            | [], submoduleNames ->
              let fnWithoutFirstModuleNamePartOfModule =
                { f with
                    name = { f.name with modules = submoduleNames } }

              let newModuleWithSubmodule =
                Module
                  { name = firstModuleNamePart
                    types = []
                    fns = []
                    constants = []
                    submodules = withFn [] fnWithoutFirstModuleNamePartOfModule }

              Stdlib.List.append otherModules [ newModuleWithSubmodule ]

            | [ foundModule ], [] ->
              let updatedModule =
                { foundModule with
                    fns =
                      Stdlib.List.append
                        foundModule.fns
                        [ { f with
                              name = { f.name with modules = [] } } ] }

              Stdlib.List.append otherModules [ updatedModule ]

            | [ foundModule ], submoduleNames ->
              let fnWithoutFirstModuleNamePartOfModule =
                { f with
                    name = { f.name with modules = submoduleNames } }

              let updatedModule =
                { foundModule with
                    submodules =
                      withFn
                        foundModule.submodules
                        fnWithoutFirstModuleNamePartOfModule }

              Stdlib.List.append otherModules [ updatedModule ]

        let withConstant (ms: List<Module>) (c: PackageConstant) : List<Module> =
          match c.name.modules with
          | firstModuleNamePart :: submoduleNames ->
            let (foundModuleMaybe, otherModules) =
              ms |> Stdlib.List.partition (fun m -> m.name == firstModuleNamePart)

            match (foundModuleMaybe, submoduleNames) with
            | [], [] ->
              let newModule =
                Module
                  { name = firstModuleNamePart
                    types = []
                    fns = []
                    constants =
                      [ { c with
                            name = { c.name with modules = [] } } ]
                    submodules = [] }

              Stdlib.List.append otherModules [ newModule ]

            | [], submoduleNames ->
              let constantWithoutFirstModuleNamePartOfModule =
                { c with
                    name = { c.name with modules = submoduleNames } }

              let newModuleWithSubmodule =
                Module
                  { name = firstModuleNamePart
                    types = []
                    fns = []
                    constants = []
                    submodules =
                      withConstant [] constantWithoutFirstModuleNamePartOfModule }

              Stdlib.List.append otherModules [ newModuleWithSubmodule ]

            | [ foundModule ], [] ->
              let updatedModule =
                { foundModule with
                    constants =
                      Stdlib.List.append
                        foundModule.constants
                        [ { c with
                              name = { c.name with modules = [] } } ] }

              Stdlib.List.append otherModules [ updatedModule ]

            | [ foundModule ], submoduleNames ->
              let constantWithoutFirstModuleNamePartOfModule =
                { c with
                    name = { c.name with modules = submoduleNames } }

              let updatedModule =
                { foundModule with
                    submodules =
                      withConstant
                        foundModule.submodules
                        constantWithoutFirstModuleNamePartOfModule }

              Stdlib.List.append otherModules [ updatedModule ]


        let toModules (p: Packages) : List<Module> =
          let empty = []

          let modulesAfterTypes =
            Stdlib.List.fold p.types empty (fun modules t -> withType modules t)

          let modulesWithTypesAndFns =
            Stdlib.List.fold p.fns modulesAfterTypes (fun modules f ->
              withFn modules f)

          let modulesWithTypesAndFnsAndConstants =
            Stdlib.List.fold p.constants modulesWithTypesAndFns (fun modules c ->
              withConstant modules c)

          modulesWithTypesAndFnsAndConstants