module Darklang =
  module Cli =
    module CommandHelpers =
      module View =
        /// Converts an EntityCategory to its string representation
        let entityCategoryToString (category: EntityCategory) : String =
          match category with
          | Functions -> "functions"
          | Types -> "types"
          | Values -> "values"
          | Submodules -> "submodules"

        /// Converts a category index to an EntityCategory
        let indexToEntityCategory (index: Int64) : EntityCategory =
          match index with
          | 0L -> EntityCategory.Functions
          | 1L -> EntityCategory.Types
          | 2L -> EntityCategory.Values
          | 3L -> EntityCategory.Submodules

        /// Converts an EntityCategory to its index
        let entityCategoryToIndex (category: EntityCategory) : Int64 =
          match category with
          | Functions -> 0L
          | Types -> 1L
          | Values -> 2L
          | Submodules -> 3L

        module Rendering =

          /// Renders view content based on type
          let renderView (content: ViewContent) : String =
            match content with
            | ModuleView (category, items, selectedIndex) ->
              if Stdlib.List.isEmpty items then
                "(none)"
              else
                // Calculate how many items we can show (adapts based on terminal size)
                let terminalWidth = Terminal.getWidth ()
                let avgItemLength = 15L
                let itemsPerLine = Stdlib.Int64.max 1L (terminalWidth |> Stdlib.Int64.divide (avgItemLength + 2L))

                let maxLines =
                  if terminalWidth > 120L then 10L
                  else if terminalWidth > 80L then 5L
                  else 3L

                let maxViewportItems = itemsPerLine * maxLines

                // If we have more items than can fit, show a viewport around the selected item
                if (items |> Stdlib.List.length) > maxViewportItems && selectedIndex >= 0L then
                  let totalItems = items |> Stdlib.List.length
                  let halfViewport = maxViewportItems |> Stdlib.Int64.divide 2L

                  // Calculate viewport start, keeping selected item in center when possible
                  let viewportStart =
                    (Stdlib.Int64.max 0L (selectedIndex - halfViewport))
                    |> Stdlib.Int64.min (totalItems - maxViewportItems)

                  let viewportEnd = Stdlib.Int64.min totalItems (viewportStart + maxViewportItems)

                  let visibleItems =
                    items
                    |> Stdlib.List.drop viewportStart
                    |> Stdlib.List.take (viewportEnd - viewportStart)

                  let formattedItems =
                    visibleItems
                    |> Stdlib.List.indexedMap (fun localIndex item ->
                      let globalIndex = viewportStart + localIndex
                      if globalIndex == selectedIndex then
                        $"{Colors.magenta}[{item}]{Colors.reset}"
                      else
                        item)

                  // Add indicators for hidden items
                  let prefix = if viewportStart > 0L then "... " else ""
                  let suffix = if viewportEnd < totalItems then " ..." else ""

                  prefix ++ (Stdlib.String.join formattedItems ", ") ++ suffix
                else
                  // Show all items if they fit
                  let formattedItems =
                    items
                    |> Stdlib.List.indexedMap (fun index item ->
                      if index == selectedIndex then
                        $"{Colors.magenta}[{item}]{Colors.reset}"
                      else
                        item)
                  Stdlib.String.join formattedItems ", "

            | EntityDefinitionView entityDef ->
              // Line-based scrolling
              let totalLines = entityDef.lines |> Stdlib.List.length
              let viewportHeight = Terminal.getViewportHeight totalLines 5L

              // Ensure scroll position is within bounds (allow scrolling to line 0)
              let maxScrollPos = Stdlib.Int64.max 0L (totalLines - viewportHeight)
              let adjustedScrollPos =
                entityDef.scrollPosition
                |> Stdlib.Int64.max 0L
                |> Stdlib.Int64.min maxScrollPos

              // Get visible lines using simple slicing
              let visibleLines =
                entityDef.lines
                |> Stdlib.List.drop adjustedScrollPos
                |> Stdlib.List.take viewportHeight

              $"{Colors.blue}{entityDef.name}\n\n" ++ (visibleLines |> Stdlib.String.join "\n")

          /// Wraps the content with a help bar for module viewing
          let renderModuleViewingInterface (content: String) : String =
            let helpBar = $"{Colors.gray}↑/↓: categories  ←/→: entities  Enter: expand/view  b: back  q: quit{Colors.reset}\n\n"
            $"{Terminal.Display.clearScreen}{content}\n{helpBar}"

          /// Wraps the content with a help bar for entity definition viewing
          let renderEntityViewingInterface (content: String) : String =
            let helpBar = $"{Colors.gray}↑/↓: scroll  ←/→: page  Enter: collapse  b: back  q: quit{Colors.reset}\n\n"
            $"{Terminal.Display.clearScreen}{content}\n{helpBar}"


          /// Renders entity interface with scrolling
          let renderEntityInterface (entityName: String) (lines: List<String>) (scrollPosition: Int64) : String =
            let entityDef = EntityDefinition { name = entityName; lines = lines; scrollPosition = scrollPosition }
            let content = ViewContent.EntityDefinitionView entityDef
            let visibleContent = renderView content
            renderEntityViewingInterface visibleContent

          /// Formats a section of entities for display with expandable state and scrolling
          let formatEntitySection (viewingState: ViewingState) (category: EntityCategory) (entities: List<String>) : String =
            let sectionName = View.entityCategoryToString category
            let isExpanded = viewingState.expandedCategories |> Stdlib.List.member_v0 category

            let expandIndicator = if isExpanded then $"{Colors.purple}▼{Colors.reset}" else $"{Colors.purple}▶{Colors.reset}"
            let selectionIndicator = if viewingState.selectedCategory == category then "→ " else "  "
            let header = $"{selectionIndicator}{expandIndicator} {sectionName} {Colors.gray}({entities |> Stdlib.List.length |> Stdlib.Int64.toString}){Colors.reset}"

            if Stdlib.List.isEmpty entities then
              $"{header}\n\n(none)\n"
            else if isExpanded then
              // Extract just the names without module prefixes
              let shortNames =
                entities
                |> Stdlib.List.map (fun fullName ->
                  fullName
                  |> Stdlib.String.split "."
                  |> Stdlib.List.last
                  |> Stdlib.Option.withDefault fullName)

              if viewingState.selectedCategory == category && viewingState.selectedItemIndex >= 0L then
                let content = ViewContent.ModuleView (category, shortNames, viewingState.selectedItemIndex)
                let itemsDisplay = renderView content
                $"{header}\n\n{itemsDisplay}\n"
              else
                $"{header}\n\n" ++ (Stdlib.String.join shortNames ", ") ++ "\n"
            else
              $"{header}\n"

          /// Formats a section of entities for display with simple list (for non-interactive mode)
          let formatEntitySectionSimple (sectionName: String) (entities: List<String>) : String =
            if Stdlib.List.isEmpty entities then
              $"{sectionName}:\n\n(none)\n"
            else
              $"{sectionName}:\n\n" ++ (Stdlib.String.join entities "\n") ++ "\n"

          /// Formats module content for non-interactive display
          let formatModuleContentSimple (moduleContent: LanguageTools.ProgramTypes.Search.SearchResults) : String =
            let functionsSection =
              formatEntitySectionSimple
                "functions"
                (moduleContent.fns
                  |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name))

            let typesSection =
              formatEntitySectionSimple
                "types"
                (moduleContent.types
                  |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name))

            let valuesSection =
              formatEntitySectionSimple
                "values"
                (moduleContent.values
                  |> Stdlib.List.map (fun c -> LanguageTools.ProgramTypes.PackageValue.nameToString c.name))

            let submodulesSection =
              formatEntitySectionSimple
                "submodules"
                (moduleContent.submodules
                  |> Stdlib.List.map (fun m ->
                    m
                    |> Stdlib.List.map (fun s -> s |> Stdlib.String.join "."))
                  |> Stdlib.List.flatten)

            functionsSection ++
            typesSection ++
            valuesSection ++
            submodulesSection

          /// Formats module content for interactive display
          let formatModuleContent (viewingState: ViewingState) : String =
            let functionsSection =
              formatEntitySection
                viewingState
                EntityCategory.Functions
                (viewingState.moduleContent.fns
                  |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name))

            let typesSection =
              formatEntitySection
                viewingState
                EntityCategory.Types
                (viewingState.moduleContent.types
                  |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name))

            let valuesSection =
              formatEntitySection
                viewingState
                EntityCategory.Values
                (viewingState.moduleContent.values
                  |> Stdlib.List.map (fun c -> LanguageTools.ProgramTypes.PackageValue.nameToString c.name))

            let submodulesSection =
              formatEntitySection
                viewingState
                EntityCategory.Submodules
                (viewingState.moduleContent.submodules
                  |> Stdlib.List.map (fun m ->
                    m
                    |> Stdlib.List.map (fun singleModulePath ->
                      Stdlib.String.join singleModulePath "."))
                  |> Stdlib.List.flatten
                  |> Stdlib.List.filter (fun submodule ->
                    submodule != viewingState.entityName))

            // Scrollable content (everything below the module title)
            let scrollableContent = Rendering.buildScrollableContent viewingState

            // Apply viewport scrolling only to the scrollable content
            let scrollableLines = scrollableContent |> Stdlib.String.split "\n"
            let totalScrollableLines = scrollableLines |> Stdlib.List.length

            // Calculate viewport height for module view
            let availableScrollHeight = Terminal.getViewportHeight totalScrollableLines 4L

            // Ensure scroll position is within bounds
            let maxScrollPos = Stdlib.Int64.max 0L (totalScrollableLines - availableScrollHeight)
            let adjustedScrollPos =
              viewingState.viewportScrollPosition
              |> Stdlib.Int64.max 0L
              |> Stdlib.Int64.min maxScrollPos

            let visibleScrollableLines =
              scrollableLines
              |> Stdlib.List.drop adjustedScrollPos
              |> Stdlib.List.take availableScrollHeight

            let contentPart =
              if Stdlib.List.isEmpty visibleScrollableLines then
                ""
              else
                visibleScrollableLines |> Stdlib.String.join "\n"

            // Always show header, even if no room for content (match entity definition format)
            $"{Colors.blue}Module: {viewingState.entityName}{Colors.reset}\n\n" ++ contentPart

          /// Builds the scrollable content for a viewing state
          let buildScrollableContent (viewingState: ViewingState) : String =
            let functionsSection =
              formatEntitySection
                viewingState
                EntityCategory.Functions
                (viewingState.moduleContent.fns
                  |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name))

            let typesSection =
              formatEntitySection
                viewingState
                EntityCategory.Types
                (viewingState.moduleContent.types
                  |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name))

            let valuesSection =
              formatEntitySection
                viewingState
                EntityCategory.Values
                (viewingState.moduleContent.values
                  |> Stdlib.List.map (fun c -> LanguageTools.ProgramTypes.PackageValue.nameToString c.name))

            let submodulesSection =
              formatEntitySection
                viewingState
                EntityCategory.Submodules
                (viewingState.moduleContent.submodules
                  |> Stdlib.List.map (fun m ->
                    m
                    |> Stdlib.List.map (fun singleModulePath ->
                      Stdlib.String.join singleModulePath "."))
                  |> Stdlib.List.flatten
                  |> Stdlib.List.filter (fun submodule ->
                    submodule != viewingState.entityName))

            "\n" ++
            functionsSection ++ "\n" ++
            typesSection ++ "\n" ++
            valuesSection ++ "\n" ++
            submodulesSection

        module Navigation =
          type ScrollDirection = Up | Down | PageUp | PageDown

          /// Helper function to handle module viewport scrolling
          let handleModuleViewportScroll (state: State) (direction: ScrollDirection) : (State * List<Msg>) =
            match state.viewingState with
            | Some viewingState ->
              // Build the scrollable content to calculate total lines
              let scrollableContent = Rendering.buildScrollableContent viewingState
              let scrollableLines = scrollableContent |> Stdlib.String.split "\n"
              let totalLines = scrollableLines |> Stdlib.List.length
              let viewportHeight = Terminal.getViewportHeight totalLines 4L

              let newScrollPos =
                match direction with
                | Up -> Stdlib.Int64.max 0L (viewingState.viewportScrollPosition - 1L)
                | Down -> viewingState.viewportScrollPosition + 1L // Will be bounded in formatModuleContent
                | PageUp -> Stdlib.Int64.max 0L (viewingState.viewportScrollPosition - viewportHeight)
                | PageDown -> viewingState.viewportScrollPosition + viewportHeight // Will be bounded in formatModuleContent

              let newViewingState = { viewingState with viewportScrollPosition = newScrollPos }
              let moduleView = Rendering.formatModuleContent newViewingState
              let completeInterface = Rendering.renderModuleViewingInterface moduleView
              let newState =
                { state with
                    viewingState = Stdlib.Option.Option.Some newViewingState
                    commandResult = CommandResult.Success completeInterface
                    needsFullRedraw = true }
              (newState, [])
            | None ->
              (state, [])

          /// Helper function to handle entity definition scrolling
          let handleEntityScroll (state: State) (direction: ScrollDirection) : (State * List<Msg>) =
            match state.viewingState with
            | Some viewingState ->
              match viewingState.entityDefinition with
              | Some entityDef ->
                // Line-based scrolling
                let totalLines = entityDef.lines |> Stdlib.List.length
                let contentHeight = Terminal.getViewportHeight totalLines 5L
                let maxScroll = Stdlib.Int64.max 0L (totalLines - contentHeight)

                let scrollAmount =
                  match direction with
                  | PageUp | PageDown -> contentHeight
                  | _ -> 1L

                let newScrollPos =
                  match direction with
                    | Up -> Stdlib.Int64.max 0L (entityDef.scrollPosition - scrollAmount)
                    | Down -> Stdlib.Int64.min maxScroll (entityDef.scrollPosition + scrollAmount)
                    | PageUp -> Stdlib.Int64.max 0L (entityDef.scrollPosition - scrollAmount)
                    | PageDown -> Stdlib.Int64.min maxScroll (entityDef.scrollPosition + scrollAmount)

                let newEntityDef = { entityDef with scrollPosition = newScrollPos }
                let completeInterface = Rendering.renderEntityInterface newEntityDef.name newEntityDef.lines newEntityDef.scrollPosition
                let newViewingState = { viewingState with entityDefinition = Stdlib.Option.Option.Some newEntityDef }
                let newState =
                  { state with
                      viewingState = Stdlib.Option.Option.Some newViewingState
                      commandResult = CommandResult.Success completeInterface
                      needsFullRedraw = true }
                (newState, [])
              | None ->
                (state, [])
            | None ->
              (state, [])

          /// Find the line position of a category header by searching in the built content
          let findCategoryLinePosition (scrollableContent: String) (targetCategory: EntityCategory) : Int64 =
            let categoryName = View.entityCategoryToString targetCategory
            let lines = scrollableContent |> Stdlib.String.split "\n"

            // Look for line containing the category name (simple string search)
            lines
            |> Stdlib.List.indexedMap (fun index line -> (index, line))
            |> Stdlib.List.findFirst (fun (_, line) -> line |> Stdlib.String.contains categoryName)
            |> Stdlib.Option.map (fun (index, _) -> index)
            |> Stdlib.Option.withDefault 0L

          /// Scroll to make a category visible (simple approach)
          let ensureCategoryVisible (viewingState: ViewingState) (category: EntityCategory) : Int64 =
            // Build scrollable content and find category position in it
            let scrollableContent = Rendering.buildScrollableContent viewingState
            let categoryLine = findCategoryLinePosition scrollableContent category
            let scrollableLines = scrollableContent |> Stdlib.String.split "\n"
            let totalLines = scrollableLines |> Stdlib.List.length
            let viewportHeight = Terminal.getViewportHeight totalLines 4L

            let currentScrollPos = viewingState.viewportScrollPosition
            let viewportTop = currentScrollPos
            let viewportBottom = currentScrollPos + viewportHeight - 1L

            // If category is not visible, scroll to show it
            if categoryLine < viewportTop || categoryLine > viewportBottom then
              // Category is outside viewport - scroll to show it at the top
              Stdlib.Int64.max 0L categoryLine
            else
              // Category is already visible - keep current scroll position
              currentScrollPos

          /// Helper function to update selection and redraw view with auto-scroll to keep selection visible
          let updateSelection (state: State) (category: EntityCategory) (itemIndex: Int64) : (State * List<Msg>) =
            match state.viewingState with
            | Some viewingState ->
              // If switching to a different category, collapse all. If staying in same category, preserve expanded state
              let newExpandedCategories =
                if category == viewingState.selectedCategory then
                  viewingState.expandedCategories  // Keep current expanded state when navigating within category
                else
                  []  // Collapse when switching categories

              let tempViewingState = { viewingState with selectedCategory = category; selectedItemIndex = itemIndex; expandedCategories = newExpandedCategories }
              let newScrollPosition = ensureCategoryVisible tempViewingState category

              let newViewingState = { tempViewingState with entityDefinition = Stdlib.Option.Option.None; viewportScrollPosition = newScrollPosition }
              let moduleView = Rendering.formatModuleContent newViewingState
              let completeInterface = Rendering.renderModuleViewingInterface moduleView
              let newState = { state with viewingState = Stdlib.Option.Option.Some newViewingState; commandResult = CommandResult.Success completeInterface; needsFullRedraw = true }
              (newState, [])
            | None ->
              (state, [])

          /// Handle key presses in viewing mode
          let handleViewingModeKey (state: State) (viewingState: ViewingState) (key: Stdlib.Cli.Stdin.Key.Key) (modifiers: Stdlib.Cli.Stdin.Modifiers.Modifiers) : (State * List<Msg>) =
            // Check for viewport scrolling (Ctrl+Arrow or Shift+Arrow for mouse wheel)
            match (key, modifiers.shift, modifiers.ctrl) with
            | (UpArrow, _, true) | (UpArrow, true, false) ->
              match viewingState.entityDefinition with
              | Some _ -> handleEntityScroll state ScrollDirection.Up
              | None -> handleModuleViewportScroll state ScrollDirection.Up
            | (DownArrow, _, true) | (DownArrow, true, false) ->
              match viewingState.entityDefinition with
              | Some _ -> handleEntityScroll state ScrollDirection.Down
              | None -> handleModuleViewportScroll state ScrollDirection.Down
            | _ ->
              match key with
              | UpArrow ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.Up
                | None ->
                  let currentIndex = View.entityCategoryToIndex viewingState.selectedCategory
                  let newIndex = Stdlib.Int64.max 0L (currentIndex - 1L)
                  let newCategory = View.indexToEntityCategory newIndex
                  updateSelection state newCategory (-1L)
              | DownArrow ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.Down
                | None ->
                  let currentIndex = View.entityCategoryToIndex viewingState.selectedCategory
                  let newIndex = Stdlib.Int64.min 3L (currentIndex + 1L)
                  let newCategory = View.indexToEntityCategory newIndex
                  updateSelection state newCategory (-1L)
              | Enter ->
                let isExpanded = viewingState.expandedCategories |> Stdlib.List.member_v0 viewingState.selectedCategory
                if isExpanded && viewingState.selectedItemIndex >= 0L then
                  (state, [Msg.ShowItemDefinition viewingState.selectedCategory viewingState.selectedItemIndex])
                else
                  (state, [Msg.ToggleCategory viewingState.selectedCategory])
              | LeftArrow ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.PageUp
                | None ->
                  let currentExpanded = viewingState.expandedCategories |> Stdlib.List.member_v0 viewingState.selectedCategory
                  if currentExpanded then
                    let currentEntities = EntityLookup.getEntitiesForCategory viewingState.moduleContent viewingState.selectedCategory viewingState.entityName
                    let newItemIndex = Stdlib.Int64.max (-1L) (viewingState.selectedItemIndex - 1L)
                    updateSelection state viewingState.selectedCategory newItemIndex
                  else
                    (state, [])
              | RightArrow ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.PageDown
                | None ->
                  let currentExpanded = viewingState.expandedCategories |> Stdlib.List.member_v0 viewingState.selectedCategory
                  if currentExpanded then
                    let currentEntities = EntityLookup.getEntitiesForCategory viewingState.moduleContent viewingState.selectedCategory viewingState.entityName
                    let maxIndex = (currentEntities |> Stdlib.List.length) - 1L
                    let newItemIndex = Stdlib.Int64.min maxIndex (viewingState.selectedItemIndex + 1L)
                    updateSelection state viewingState.selectedCategory newItemIndex
                  else
                    (state, [])
              | B ->
                match viewingState.entityDefinition with
                | Some _ ->
                  let newViewingState = { viewingState with entityDefinition = Stdlib.Option.Option.None }
                  let moduleView = Rendering.formatModuleContent newViewingState
                  let completeInterface = Rendering.renderModuleViewingInterface moduleView
                  let newState =
                    { state with
                        viewingState = Stdlib.Option.Option.Some newViewingState
                        commandResult = CommandResult.Success completeInterface
                        needsFullRedraw = true }
                  (newState, [])
                | None ->
                  if viewingState.entityName |> Stdlib.String.contains "." then
                    let parts = viewingState.entityName |> Stdlib.String.split "."
                    let parentParts = parts |> Stdlib.List.dropLast
                    match parentParts with
                    | [] ->
                      (state, [])
                    | _ ->
                      let parentModule = Stdlib.String.join parentParts "."
                      (state, [Msg.SubmitCommand $"view {parentModule}"])
                  else
                    (state, [])
              | PageUp ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.PageUp
                | None ->
                  handleModuleViewportScroll state ScrollDirection.PageUp
              | PageDown ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.PageDown
                | None ->
                  handleModuleViewportScroll state ScrollDirection.PageDown
              | Q ->
                let exitAlternateScreen = Terminal.Display.exitAltScreen
                let newState =
                  { state with
                      viewingState = Stdlib.Option.Option.None
                      commandResult = CommandResult.Success (exitAlternateScreen ++ "Exited viewing mode")
                      needsFullRedraw = true }
                (newState, [])
              | _ ->
                (state, [])

        module EntityLookup =
          /// Helper function to render entity definition
          let renderEntityDefinition (state: State) (entityType: String) (fullyQualifiedName: String) (prettyPrinted: String) : (State * List<Msg>) =
            match state.viewingState with
            | Some viewingState ->
              let (entityDefinition, updatedViewingState) = getOrCreateEntityDefinition viewingState entityType fullyQualifiedName prettyPrinted
              let completeInterface = Rendering.renderEntityInterface entityDefinition.name entityDefinition.lines entityDefinition.scrollPosition
              let finalViewingState = { updatedViewingState with entityDefinition = Stdlib.Option.Option.Some entityDefinition }
              let newState =
                { state with
                    commandResult = CommandResult.Success completeInterface
                    viewingState = Stdlib.Option.Option.Some finalViewingState
                    needsFullRedraw = true }
              (newState, [])
            | None ->
              let highlighted = Cli.SyntaxHighlighting.highlightCode prettyPrinted
              let newState =
                { state with
                    commandResult = CommandResult.Success $"{entityType}: {fullyQualifiedName}\n\n{highlighted}" }
              (newState, [])

          /// Helper function to view an entity by its fully qualified name
          let viewEntityByName (state: State) (fullyQualifiedName: String) : (State * List<Msg>) =
            let modules = fullyQualifiedName |> Stdlib.String.split "." |> Stdlib.List.dropLast
            let text = fullyQualifiedName |> Stdlib.String.split "." |> Stdlib.List.last |> Builtin.unwrap

            let query = Command.createSearchQuery modules text
            let moduleContent = LanguageTools.PackageManager.Search.search query

            match findEntity moduleContent text with
            | Some ((entityType, prettyPrinted)) ->
              renderEntityDefinition state entityType fullyQualifiedName prettyPrinted
            | None ->
              let newState =
                { state with
                    commandResult = CommandResult.Error $"Entity not found: {fullyQualifiedName}" }
              (newState, [])

          /// Entity lookup that finds an entity by name and returns its type and pretty-printed definition
          let findEntity (moduleContent: LanguageTools.ProgramTypes.Search.SearchResults) (name: String) : Stdlib.Option.Option<(String * String)> =
            let valueResult =
              moduleContent.values
              |> Stdlib.List.findFirst (fun v -> v.name.name == name)
              |> Stdlib.Option.map (fun v -> ("Value", PrettyPrinter.ProgramTypes.packageValue v))

            let functionResult =
              moduleContent.fns
              |> Stdlib.List.findFirst (fun f -> f.name.name == name)
              |> Stdlib.Option.map (fun f -> ("Function", PrettyPrinter.ProgramTypes.packageFn f))

            let typeResult =
              moduleContent.types
              |> Stdlib.List.findFirst (fun t -> t.name.name == name)
              |> Stdlib.Option.map (fun t -> ("Type", PrettyPrinter.ProgramTypes.packageType t))

            match valueResult with
            | Some _ -> valueResult
            | None ->
              match functionResult with
              | Some _ -> functionResult
              | None -> typeResult

          /// Gets entities from moduleContent for a given category
          let getEntitiesForCategory (moduleContent: LanguageTools.ProgramTypes.Search.SearchResults) (category: EntityCategory) (currentEntityName: String) : List<String> =
            match category with
            | Functions -> moduleContent.fns |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name)
            | Types -> moduleContent.types |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name)
            | Values -> moduleContent.values |> Stdlib.List.map (fun value -> LanguageTools.ProgramTypes.PackageValue.nameToString value.name)
            | Submodules ->
              moduleContent.submodules
              |> Stdlib.List.map (fun m ->
                m
                |> Stdlib.List.map (fun singleModulePath ->
                  Stdlib.String.join singleModulePath "."))
              |> Stdlib.List.flatten
              |> Stdlib.List.filter (fun submodule ->
                submodule != currentEntityName)

          /// Gets an entity definition from cache or creates a new one
          let getOrCreateEntityDefinition (viewingState: ViewingState) (entityType: String) (fullyQualifiedName: String) (prettyPrinted: String) : (EntityDefinition * ViewingState) =
            let cacheKey = $"{entityType}:{fullyQualifiedName}"

            match viewingState.entityCache |> Stdlib.List.findFirst (fun (key, _) -> key == cacheKey) with
            | Some ((_, cachedDef)) ->
              // Always reset scroll position to 0 when viewing an entity definition
              let resetDef = { cachedDef with scrollPosition = 0L }
              (resetDef, viewingState)
            | None ->
              // Create new definition and add to cache
              let highlighted = Cli.SyntaxHighlighting.highlightCode prettyPrinted
              let lines = highlighted |> Stdlib.String.split "\n"
              let entityDefinition = EntityDefinition { name = $"{entityType}: {fullyQualifiedName}"; lines = lines; scrollPosition = 0L }
              let newCache = viewingState.entityCache |> Stdlib.List.push (cacheKey, entityDefinition)
              let newViewingState = { viewingState with entityCache = newCache }
              (entityDefinition, newViewingState)