module Darklang =
  module Cli =
      // Helper function that processes a list of messages
    let processMessages (state: State) (msgs: List<Msg>) : State =
      match msgs with
      | [] -> state
      | msg :: remainingMsgs ->
        // Process this message
        let (updatedState, newMsgs) = update state msg

        // First process any new messages generated by this update
        let stateAfterNewMsgs =
          if Stdlib.List.isEmpty newMsgs then
            updatedState
          else
            processMessages updatedState newMsgs

        // Then continue with the remaining messages
        processMessages stateAfterNewMsgs remainingMsgs


    let runInternalLoop (state: State): Int64 =
      // Handle rendering based on the interaction mode
      let stateAfterRender =
        match state.interactionMode with
        // In Regular mode, don't clear the screen, just print the prompt
        | Regular ->
          if state.needsFullRedraw then
            // For command results, print the full render
            Builtin.print (render state)
            { state with needsFullRedraw = false }
          else
            // For regular key input, just update the prompt line in-place
            // Clear the current prompt line and reprint it
            Builtin.print "\r\u001b[K"
            Builtin.print (renderPromptOnly state)
            state

        // In RefreshScreen mode, clear the screen and redraw everything
        | RefreshScreen ->
          if state.needsFullRedraw then
            Builtin.stdoutClear()
            Builtin.print (render state)
            { state with needsFullRedraw = false }
          else
            // For regular key input, just update the prompt line in-place
            Builtin.print "\r\u001b[K"
            Builtin.print (renderPromptOnly state)
            state

      // Check if we should exit before reading input
      if stateAfterRender.isExiting then
        0L
      else
        let keyRead = Stdlib.Cli.Stdin.readKey ()
        let msg = Msg.KeyPressed(keyRead.key, keyRead.modifiers, keyRead.keyChar)
        let (newState, messages) = update stateAfterRender msg

        // Process all messages
        let stateAfterMessages = processMessages newState messages

        // Check if we should exit
        if keyRead.key == Stdlib.Cli.Stdin.Key.Key.Escape || stateAfterMessages.isExiting then
          0L
        else
          // Continue the REPL loop with the updated state
          runInternalLoop stateAfterMessages



    /// Starts the REPL with the initial state
    let executeCliCommand (args: List<String>) : Int64 =
      let (state, initialMsgs) = init args
      let state = processMessages state initialMsgs
      match state.interactionMode with
      | NonInteractive ->
        match state.commandResult with
        | Success msg -> Builtin.printLine msg; 0L
        | Error msg -> Builtin.printLine $"Error: {msg}"; 1L
        | Info msg -> Builtin.printLine msg; 0L
        | None -> 0L
      | _ ->
        runInternalLoop state


    module ExecutionError =
      // TODO migrate this to some ParseAndExecuteScript submodule
      type ExecutionError =
        { msg: String; metadata: Dict<String> }

      let toString (err: ExecutionError) : String =
        let metadataStr =
          err.metadata
          |> Stdlib.Dict.toList
          |> Stdlib.List.map (fun (k, v) -> $"- {k}: {v}")
          |> Stdlib.String.join "\n"
        $"Error: {err.msg}\n{metadataStr}"


