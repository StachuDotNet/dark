module Darklang =
  module Cli =
    /// Everything related to the installation of the Darklang CLI
    /// , globally (with regards to the current user account)
    ///
    /// (as opposed to running the CLI without any install,
    /// with a simple adjacent .darklang directory)
    module Installation =
      /// CLI installation mode
      type InstallationMode =
        /// Runs from any location
        /// Creates files as needed in an adjacent .darklang directory
        | Portable

        /// Globally installed with system integration, per user account
        | Installed


      /// Convert installation mode to string for display
      let installationModeToString (mode: InstallationMode) : String =
        match mode with
        | Portable -> "portable"
        | Installed -> "installed"


      /// Detect current CLI installation mode based on executable location
      let getInstallationMode () : InstallationMode =
        let executablePath = Builtin.getCurrentExecutablePath ()
        let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap
        let homeDir =
          match host.os with
          | Windows ->
            match Stdlib.Cli.PowerShell.getHomeDirectory () with
            | Ok dir -> dir
            | Error _ -> ""
          | _ ->
            match Stdlib.Cli.Unix.getHomeDirectory () with
            | Ok dir -> dir
            | Error _ -> ""

        if homeDir == "" then
          InstallationMode.Portable
        else
          let globalBinPath = 
            match host.os with
            | Windows -> $"{homeDir}\\.darklang\\bin\\"
            | _ -> $"{homeDir}/.darklang/bin/"
          
          // Check if executable is running from global installation directory
          if Stdlib.String.contains executablePath globalBinPath then
            InstallationMode.Installed
          else
            InstallationMode.Portable

      /// Check if the latest version of the Darklang CLI is installed,
      /// by comparing:
      /// - the latest release on GitHub,
      /// (against)
      /// - the locally-installed version, as recorded in the `config.json` file
      let isAtLatestVersion
        (configPath: String)
        : Stdlib.Result.Result<Bool, String> =
        match GitHub.Releases.getLatestReleaseTag () with
        | Ok latestVersion ->
          match Config.readLocallyInstalledDarklangVersion configPath with
          | Ok localVersion -> Stdlib.Result.Result.Ok(localVersion == latestVersion)
          | Error _e -> Stdlib.Result.Result.Error "Couldn't determine local version"
        | Error _e ->
          Stdlib.Result.Result.Error
            "Couldn't determine latest version -- whatever you're about to try probably won't work"

      /// Migrate portable database to global installation
      let migratePortableData (host: Stdlib.Cli.Host.Host) (portableDbPath: String) : Stdlib.Result.Result<Unit, String> =
        let homeDir =
          match host.os with
          | Windows ->
            match Stdlib.Cli.PowerShell.getHomeDirectory () with
            | Ok dir -> dir
            | Error _ -> ""
          | _ ->
            match Stdlib.Cli.Unix.getHomeDirectory () with
            | Ok dir -> dir
            | Error _ -> ""

        if homeDir == "" then
          Stdlib.Result.Result.Error "Unable to determine home directory"
        else
          let globalDbPath = $"{homeDir}/.darklang/data.db"
          match host.os with
          | Windows -> Stdlib.Cli.PowerShell.copyFile portableDbPath globalDbPath
          | _ -> Stdlib.Cli.Unix.copyFile portableDbPath globalDbPath


      /// Check if a global installation exists
      let globalInstallationExists (host: Stdlib.Cli.Host.Host) : Bool =
        let homeDir =
          match host.os with
          | Windows ->
            match Stdlib.Cli.PowerShell.getHomeDirectory () with
            | Ok dir -> dir
            | Error _ -> ""
          | _ ->
            match Stdlib.Cli.Unix.getHomeDirectory () with
            | Ok dir -> dir
            | Error _ -> ""
        
        if homeDir == "" then
          false
        else
          let globalBinPath = 
            match host.os with
            | Windows -> $"{homeDir}\\.darklang\\bin\\dark.exe"
            | _ -> $"{homeDir}/.darklang/bin/dark"
          
          match host.os with
          | Windows -> Stdlib.Cli.PowerShell.fileExists globalBinPath
          | _ -> Stdlib.Cli.Unix.fileExists globalBinPath


      /// Install CLI by copying the current binary (for development/testing)
      let installFromCurrentBinary (host: Stdlib.Cli.Host.Host) : Stdlib.Result.Result<String, String> =
        let currentBinaryPath = Builtin.getCurrentExecutablePath ()
        let currentDir = Builtin.directoryCurrent ()
        let portableDbPath = $"{currentDir}/.darklang/data.db"
        
        let homeDir =
          match host.os with
          | Windows ->
            match Stdlib.Cli.PowerShell.getHomeDirectory () with
            | Ok dir -> dir
            | Error _ -> ""
          | _ ->
            match Stdlib.Cli.Unix.getHomeDirectory () with
            | Ok dir -> dir
            | Error _ -> ""
        
        if homeDir == "" then
          Stdlib.Result.Result.Error "Unable to determine home directory"
        else
          let globalBinDir = 
            match host.os with
            | Windows -> $"{homeDir}\\.darklang\\bin\\"
            | _ -> $"{homeDir}/.darklang/bin/"
          
          let globalBinaryPath = 
            match host.os with
            | Windows -> $"{globalBinDir}dark.exe"
            | _ -> $"{globalBinDir}dark"
          
          let configPath = 
            match host.os with
            | Windows -> $"{homeDir}\\.darklang\\config.json"
            | _ -> $"{homeDir}/.darklang/config.json"
          
          // Create directories and copy binary
          let createDirsAndCopy =
            match host.os with
            | Windows ->
              match Stdlib.Cli.PowerShell.ensureDirectoryExists globalBinDir with
              | Ok _ -> Stdlib.Cli.PowerShell.copyFile currentBinaryPath globalBinaryPath
              | Error e -> Stdlib.Result.Result.Error e
            | _ ->
              match Stdlib.Cli.Unix.ensureDirectoryExists globalBinDir with
              | Ok _ -> 
                match Stdlib.Cli.Unix.copyFile currentBinaryPath globalBinaryPath with
                | Ok _ -> Stdlib.Cli.Unix.grantExecutePermission globalBinaryPath
                | Error e -> Stdlib.Result.Result.Error e
              | Error e -> Stdlib.Result.Result.Error e
          
          match createDirsAndCopy with
          | Ok _ ->
            // Create config.json and set up shell integration
            let setupResult = 
              match host.os with
              | Windows ->
                match Stdlib.Cli.PowerShell.createFile configPath with
                | Ok _ ->
                  match Config.updateVersion configPath "local-binary" with
                  | Ok _ -> Stdlib.Result.Result.Ok()
                  | Error e -> Stdlib.Result.Result.Error e
                | Error e -> Stdlib.Result.Result.Error e
              | _ ->
                match Config.updateVersion configPath "local-binary" with
                | Ok _ ->
                  match Stdlib.Cli.Unix.deleteAlias host.defaultShell "dark" with
                  | Ok _ ->
                    match Stdlib.Cli.Unix.addAlias host.defaultShell "dark" globalBinaryPath with
                    | Ok _ -> Stdlib.Result.Result.Ok()
                    | Error e -> Stdlib.Result.Result.Error e
                  | Error _ -> 
                    // Ignore error if alias doesn't exist, try to add it anyway
                    match Stdlib.Cli.Unix.addAlias host.defaultShell "dark" globalBinaryPath with
                    | Ok _ -> Stdlib.Result.Result.Ok()
                    | Error e -> Stdlib.Result.Result.Error e
                | Error e -> Stdlib.Result.Result.Error e
            
            match setupResult with
            | Ok _ ->
              // Ask about data migration
              Builtin.printLine "Would you like to copy the data from this portable directory to the installation, or start fresh? (copy/fresh, default: fresh): "
              let migrateChoice = (Builtin.stdinReadLine ()) |> Stdlib.String.trim
              
              if migrateChoice == "copy" then
                if Stdlib.Cli.Unix.fileExists portableDbPath || Stdlib.Cli.PowerShell.fileExists portableDbPath then
                  match migratePortableData host portableDbPath with
                  | Ok _ -> Stdlib.Result.Result.Ok("Binary copied and data migrated. The global 'dark' command should now be available.")
                  | Error e -> Stdlib.Result.Result.Error($"Binary copied but data migration failed: {e}")
                else
                  Stdlib.Result.Result.Ok("Binary copied with fresh database (no portable data found). The global 'dark' command should now be available.")
              else
                Stdlib.Result.Result.Ok("Binary copied with fresh database. The global 'dark' command should now be available.")
            | Error e -> Stdlib.Result.Result.Error($"Binary copied but setup failed: {e}")
          | Error e -> Stdlib.Result.Result.Error e


      /// Install CLI with option to migrate existing portable data
      let install (host: Stdlib.Cli.Host.Host) : Stdlib.Result.Result<String, String> =
        let currentDir = Builtin.directoryCurrent ()
        let portableDbPath = $"{currentDir}/.darklang/data.db"

        Builtin.printLine "Found existing portable installation with data."
        Builtin.printLine "Installation options:"
        Builtin.printLine "1. Fresh install (start with clean database)"
        Builtin.printLine "2. Migrate current data to global installation"
        Builtin.printLine "Choose option (1 or 2, default: 1): "
        let choice = (Builtin.stdinReadLine ()) |> Stdlib.String.trim

        match Install.installOrUpdateLatestRelease host with
        | Ok _ ->
          if choice == "2" then
            // Copy the database after successful installation
            match migratePortableData host portableDbPath with
            | Ok _ -> Stdlib.Result.Result.Ok("Global installation complete with data migration. Restart your terminal to use 'dark' command.")
            | Error e -> Stdlib.Result.Result.Error($"Installation complete but data migration failed: {e}. You can probably continue if you copy the .db manually, restart your terminal, and run the 'dark' command")
          else
            Stdlib.Result.Result.Ok("Global installation complete with fresh database. Restart your terminal to use 'dark' command.")
        | Error e -> Stdlib.Result.Result.Error e


      /// Update the CLI if a newer version is available
      let updateIfAvailable (currentVersion: String) (host: Stdlib.Cli.Host.Host) : Stdlib.Result.Result<String, String> =
        match GitHub.Releases.getLatestReleaseTag () with
        | Ok latestVersion ->
          // Handle local-binary specially
          if currentVersion == "local-binary" then
            Builtin.printLine "You're currently running a locally-installed binary (from development)."
            Builtin.printLine $"Latest official release is {latestVersion}."
            Builtin.printLine "Update to the official release? (y/n): "
            let choice = (Builtin.stdinReadLine ()) |> Stdlib.String.trim
            
            if choice == "y" || choice == "Y" then
              match Install.installOrUpdateLatestRelease host with
              | Ok _ -> Stdlib.Result.Result.Ok($"Successfully updated to official release {latestVersion}")
              | Error e -> Stdlib.Result.Result.Error e
            else
              Stdlib.Result.Result.Ok("Update cancelled - keeping local binary")
          else if currentVersion == latestVersion then
            Stdlib.Result.Result.Ok("Already up to date!")
          else
            match Install.installOrUpdateLatestRelease host with
            | Ok _ -> Stdlib.Result.Result.Ok($"Successfully updated to {latestVersion}")
            | Error e -> Stdlib.Result.Result.Error e
        | Error _ ->
          // Unable to check for updates, proceed with installation
          match Install.installOrUpdateLatestRelease host with
          | Ok _ -> Stdlib.Result.Result.Ok("Update complete")
          | Error e -> Stdlib.Result.Result.Error e


      /// Uninstall the CLI with user confirmation
      let uninstallWithConfirmation (host: Stdlib.Cli.Host.Host) : Stdlib.Result.Result<String, String> =
        Builtin.printLine "Are you sure you want to uninstall darklang cli? (y/n): "
        let response = Builtin.stdinReadLine ()

        if response == "y" || response == "Y" then
          Builtin.printLine "Uninstalling..."
          match Uninstall.runUninstall host with
          | Ok _ -> Stdlib.Result.Result.Ok("Uninstall complete")
          | Error e -> Stdlib.Result.Result.Error e
        else
          Stdlib.Result.Result.Ok("Uninstall cancelled")

