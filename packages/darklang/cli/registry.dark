module Darklang =
  module Cli =
    module Registry =
      type CommandHandler =
        { name: String
          description: String
          aliases: List<String>
          execute: Types.AppState -> List<String> -> Types.AppState
          help: Types.AppState -> Types.AppState
          complete: Types.AppState -> List<String> -> List<String> }

      let allCommands () : List<CommandHandler> =
        [ CommandHandler { name = "quit"; description = "Exit the CLI"; aliases = ["exit"]; execute = Quit.execute; help = Quit.help; complete = Quit.complete }
          CommandHandler { name = "help"; description = "Show help for commands"; aliases = ["h"; "?"]; execute = Help.execute; help = Help.help; complete = Help.complete }
          CommandHandler { name = "install"; description = "Install CLI globally"; aliases = []; execute = Installation.Commands.executeInstall; help = Installation.Commands.installHelp; complete = Installation.Commands.installComplete }
          CommandHandler { name = "update"; description = "Update CLI to latest version"; aliases = ["upgrade"]; execute = Installation.Commands.executeUpdate; help = Installation.Commands.updateHelp; complete = Installation.Commands.updateComplete }
          CommandHandler { name = "uninstall"; description = "Remove CLI installation"; aliases = []; execute = Installation.Commands.executeUninstall; help = Installation.Commands.uninstallHelp; complete = Installation.Commands.uninstallComplete }
          CommandHandler { name = "status"; description = "Show installation status"; aliases = []; execute = Installation.Commands.executeStatus; help = Installation.Commands.statusHelp; complete = Installation.Commands.statusComplete }
          CommandHandler { name = "version"; description = "Display CLI version"; aliases = ["v"]; execute = Installation.Commands.executeVersion; help = Installation.Commands.versionHelp; complete = Installation.Commands.versionComplete }
          CommandHandler { name = "cd"; description = "Navigate to package or module"; aliases = []; execute = Packages.Navigation.executeCD; help = Packages.Navigation.cdHelp; complete = Packages.Navigation.cdComplete }
          CommandHandler { name = "ls"; description = "List package contents"; aliases = ["dir"]; execute = Packages.Listing.executeLS; help = Packages.Listing.lsHelp; complete = Packages.Listing.lsComplete }
          CommandHandler { name = "pwd"; description = "Show current package path"; aliases = []; execute = Packages.Navigation.executePWD; help = Packages.Navigation.pwdHelp; complete = Packages.Navigation.pwdComplete }
          CommandHandler { name = "back"; description = "Go back to previous location"; aliases = ["b"]; execute = Packages.Navigation.executeBACK; help = Packages.Navigation.backHelp; complete = Packages.Navigation.backComplete }
          CommandHandler { name = "clear"; description = "Clear the screen"; aliases = ["cls"]; execute = Cli.Commands.executeClear; help = Cli.Commands.clearHelp; complete = Cli.Commands.clearComplete }
          CommandHandler { name = "run"; description = "Run a function or script"; aliases = []; execute = Cli.Execution.executeRun; help = Cli.Execution.runHelp; complete = Cli.Execution.runComplete }
          CommandHandler { name = "eval"; description = "Evaluate a Dark expression"; aliases = ["e"]; execute = Cli.Execution.executeEval; help = Cli.Execution.evalHelp; complete = Cli.Execution.evalComplete }
          CommandHandler { name = "scripts"; description = "Store, manage, and run Dark scripts"; aliases = []; execute = Cli.Scripts.executeScripts; help = Cli.Scripts.scriptsHelp; complete = Cli.Scripts.scriptsComplete }
          CommandHandler { name = "view"; description = "View details of functions, types, constants, or modules"; aliases = []; execute = Packages.Viewing.executeView; help = Packages.Viewing.viewHelp; complete = Packages.Viewing.viewComplete } ]

      let findCommand (name: String) : CommandHandler =
        let commands = allCommands ()
        let nameMatches = Stdlib.List.filter commands (fun cmd -> cmd.name == name)
        let aliasMatches = Stdlib.List.filter commands (fun cmd -> 
          match Stdlib.List.findFirst cmd.aliases (fun alias -> alias == name) with
          | Some _ -> true
          | None -> false)
        let allMatches = Stdlib.List.append nameMatches aliasMatches
        match allMatches with
        | [handler] -> handler
        | handler :: _ -> handler
        | [] -> 
          CommandHandler 
            { name = name
              description = "Unknown command"
              aliases = []
              execute = fun state args -> 
                Builtin.printLine (View.formatError $"Unknown command: {name}")
                Builtin.printLine "Use 'help' to see available commands."
                Types.AppState { isExiting = state.isExiting; lastCommand = name; output = $"unknown command: {name}"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
              help = fun state ->
                Builtin.printLine $"No help available for command: {name}"
                Types.AppState { isExiting = state.isExiting; lastCommand = $"help {name}"; output = $"no help for {name}"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
              complete = fun state args -> [] }

      let executeCommand (name: String) (state: Types.AppState) (args: List<String>) : Types.AppState =
        let handler = findCommand name
        let ex = handler.execute
        ex state args

      let executeCommandHelp (name: String) (state: Types.AppState) : Types.AppState =
        let handler = findCommand name
        let help = handler.help
        help state

      let getCommandList () : String =
        let commands = allCommands ()
        
        // Group commands by category
        let packageCommands = ["cd"; "ls"; "pwd"; "back"]
        let executionCommands = ["run"; "eval"; "scripts"]
        let installCommands = ["install"; "update"; "uninstall"; "status"; "version"]
        let utilityCommands = ["clear"; "help"; "quit"]
        
        // Format package navigation group
        let packageGroup =
          let packageCmds = 
            packageCommands
            |> Stdlib.List.filterMap (fun name ->
              match Stdlib.List.findFirst commands (fun cmd -> cmd.name == name) with
              | Some cmd ->
                match cmd.aliases with
                | [] -> Stdlib.Option.Option.Some $"  {cmd.name} - {cmd.description}"
                | aliases ->
                  let aliasText = Stdlib.String.join aliases ", "
                  Stdlib.Option.Option.Some $"  {cmd.name} ({aliasText}) - {cmd.description}"
              | None -> Stdlib.Option.Option.None)
          let packageLines = Stdlib.String.join packageCmds "\n"
          $"Package navigation:\n{packageLines}"
        
        // Format execution group
        let executionGroup =
          let executionCmds = 
            executionCommands
            |> Stdlib.List.filterMap (fun name ->
              match Stdlib.List.findFirst commands (fun cmd -> cmd.name == name) with
              | Some cmd ->
                match cmd.aliases with
                | [] -> Stdlib.Option.Option.Some $"  {cmd.name} - {cmd.description}"
                | aliases ->
                  let aliasText = Stdlib.String.join aliases ", "
                  Stdlib.Option.Option.Some $"  {cmd.name} ({aliasText}) - {cmd.description}"
              | None -> Stdlib.Option.Option.None)
          let executionLines = Stdlib.String.join executionCmds "\n"
          $"Code execution:\n{executionLines}"
        
        // Format installation group
        let installGroup =
          let installCmds = 
            installCommands
            |> Stdlib.List.filterMap (fun name ->
              match Stdlib.List.findFirst commands (fun cmd -> cmd.name == name) with
              | Some cmd ->
                match cmd.aliases with
                | [] -> Stdlib.Option.Option.Some $"  {cmd.name} - {cmd.description}"
                | aliases ->
                  let aliasText = Stdlib.String.join aliases ", "
                  Stdlib.Option.Option.Some $"  {cmd.name} ({aliasText}) - {cmd.description}"
              | None -> Stdlib.Option.Option.None)
          let installLines = Stdlib.String.join installCmds "\n"
          $"Installation:\n{installLines}"
        
        // Format utilities group
        let utilityGroup =
          let utilityCmds = 
            utilityCommands
            |> Stdlib.List.filterMap (fun name ->
              match Stdlib.List.findFirst commands (fun cmd -> cmd.name == name) with
              | Some cmd ->
                match cmd.aliases with
                | [] -> Stdlib.Option.Option.Some $"  {cmd.name} - {cmd.description}"
                | aliases ->
                  let aliasText = Stdlib.String.join aliases ", "
                  Stdlib.Option.Option.Some $"  {cmd.name} ({aliasText}) - {cmd.description}"
              | None -> Stdlib.Option.Option.None)
          let utilityLines = Stdlib.String.join utilityCmds "\n"
          $"Utilities:\n{utilityLines}"
        
        let groupsText = Stdlib.String.join [packageGroup; executionGroup; installGroup; utilityGroup] "\n\n"
        $"Available commands:\n\n{groupsText}"

      let getCompletions (state: Types.AppState) (input: String) : List<String> =
        let parsed = Completion.parseInput input
        
        if parsed.isCompletingCommand then
          // Completing command name
          let partial = Completion.getPartialCompletion parsed
          let commands = allCommands ()
          let allNames = Stdlib.List.map commands (fun cmd -> cmd.name)
          let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
          let allOptions = Stdlib.List.append allNames allAliases
          if Stdlib.String.isEmpty partial then
            allOptions
          else
            Stdlib.List.filter allOptions (fun name -> Stdlib.String.startsWith name partial)
        else
          // Completing command arguments
          let handler = findCommand parsed.commandName
          let completeFunc = handler.complete
          completeFunc state parsed.args

      let getCompletionHint (state: Types.AppState) (input: String) : String =
        let parsed = Completion.parseInput input
        let completions = getCompletions state input
        let partial = Completion.getPartialCompletion parsed
        Completion.getHintFromCompletions partial completions

      let findCommonPrefix (strings: List<String>) : String =
        match strings with
        | [] -> ""
        | [single] -> single
        | first :: rest ->
          Stdlib.List.fold rest first (fun acc next ->
            let maxLen = Stdlib.Int64.min (Stdlib.String.length acc) (Stdlib.String.length next)
            let commonLen = findCommonLength acc next 0L maxLen
            Stdlib.String.slice acc 0L commonLen)

      let findCommonLength (str1: String) (str2: String) (index: Int64) (maxLen: Int64) : Int64 =
        if index >= maxLen then
          index
        else
          let char1 = Stdlib.String.slice str1 index (index + 1L)
          let char2 = Stdlib.String.slice str2 index (index + 1L)
          if char1 == char2 then
            findCommonLength str1 str2 (index + 1L) maxLen
          else
            index