module Darklang =
  module Cli =
    module Registry =
      type CommandHandler =
        { name: String
          description: String
          aliases: List<String>
          execute: Types.AppState -> List<String> -> Types.AppState
          help: Types.AppState -> Types.AppState
          complete: Types.AppState -> List<String> -> List<String> }

      let allCommands () : List<CommandHandler> =
        [ CommandHandler { name = "quit"; description = "Exit the CLI"; aliases = ["exit"]; execute = Quit.execute; help = Quit.help; complete = Help.complete }
          CommandHandler { name = "help"; description = "Show help for commands"; aliases = ["h"; "?"]; execute = Help.execute; help = Help.help; complete = Help.complete }
          CommandHandler { name = "install"; description = "Install CLI globally"; aliases = []; execute = Install.executeInstall; help = Install.installHelp; complete = Install.installComplete }
          CommandHandler { name = "update"; description = "Update CLI to latest version"; aliases = ["upgrade"]; execute = Install.executeUpdate; help = Install.updateHelp; complete = Install.updateComplete }
          CommandHandler { name = "uninstall"; description = "Remove CLI installation"; aliases = []; execute = Install.executeUninstall; help = Install.uninstallHelp; complete = Install.uninstallComplete }
          CommandHandler { name = "status"; description = "Show installation status"; aliases = []; execute = Install.executeStatus; help = Install.statusHelp; complete = Install.statusComplete }
          CommandHandler { name = "version"; description = "Display CLI version"; aliases = ["v"]; execute = Install.executeVersion; help = Install.versionHelp; complete = Install.versionComplete } ]

      let findCommand (name: String) : CommandHandler =
        let commands = allCommands ()
        let nameMatches = Stdlib.List.filter commands (fun cmd -> cmd.name == name)
        let aliasMatches = Stdlib.List.filter commands (fun cmd -> 
          match Stdlib.List.findFirst cmd.aliases (fun alias -> alias == name) with
          | Some _ -> true
          | None -> false)
        let allMatches = Stdlib.List.append nameMatches aliasMatches
        match allMatches with
        | [handler] -> handler
        | handler :: _ -> handler
        | [] -> 
          CommandHandler 
            { name = name
              description = "Unknown command"
              aliases = []
              execute = fun state args -> 
                Builtin.printLine (View.formatError $"Unknown command: {name}")
                Builtin.printLine "Use 'help' to see available commands."
                Types.AppState { isExiting = state.isExiting; lastCommand = name; output = $"unknown command: {name}"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw }
              help = fun state ->
                Builtin.printLine $"No help available for command: {name}"
                Types.AppState { isExiting = state.isExiting; lastCommand = $"help {name}"; output = $"no help for {name}"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw }
              complete = fun state args -> [] }

      let executeCommand (name: String) (state: Types.AppState) (args: List<String>) : Types.AppState =
        let handler = findCommand name
        let ex = handler.execute
        ex state args

      let executeCommandHelp (name: String) (state: Types.AppState) : Types.AppState =
        let handler = findCommand name
        let help = handler.help
        help state

      let getCommandList () : String =
        let commands = allCommands ()
        let lines = Stdlib.List.map commands (fun cmd ->
          match cmd.aliases with
          | [] -> $"  {cmd.name} - {cmd.description}"
          | aliases ->
            let aliasText = Stdlib.String.join aliases ", "
            $"  {cmd.name} ({aliasText}) - {cmd.description}")
        let joined = Stdlib.String.join lines "\n"
        $"Available commands:\n{joined}"

      let getCompletions (state: Types.AppState) (input: String) : List<String> =
        let parsed = Completion.parseInput input
        
        if parsed.isCompletingCommand then
          // Completing command name
          let partial = Completion.getPartialCompletion parsed
          let commands = allCommands ()
          let allNames = Stdlib.List.map commands (fun cmd -> cmd.name)
          let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
          let allOptions = Stdlib.List.append allNames allAliases
          if Stdlib.String.isEmpty partial then
            allOptions
          else
            Stdlib.List.filter allOptions (fun name -> Stdlib.String.startsWith name partial)
        else
          // Completing command arguments
          let handler = findCommand parsed.commandName
          let completeFunc = handler.complete
          completeFunc state parsed.args

      let getCompletionHint (state: Types.AppState) (input: String) : String =
        let parsed = Completion.parseInput input
        let completions = getCompletions state input
        let partial = Completion.getPartialCompletion parsed
        Completion.getHintFromCompletions partial completions

      let findCommonPrefix (strings: List<String>) : String =
        match strings with
        | [] -> ""
        | [single] -> single
        | first :: rest ->
          Stdlib.List.fold rest first (fun acc next ->
            let maxLen = Stdlib.Int64.min (Stdlib.String.length acc) (Stdlib.String.length next)
            let commonLen = findCommonLength acc next 0L maxLen
            Stdlib.String.slice acc 0L commonLen)

      let findCommonLength (str1: String) (str2: String) (index: Int64) (maxLen: Int64) : Int64 =
        if index >= maxLen then
          index
        else
          let char1 = Stdlib.String.slice str1 index (index + 1L)
          let char2 = Stdlib.String.slice str2 index (index + 1L)
          if char1 == char2 then
            findCommonLength str1 str2 (index + 1L) maxLen
          else
            index