module Darklang =
  module Cli =
    module Install =
      /// Get current CLI version for display
      let cliVersion () : String =
        "v0.1.0-dev"

      /// Install command handler
      let executeInstall (state: Types.AppState) (args: List<String>) : Types.AppState =
        let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap
        let currentMode = Installation.System.getInstallationMode ()
        
        match currentMode with
        | Installed ->
          Builtin.printLine (View.formatSuccess "Already installed globally")
          Types.AppState { isExiting = state.isExiting; lastCommand = "install"; output = "already installed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
        | Portable ->
          let currentDir = Builtin.directoryCurrent ()
          
          if Installation.System.globalInstallationExists host then
            let homeDir =
              match host.os with
              | Windows ->
                match Stdlib.Cli.PowerShell.getHomeDirectory () with
                | Ok dir -> $"{dir}\\.darklang"
                | Error _ -> "~\\.darklang"
              | _ ->
                match Stdlib.Cli.Unix.getHomeDirectory () with
                | Ok dir -> $"{dir}/.darklang"
                | Error _ -> "~/.darklang"

            let message = $"Detected portable mode - you're running from {currentDir}/.darklang\nFound existing global installation at {homeDir}\n\nIf you'd like to update your global installation, please run `darklang` rather than this portable executable."
            Builtin.printLine (View.formatSuccess message)
            Types.AppState { isExiting = state.isExiting; lastCommand = "install"; output = "existing global found"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
          else
            Builtin.printLine "Choose installation method:"
            Builtin.printLine "1. Copy this binary (for testing local changes)"
            Builtin.printLine "2. Download latest release from GitHub"
            Builtin.printLine "Choose option (1 or 2): "
            let choice = (Builtin.stdinReadLine ()) |> Stdlib.String.trim

            if choice == "1" then
              match Installation.System.installFromCurrentBinary host with
              | Ok message ->
                Builtin.printLine (View.formatSuccess message)
                Types.AppState { isExiting = state.isExiting; lastCommand = "install"; output = "binary install success"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
              | Error e ->
                Builtin.printLine (View.formatError e)
                Types.AppState { isExiting = state.isExiting; lastCommand = "install"; output = "binary install failed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
            else
              Builtin.printLine "Installing globally..."
              match Installation.System.install host with
              | Ok message ->
                Builtin.printLine (View.formatSuccess message)
                Types.AppState { isExiting = state.isExiting; lastCommand = "install"; output = "global install success"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
              | Error e ->
                Builtin.printLine (View.formatError e)
                Types.AppState { isExiting = state.isExiting; lastCommand = "install"; output = "global install failed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      /// Install help handler
      let installHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: install"
        Builtin.printLine "Install Darklang CLI globally for system-wide access."
        Builtin.printLine ""
        Builtin.printLine "This command installs the CLI to ~/.darklang/bin/ and sets up"
        Builtin.printLine "shell configuration for global access."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help install"; output = "install help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      /// Update command handler
      let executeUpdate (state: Types.AppState) (args: List<String>) : Types.AppState =
        let currentVersion = cliVersion ()
        let currentMode = Installation.System.getInstallationMode ()
        let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap
        
        match currentMode with
        | Installed ->
          Builtin.printLine $"Checking for updates from Darklang CLI {currentVersion}..."
          match Installation.System.updateIfAvailable currentVersion host with
          | Ok message ->
            Builtin.printLine (View.formatSuccess message)
            Types.AppState { isExiting = state.isExiting; lastCommand = "update"; output = "update success"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
          | Error e ->
            Builtin.printLine (View.formatError e)
            Types.AppState { isExiting = state.isExiting; lastCommand = "update"; output = "update failed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
        | Portable ->
          let message = $"Running in portable mode from {Builtin.directoryCurrent ()}/.darklang\n\nTo update this portable executable, please download the latest release manually from:\nhttps://github.com/darklang/dark/releases\n\nFor automatic updates, consider running 'install' to set up global installation."
          Builtin.printLine (View.formatSuccess message)
          Types.AppState { isExiting = state.isExiting; lastCommand = "update"; output = "portable update info"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      /// Update help handler  
      let updateHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: update"
        Builtin.printLine "Update Darklang CLI to the latest version."
        Builtin.printLine ""
        Builtin.printLine "Checks GitHub for the latest release and updates the globally"
        Builtin.printLine "installed CLI. Only works for global installations."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help update"; output = "update help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      /// Uninstall command handler
      let executeUninstall (state: Types.AppState) (args: List<String>) : Types.AppState =
        let currentMode = Installation.System.getInstallationMode ()
        let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap
        
        match currentMode with
        | Installed ->
          match Installation.System.uninstallWithConfirmation host with
          | Ok message ->
            Builtin.printLine (View.formatSuccess message)
            // Exit after successful uninstall since the executable is being removed
            Types.AppState { isExiting = true; lastCommand = "uninstall"; output = "uninstall success"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
          | Error e ->
            Builtin.printLine (View.formatError e)
            Types.AppState { isExiting = state.isExiting; lastCommand = "uninstall"; output = "uninstall failed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
        | Portable ->
          Builtin.printLine (View.formatError "Cannot uninstall - running in portable mode")
          Builtin.printLine "To remove this portable installation, simply delete the current directory"
          Types.AppState { isExiting = state.isExiting; lastCommand = "uninstall"; output = "portable uninstall error"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      /// Uninstall help handler
      let uninstallHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: uninstall"
        Builtin.printLine "Uninstall Darklang CLI from global installation."
        Builtin.printLine ""
        Builtin.printLine "Removes the CLI from ~/.darklang/ and cleans up shell configuration."
        Builtin.printLine "Only available for global installations."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help uninstall"; output = "uninstall help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      /// Status command handler
      let executeStatus (state: Types.AppState) (args: List<String>) : Types.AppState =
        let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap
        let currentMode = Installation.System.getInstallationMode ()
        
        let statusMessage =
          match currentMode with
          | Installed ->
            let homeDir =
              match host.os with
              | Windows ->
                match Stdlib.Cli.PowerShell.getHomeDirectory () with
                | Ok dir -> $"{dir}\\.darklang"
                | Error _ -> "~\\.darklang"
              | _ ->
                match Stdlib.Cli.Unix.getHomeDirectory () with
                | Ok dir -> $"{dir}/.darklang"
                | Error _ -> "~/.darklang"
            $"Status: Globally installed at {homeDir} and ready to use"
          | Portable ->
            let currentDir = Builtin.directoryCurrent ()
            $"Status: Running in portable mode at {currentDir}/.darklang (run 'install' for global system-wide access)"

        Builtin.printLine (View.formatSuccess statusMessage)
        Types.AppState { isExiting = state.isExiting; lastCommand = "status"; output = "status displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      /// Status help handler
      let statusHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: status"
        Builtin.printLine "Show current CLI installation status."
        Builtin.printLine ""
        Builtin.printLine "Displays whether CLI is running in portable or global mode"
        Builtin.printLine "and shows installation location."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help status"; output = "status help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      /// Enhanced version command with installation info
      let executeVersion (state: Types.AppState) (args: List<String>) : Types.AppState =
        let currentMode = Installation.System.getInstallationMode ()
        let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap
        
        let modeInfo =
          match currentMode with
          | Installed ->
            let homeDir =
              match host.os with
              | Windows ->
                match Stdlib.Cli.PowerShell.getHomeDirectory () with
                | Ok dir -> $"{dir}\\.darklang"
                | Error _ -> "~\\.darklang"
              | _ ->
                match Stdlib.Cli.Unix.getHomeDirectory () with
                | Ok dir -> $"{dir}/.darklang"
                | Error _ -> "~/.darklang"
            $"Installed at: {homeDir}"
          | Portable ->
            let currentDir = Builtin.directoryCurrent ()
            $"Running portable from: {currentDir}/.darklang"

        Builtin.printLine (View.formatVersion ())
        Builtin.printLine modeInfo
        Types.AppState { isExiting = state.isExiting; lastCommand = "version"; output = "version with install info displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      /// Enhanced version help handler
      let versionHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: version"
        Builtin.printLine "Display CLI version and installation information."
        Builtin.printLine ""
        Builtin.printLine "Shows current version, installation mode, and location."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help version"; output = "version help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      /// Completion functions for installation commands
      let installComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

      let updateComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

      let uninstallComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

      let statusComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

      let versionComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args