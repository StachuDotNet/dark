/// System integration utilities for CLI installation
module Darklang.Cli.Installation.System


/// CLI installation mode
type InstallationMode =
  /// Runs from any location
  /// Creates files as needed in an adjacent .darklang directory
  | Portable

  /// Globally installed with system integration, per user account
  | Installed


/// Convert installation mode to string for display
let installationModeToString (mode: InstallationMode) : String =
  match mode with
  | Portable -> "portable"
  | Installed -> "installed"


/// Detect current CLI installation mode based on executable location
let getInstallationMode () : InstallationMode =
  let executablePath = Builtin.getCurrentExecutablePath ()
  let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap
  let darklangHomeDir = Config.getDarklangHomeDir host

  let globalBinPath =
    match host.os with
    | Windows -> $"{darklangHomeDir}\\bin\\"
    | _ -> $"{darklangHomeDir}/bin/"

  // Check if executable is running from global installation directory
  if Stdlib.String.contains executablePath globalBinPath then
    InstallationMode.Installed
  else
    InstallationMode.Portable


/// Check if the latest version of the Darklang CLI is installed,
/// by comparing:
/// - the latest release on GitHub,
/// (against)
/// - the locally-installed version, as recorded in the `config.json` file
let isAtLatestVersion
  (configPath: String)
  : Stdlib.Result.Result<Bool, String> =
  match Darklang.GitHub.Releases.getLatestReleaseTag () with
  | Ok latestVersion ->
    match Config.readLocallyInstalledDarklangVersion configPath with
    | Ok localVersion -> Stdlib.Result.Result.Ok(localVersion == latestVersion)
    | Error _e -> Stdlib.Result.Result.Error "Couldn't determine local version"
  | Error _e ->
    Stdlib.Result.Result.Error
      "Couldn't determine latest version -- whatever you're about to try probably won't work"


/// Migrate portable database to global installation
let migratePortableData (host: Stdlib.Cli.Host.Host) (portableDbPath: String) : Stdlib.Result.Result<Unit, String> =
  let darklangHomeDir = Config.getDarklangHomeDir host

  let globalDbPath = $"{darklangHomeDir}/data.db"
  match host.os with
  | Windows -> Stdlib.Cli.PowerShell.copyFile portableDbPath globalDbPath
  | _ -> Stdlib.Cli.Unix.copyFile portableDbPath globalDbPath


/// Check if a global installation exists
let globalInstallationExists (host: Stdlib.Cli.Host.Host) : Bool =
  let darklangHomeDir = Config.getDarklangHomeDir host

  let globalBinPath =
    match host.os with
    | Windows -> $"{darklangHomeDir}\\bin\\dark.exe"
    | _ -> $"{darklangHomeDir}/bin/dark"

  match host.os with
  | Windows -> Stdlib.Cli.PowerShell.fileExists globalBinPath
  | _ -> Stdlib.Cli.Unix.fileExists globalBinPath


/// Install CLI by copying the current binary (for development/testing)
let installFromCurrentBinary (host: Stdlib.Cli.Host.Host) : Stdlib.Result.Result<String, String> =
  let currentBinaryPath = Builtin.getCurrentExecutablePath ()
  let currentDir = Builtin.directoryCurrent ()
  let portableDbPath = $"{currentDir}/.darklang/data.db"

  let darklangHomeDir = Config.getDarklangHomeDir host

  let globalBinDir =
    match host.os with
    | Windows -> $"{darklangHomeDir}\\bin\\"
    | _ -> $"{darklangHomeDir}/bin/"

  let globalBinaryPath =
    match host.os with
    | Windows -> $"{globalBinDir}dark.exe"
    | _ -> $"{globalBinDir}dark"

  let configPath = $"{darklangHomeDir}/config.json"

  // Create directories and copy binary
  let createDirsAndCopy =
    match host.os with
    | Windows ->
      match Stdlib.Cli.PowerShell.ensureDirectoryExists globalBinDir with
      | Ok _ -> Stdlib.Cli.PowerShell.copyFile currentBinaryPath globalBinaryPath
      | Error e -> Stdlib.Result.Result.Error e
    | _ ->
      match Stdlib.Cli.Unix.ensureDirectoryExists globalBinDir with
      | Ok _ ->
        match Stdlib.Cli.Unix.copyFile currentBinaryPath globalBinaryPath with
        | Ok _ -> Stdlib.Cli.Unix.grantExecutePermission globalBinaryPath
        | Error e -> Stdlib.Result.Result.Error e
      | Error e -> Stdlib.Result.Result.Error e

  match createDirsAndCopy with
  | Ok _ ->
    // Create config.json and set up shell integration
    let setupResult =
      match host.os with
      | Windows ->
        match Stdlib.Cli.PowerShell.createFile configPath with
        | Ok _ ->
          match Config.updateVersion configPath "local-binary" with
          | Ok _ -> Stdlib.Result.Result.Ok()
          | Error e -> Stdlib.Result.Result.Error e
        | Error e -> Stdlib.Result.Result.Error e
      | _ ->
        match Config.updateVersion configPath "local-binary" with
        | Ok _ ->
          match Stdlib.Cli.Unix.deleteAlias host.defaultShell "dark" with
          | Ok _ ->
            match Stdlib.Cli.Unix.addAlias host.defaultShell "dark" globalBinaryPath with
            | Ok _ -> Stdlib.Result.Result.Ok()
            | Error e -> Stdlib.Result.Result.Error e
          | Error _ ->
            // Ignore error if alias doesn't exist, try to add it anyway
            match Stdlib.Cli.Unix.addAlias host.defaultShell "dark" globalBinaryPath with
            | Ok _ -> Stdlib.Result.Result.Ok()
            | Error e -> Stdlib.Result.Result.Error e
        | Error e -> Stdlib.Result.Result.Error e

    match setupResult with
    | Ok _ ->
      // Ask about data migration
      Stdlib.printLine "Would you like to copy the data from this portable directory to the installation, or start fresh? (copy/fresh, default: fresh): "
      let migrateChoice = (Builtin.stdinReadLine ()) |> Stdlib.String.trim

      if migrateChoice == "copy" then
        if Stdlib.Cli.Unix.fileExists portableDbPath || Stdlib.Cli.PowerShell.fileExists portableDbPath then
          match migratePortableData host portableDbPath with
          | Ok _ -> Stdlib.Result.Result.Ok("Binary copied and data migrated. The global 'dark' command should now be available.")
          | Error e -> Stdlib.Result.Result.Error($"Binary copied but data migration failed: {e}")
        else
          Stdlib.Result.Result.Ok("Binary copied with fresh database (no portable data found). The global 'dark' command should now be available.")
      else
        Stdlib.Result.Result.Ok("Binary copied with fresh database. The global 'dark' command should now be available.")
    | Error e -> Stdlib.Result.Result.Error($"Binary copied but setup failed: {e}")
  | Error e -> Stdlib.Result.Result.Error e


/// Install CLI with option to migrate existing portable data
let install (host: Stdlib.Cli.Host.Host) : Stdlib.Result.Result<String, String> =
  let currentDir = Builtin.directoryCurrent ()
  let portableDbPath = $"{currentDir}/.darklang/data.db"

  Stdlib.printLine "Found existing portable installation with data."
  Stdlib.printLine "Installation options:"
  Stdlib.printLine "1. Fresh install (start with clean database)"
  Stdlib.printLine "2. Migrate current data to global installation"
  Stdlib.printLine "Choose option (1 or 2, default: 1): "
  let choice = (Builtin.stdinReadLine ()) |> Stdlib.String.trim

  match Download.installOrUpdateLatestRelease host with
  | Ok _ ->
    if choice == "2" then
      // Copy the database after successful installation
      match migratePortableData host portableDbPath with
      | Ok _ -> Stdlib.Result.Result.Ok("Global installation complete with data migration. Restart your terminal to use 'dark' command.")
      | Error e -> Stdlib.Result.Result.Error($"Installation complete but data migration failed: {e}. You can probably continue if you copy the .db manually, restart your terminal, and run the 'dark' command")
    else
      Stdlib.Result.Result.Ok("Global installation complete with fresh database. Restart your terminal to use 'dark' command.")
  | Error e -> Stdlib.Result.Result.Error e


/// Update the CLI if a newer version is available
let updateIfAvailable (currentVersion: String) (host: Stdlib.Cli.Host.Host) : Stdlib.Result.Result<String, String> =
  match Darklang.GitHub.Releases.getLatestReleaseTag () with
  | Ok latestVersion ->
    // Handle local-binary specially
    if currentVersion == "local-binary" then
      Stdlib.printLine "You're currently running a locally-installed binary (from development)."
      Stdlib.printLine $"Latest official release is {latestVersion}."
      Stdlib.printLine "Update to the official release? (y/n): "
      let choice = (Builtin.stdinReadLine ()) |> Stdlib.String.trim

      if choice == "y" || choice == "Y" then
        match Download.installOrUpdateLatestRelease host with
        | Ok _ -> Stdlib.Result.Result.Ok($"Successfully updated to official release {latestVersion}")
        | Error e -> Stdlib.Result.Result.Error e
      else
        Stdlib.Result.Result.Ok("Update cancelled - keeping local binary")
    else if currentVersion == latestVersion then
      Stdlib.Result.Result.Ok("Already up to date!")
    else
      match Download.installOrUpdateLatestRelease host with
      | Ok _ -> Stdlib.Result.Result.Ok($"Successfully updated to {latestVersion}")
      | Error e -> Stdlib.Result.Result.Error e
  | Error _ ->
    // Unable to check for updates, proceed with installation
    match Download.installOrUpdateLatestRelease host with
    | Ok _ -> Stdlib.Result.Result.Ok("Update complete")
    | Error e -> Stdlib.Result.Result.Error e


/// Uninstall the CLI with user confirmation
let uninstallWithConfirmation (host: Stdlib.Cli.Host.Host) : Stdlib.Result.Result<String, String> =
  Stdlib.printLine "Are you sure you want to uninstall dark cli? (y/n): "
  let response = Builtin.stdinReadLine ()

  if response == "y" || response == "Y" then
    Stdlib.printLine "Uninstalling..."
    match Uninstall.runUninstall host with
    | Ok _ -> Stdlib.Result.Result.Ok("Uninstall complete")
    | Error e -> Stdlib.Result.Result.Error e
  else
    Stdlib.Result.Result.Ok("Uninstall cancelled")