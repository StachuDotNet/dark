module Darklang =
  module Cli =
    module Installation =
      module Commands =
        // Helpers
        let cliVersion () : String =
          let hash = Builtin.getBuildHash ()
          "alpha-" ++ hash

        let getVersionInfo () : String =
          let currentVersion = cliVersion ()
          match GitHub.Releases.getLatestReleaseBuildHash () with
          | Ok latestVersion ->
            if currentVersion == latestVersion then
              "Darklang CLI " ++ currentVersion ++ " (up to date)"
            else
              "Darklang CLI " ++ currentVersion ++ " (latest: " ++ latestVersion ++ " - update available!)"
          | Error _ ->
            "Darklang CLI " ++ currentVersion ++ " (unable to check for updates)"


        // Install
        let executeInstall (state: AppState) (args: List<String>) : AppState =
          let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap
          let currentMode = Installation.System.getInstallationMode ()

          match currentMode with
          | Installed ->
            Builtin.printLine (View.formatSuccess "Already installed globally")
            { state with lastCommand = "install"; output = "already installed" }
          | Portable ->
            let currentDir = Builtin.directoryCurrent ()

            if Installation.System.globalInstallationExists host then
              let homeDir = Config.getDarklangHomeDir host

              let message = $"Detected portable mode - you're running from {currentDir}/.darklang\nFound existing global installation at {homeDir}\n\nIf you'd like to update your global installation, please run `darklang` rather than this portable executable."
              Builtin.printLine (View.formatSuccess message)
              { state with lastCommand = "install"; output = "existing global found" }
            else
              Builtin.printLine "Choose installation method:"
              Builtin.printLine "1. Copy this binary (for testing local changes)"
              Builtin.printLine "2. Download latest release from GitHub"
              Builtin.printLine "Choose option (1 or 2): "
              let choice = (Builtin.stdinReadLine ()) |> Stdlib.String.trim

              if choice == "1" then
                match Installation.System.installFromCurrentBinary host with
                | Ok message ->
                  Builtin.printLine (View.formatSuccess message)
                  { state with lastCommand = "install"; output = "binary install success" }
                | Error e ->
                  Builtin.printLine (View.formatError e)
                  { state with lastCommand = "install"; output = "binary install failed" }
              else
                Builtin.printLine "Installing globally..."
                match Installation.System.install host with
                | Ok message ->
                  Builtin.printLine (View.formatSuccess message)
                  { state with lastCommand = "install"; output = "global install success" }
                | Error e ->
                  Builtin.printLine (View.formatError e)
                  { state with lastCommand = "install"; output = "global install failed" }

        let installHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: install"
          Builtin.printLine "Install Darklang CLI globally for system-wide access."
          Builtin.printLine ""
          Builtin.printLine "This command installs the CLI to ~/.darklang/bin/ and sets up"
          Builtin.printLine "shell configuration for global access."
          { state with lastCommand = "help install"; output = "install help displayed" }


        /// Update
        let executeUpdate (state: AppState) (args: List<String>) : AppState =
          let currentVersion = cliVersion ()
          let currentMode = Installation.System.getInstallationMode ()
          let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap

          match currentMode with
          | Installed ->
            Builtin.printLine $"Checking for updates from Darklang CLI {currentVersion}..."
            match Installation.System.updateIfAvailable currentVersion host with
            | Ok message ->
              Builtin.printLine (View.formatSuccess message)
              { state with lastCommand = "update"; output = "update success" }
            | Error e ->
              Builtin.printLine (View.formatError e)
              { state with lastCommand = "update"; output = "update failed" }
          | Portable ->
            let message = $"Running in portable mode from {Builtin.directoryCurrent ()}/.darklang\n\nTo update this portable executable, please download the latest release manually from:\nhttps://github.com/darklang/dark/releases\n\nFor automatic updates, consider running 'install' to set up global installation."
            Builtin.printLine (View.formatSuccess message)
            { state with lastCommand = "update"; output = "portable update info" }


        let updateHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: update"
          Builtin.printLine "Update Darklang CLI to the latest version."
          Builtin.printLine ""
          Builtin.printLine "Checks GitHub for the latest release and updates the globally"
          Builtin.printLine "installed CLI. Only works for global installations."
          { state with lastCommand = "help update"; output = "update help displayed" }

        // Uninstall
        let executeUninstall (state: AppState) (args: List<String>) : AppState =
          let currentMode = Installation.System.getInstallationMode ()
          let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap

          match currentMode with
          | Installed ->
            match Installation.System.uninstallWithConfirmation host with
            | Ok message ->
              Builtin.printLine (View.formatSuccess message)
              // Exit after successful uninstall since the executable is being removed
              { state with isExiting = true; lastCommand = "uninstall"; output = "uninstall success" }
            | Error e ->
              Builtin.printLine (View.formatError e)
              { state with lastCommand = "uninstall"; output = "uninstall failed" }
          | Portable ->
            Builtin.printLine (View.formatError "Cannot uninstall - running in portable mode")
            Builtin.printLine "To remove this portable installation, simply delete the current directory"
            { state with lastCommand = "uninstall"; output = "portable uninstall error" }

        let uninstallHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: uninstall"
          Builtin.printLine "Uninstall Darklang CLI from global installation."
          Builtin.printLine ""
          Builtin.printLine "Removes the CLI from ~/.darklang/ and cleans up shell configuration."
          Builtin.printLine "Only available for global installations."
          { state with lastCommand = "help uninstall"; output = "uninstall help displayed" }


        // Status
        let executeStatus (state: AppState) (args: List<String>) : AppState =
          let host = (Stdlib.Cli.Host.getRuntimeHost ()) |> Builtin.unwrap
          let currentMode = Installation.System.getInstallationMode ()

          let version = getVersionInfo ()

          let currentLocation = Packages.Path.formatPath state.currentPath
          let locationDisplay = if Stdlib.String.isEmpty currentLocation then "/" else currentLocation

          let installationStatus =
            match currentMode with
            | Installed ->
              let homeDir = Config.getDarklangHomeDir host
              Colors.success "Status: " ++ "Globally installed at " ++ homeDir ++ " and ready to use"
            | Portable ->
              let currentDir = Builtin.directoryCurrent ()
              Colors.warning "Status: " ++ "Running in portable mode at " ++ currentDir ++ "/.darklang (run 'install' for global system-wide access)"

          let statusText =
            Colors.info "Version: " ++ version ++ "\n" ++
            Colors.info "Location: " ++ locationDisplay ++ "\n" ++
            installationStatus ++ "\n\n" ++
            "Type " ++ Colors.hint "'help'" ++ " for available commands"

          Builtin.printLine statusText
          { state with lastCommand = "status"; output = "detailed status displayed" }

        let statusHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: status"
          Builtin.printLine "Show current CLI installation status."
          Builtin.printLine ""
          Builtin.printLine "Displays whether CLI is running in portable or global mode"
          Builtin.printLine "and shows installation location."
          { state with lastCommand = "help status"; output = "status help displayed" }


        // Version
        let executeVersion (state: AppState) (args: List<String>) : AppState =
          let versionInfo = getVersionInfo ()
          Builtin.printLine versionInfo
          { state with lastCommand = "version"; output = "version info displayed" }

        let versionHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: version"
          Builtin.printLine "Display CLI version and installation information."
          Builtin.printLine ""
          Builtin.printLine "Shows current version, installation mode, and location."
          { state with lastCommand = "help version"; output = "version help displayed" }


        /// Completion functions for installation commands
        let installComplete (state: AppState) (args: List<String>) : List<String> =
          Completion.noArgsCompletion state args

        let updateComplete (state: AppState) (args: List<String>) : List<String> =
          Completion.noArgsCompletion state args

        let uninstallComplete (state: AppState) (args: List<String>) : List<String> =
          Completion.noArgsCompletion state args

        let statusComplete (state: AppState) (args: List<String>) : List<String> =
          Completion.noArgsCompletion state args

        let versionComplete (state: AppState) (args: List<String>) : List<String> =
          Completion.noArgsCompletion state args