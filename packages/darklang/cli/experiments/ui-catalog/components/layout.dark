module Darklang =
  module Cli =
    module Experiments =
      module UICatalog =
        module Components =
          module Layout =
            // ==========================================
            // Layout Components - Containers, Panels, Grids
            // ==========================================

            // Container Component
            type ContainerModel<'TChild> =
              { children: List<'TChild>
                padding: Int64
                border: Bool
                title: String }

            let createContainer (children: List<'TChild>) (title: String) (border: Bool) : Core.Types.Component<ContainerModel<'TChild>> =
              let model = ContainerModel { children = children; padding = 1L; border = border; title = title }
              // Calculate container size based on children (simplified)
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = 40L; height = 20L } }
              Core.Types.Component
                { id = "container-" ++ title
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = false }

            let renderContainer (component: Core.Types.Component<ContainerModel<'TChild>>) (context: Core.Types.RenderContext) (renderChild: 'TChild -> Core.Types.RenderContext -> List<String>) : List<String> =
              let model = component.model

              if model.border then
                let contentLines =
                  model.children
                  |> Stdlib.List.map (fun child -> renderChild child context)
                  |> Stdlib.List.flatten

                Core.Rendering.drawBox component.bounds model.title contentLines
              else
                model.children
                |> Stdlib.List.map (fun child -> renderChild child context)
                |> Stdlib.List.flatten

            // Panel Component
            type PanelModel =
              { content: List<String>
                title: String
                color: Core.Types.Color
                collapsible: Bool
                collapsed: Bool }

            let createPanel (title: String) (content: List<String>) (color: Core.Types.Color) : Core.Types.Component<PanelModel> =
              let model = PanelModel { content = content; title = title; color = color; collapsible = false; collapsed = false }
              let contentHeight = if model.collapsed then 1L else Stdlib.List.length content + 2L
              let maxWidth =
                (Stdlib.List.push content title)
                |> Stdlib.List.map Stdlib.String.length
                |> Stdlib.List.fold 20L (fun acc len -> if len > acc then len else acc)
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = maxWidth + 4L; height = contentHeight } }
              Core.Types.Component
                { id = "panel-" ++ title
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = true }

            let renderPanel (component: Core.Types.Component<PanelModel>) (context: Core.Types.RenderContext) : List<String> =
              let model = component.model
              let hasFocus = context.hasFocus && component.state == Core.Types.ComponentState.Focused

              let titleColor = if hasFocus then Core.Types.Color.Primary else model.color
              let coloredTitle = Core.Rendering.colorize titleColor model.title
              let collapseIndicator = if model.collapsible then (if model.collapsed then " ▼" else " ▲") else ""
              let fullTitle = coloredTitle ++ collapseIndicator

              if model.collapsed then
                let focusIndicator = if hasFocus then "► " else "  "
                [ focusIndicator ++ "┌─ " ++ fullTitle ++ " ─┐" ]
              else
                Core.Rendering.drawBox component.bounds fullTitle model.content

            let togglePanel (component: Core.Types.Component<PanelModel>) : Core.Types.Component<PanelModel> =
              let model = component.model
              if model.collapsible then
                { component with model = { model with collapsed = Stdlib.Bool.not model.collapsed } }
              else
                component

            // Grid Layout Component
            type GridModel<'TItem> =
              { items: List<'TItem>
                columns: Int64
                spacing: Int64
                itemWidth: Int64
                itemHeight: Int64 }

            let createGrid (items: List<'TItem>) (columns: Int64) (itemWidth: Int64) (itemHeight: Int64) : Core.Types.Component<GridModel<'TItem>> =
              let model = GridModel { items = items; columns = columns; spacing = 1L; itemWidth = itemWidth; itemHeight = itemHeight }
              let rows = Stdlib.Int64.divide (Stdlib.List.length items + columns - 1L) columns
              let totalWidth = columns * itemWidth + (columns - 1L) * model.spacing
              let totalHeight = rows * itemHeight + (rows - 1L) * model.spacing
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = totalWidth; height = totalHeight } }
              Core.Types.Component
                { id = "grid"
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = true }

            let renderGrid (component: Core.Types.Component<GridModel<'TItem>>) (context: Core.Types.RenderContext) (renderItem: 'TItem -> Int64 -> Core.Types.RenderContext -> List<String>) : List<String> =
              let model = component.model
              // Simplified grid rendering - just render items in a vertical list for now
              model.items
              |> Stdlib.List.indexedMap (fun index item ->
                  let renderedItem = renderItem item index context
                  renderedItem)
              |> Stdlib.List.flatten

            // Horizontal Stack Component
            type HStackModel<'TItem> =
              { items: List<'TItem>
                spacing: Int64
                alignment: Core.Types.Alignment }

            let createHStack (items: List<'TItem>) (spacing: Int64) (alignment: Core.Types.Alignment) : Core.Types.Component<HStackModel<'TItem>> =
              let model = HStackModel { items = items; spacing = spacing; alignment = alignment }
              // Calculate size based on items (simplified)
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = 60L; height = 5L } }
              Core.Types.Component
                { id = "hstack"
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = false }

            let renderHStack (component: Core.Types.Component<HStackModel<'TItem>>) (context: Core.Types.RenderContext) (renderItem: 'TItem -> Core.Types.RenderContext -> List<String>) : List<String> =
              let model = component.model
              let itemRenderings = model.items |> Stdlib.List.map (fun item -> renderItem item context)

              // Find max height among all items
              let maxHeight =
                itemRenderings
                |> Stdlib.List.map Stdlib.List.length
                |> Stdlib.List.fold 1L (fun acc len -> if len > acc then len else acc)

              // Combine items horizontally line by line
              (Stdlib.List.range 0L (maxHeight - 1L))
              |> Stdlib.List.map (fun lineIndex ->
                  itemRenderings
                  |> Stdlib.List.map (fun itemLines ->
                      match Stdlib.List.getAt itemLines lineIndex with
                      | Some line -> line
                      | None -> "")
                  |> Stdlib.String.join (Stdlib.String.repeat " " model.spacing))

            // Vertical Stack Component
            type VStackModel<'TItem> =
              { items: List<'TItem>
                spacing: Int64 }

            let createVStack (items: List<'TItem>) (spacing: Int64) : Core.Types.Component<VStackModel<'TItem>> =
              let model = VStackModel { items = items; spacing = spacing }
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = 40L; height = 20L } }
              Core.Types.Component
                { id = "vstack"
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = false }

            let renderVStack (component: Core.Types.Component<VStackModel<'TItem>>) (context: Core.Types.RenderContext) (renderItem: 'TItem -> Core.Types.RenderContext -> List<String>) : List<String> =
              let model = component.model
              let spacingLines = (Stdlib.List.range 0L (model.spacing - 1L)) |> Stdlib.List.map (fun _ -> "")

              model.items
              |> Stdlib.List.map (fun item -> renderItem item context)
              |> Stdlib.List.interpose spacingLines
              |> Stdlib.List.flatten