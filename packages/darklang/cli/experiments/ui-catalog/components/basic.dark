module Darklang =
  module CLI =
    module Experiments =
      module UICatalog =
        module Components =
          module Basic =
            // ==========================================
            // Basic UI Components - Buttons, Labels, Text
            // ==========================================

            // Button Component
            type ButtonModel = 
              { text: String
                color: Core.Types.Color
                size: Core.Types.Size
                disabled: Bool
                action: (Unit -> Unit) }

            let createButton (text: String) (color: Core.Types.Color) (action: Unit -> Unit) : Core.Types.Component<ButtonModel> =
              let model = ButtonModel { text = text; color = color; size = Core.Types.Size.Normal; disabled = false; action = action }
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = 12L; height = 3L } }
              Core.Types.Component 
                { id = "button-" ++ text
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = true }

            let renderButton (component: Core.Types.Component<ButtonModel>) (context: Core.Types.RenderContext) : List<String> =
              let model = component.model
              let hasFocus = context.hasFocus && component.state == Core.Types.ComponentState.Focused
              
              let buttonText = 
                if model.disabled then
                  Core.Rendering.dim model.text
                else if hasFocus then
                  Core.Rendering.bold model.text
                else
                  model.text
              
              let coloredText = 
                if model.disabled then
                  buttonText
                else
                  Core.Rendering.colorize model.color buttonText
              
              let paddedText = Core.Rendering.padText coloredText component.bounds.dimensions.width Core.Types.Alignment.Center
              let focusIndicator = if hasFocus then "► " else "  "
              
              [ focusIndicator ++ "┌" ++ Stdlib.String.repeat "─" (component.bounds.dimensions.width - 2L) ++ "┐"
                focusIndicator ++ "│" ++ paddedText ++ "│"
                focusIndicator ++ "└" ++ Stdlib.String.repeat "─" (component.bounds.dimensions.width - 2L) ++ "┘" ]

            // Label Component
            type LabelModel =
              { text: String
                color: Core.Types.Color
                size: Core.Types.Size
                bold: Bool }

            let createLabel (text: String) (color: Core.Types.Color) : Core.Types.Component<LabelModel> =
              let model = LabelModel { text = text; color = color; size = Core.Types.Size.Normal; bold = false }
              let textLength = Stdlib.String.length text
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = textLength; height = 1L } }
              Core.Types.Component
                { id = "label-" ++ text
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = false }

            let renderLabel (component: Core.Types.Component<LabelModel>) (context: Core.Types.RenderContext) : List<String> =
              let model = component.model
              let styledText = 
                if model.bold then
                  Core.Rendering.bold model.text
                else
                  model.text
              
              let coloredText = Core.Rendering.colorize model.color styledText
              [ coloredText ]

            // Text Block Component
            type TextBlockModel =
              { lines: List<String>
                color: Core.Types.Color
                alignment: Core.Types.Alignment
                wordWrap: Bool }

            let createTextBlock (lines: List<String>) (color: Core.Types.Color) (alignment: Core.Types.Alignment) : Core.Types.Component<TextBlockModel> =
              let model = TextBlockModel { lines = lines; color = color; alignment = alignment; wordWrap = false }
              let maxWidth = 
                lines
                |> Stdlib.List.map Stdlib.String.length
                |> Stdlib.List.fold 0L (fun acc len -> if len > acc then len else acc)
              let height = Stdlib.List.length lines
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = maxWidth; height = height } }
              Core.Types.Component
                { id = "textblock"
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = false }

            let renderTextBlock (component: Core.Types.Component<TextBlockModel>) (context: Core.Types.RenderContext) : List<String> =
              let model = component.model
              model.lines
              |> Stdlib.List.map (fun line ->
                  let paddedLine = Core.Rendering.padText line component.bounds.dimensions.width model.alignment
                  Core.Rendering.colorize model.color paddedLine)

            // Divider Component
            type DividerModel =
              { character: String
                color: Core.Types.Color
                length: Int64 }

            let createDivider (character: String) (length: Int64) (color: Core.Types.Color) : Core.Types.Component<DividerModel> =
              let model = DividerModel { character = character; color = color; length = length }
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = length; height = 1L } }
              Core.Types.Component
                { id = "divider"
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = false }

            let renderDivider (component: Core.Types.Component<DividerModel>) (context: Core.Types.RenderContext) : List<String> =
              let model = component.model
              let line = Stdlib.String.repeat model.character model.length
              let coloredLine = Core.Rendering.colorize model.color line
              [ coloredLine ]

            // Progress Bar Component
            type ProgressModel =
              { value: Int64
                min: Int64
                max: Int64
                color: Core.Types.Color
                showPercentage: Bool }

            let createProgressBar (value: Int64) (min: Int64) (max: Int64) (color: Core.Types.Color) : Core.Types.Component<ProgressModel> =
              let model = ProgressModel { value = value; min = min; max = max; color = color; showPercentage = true }
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = 20L; height = 1L } }
              Core.Types.Component
                { id = "progress"
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = false }

            let renderProgressBar (component: Core.Types.Component<ProgressModel>) (context: Core.Types.RenderContext) : List<String> =
              let model = component.model
              let range = model.max - model.min
              let progress = model.value - model.min
              let availableWidth = component.bounds.dimensions.width - 2L
              let filledWidth = if range == 0L then 0L else Stdlib.Int64.divide (progress * availableWidth) range
              let filled = Stdlib.String.repeat "█" filledWidth
              let empty = Stdlib.String.repeat "░" (component.bounds.dimensions.width - 2L - filledWidth)
              
              let progressText = "[" ++ filled ++ empty ++ "]"
              let coloredProgress = Core.Rendering.colorize model.color progressText
              
              if model.showPercentage then
                let percentValue = if range == 0L then 0L else Stdlib.Int64.divide (progress * 100L) range
                let percentText = " " ++ Stdlib.Int64.toString percentValue ++ "%"
                [ coloredProgress ++ percentText ]
              else
                [ coloredProgress ]