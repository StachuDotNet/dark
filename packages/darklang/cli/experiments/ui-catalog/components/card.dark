module Darklang =
  module CLI =
    module Experiments =
      module UICatalog =
        module Components =
          module Card =
            // ==========================================
            // Card Components - Flexible content containers
            // ==========================================

            // Border characters type
            type BorderChars =
              { top: String
                bottom: String
                left: String
                right: String
                topRight: String
                bottomRight: String
                horizontal: String }

            // Card Component
            type CardModel =
              { title: String
                subtitle: String
                content: List<String>
                footer: List<String>
                headerColor: Core.Types.Color
                borderColor: Core.Types.Color
                width: Int64
                height: Int64
                hasShadow: Bool
                isRounded: Bool }

            let createCard (title: String) (content: List<String>) (width: Int64) (height: Int64) : Core.Types.Component<CardModel> =
              let model = CardModel { title = title; subtitle = ""; content = content; footer = []; headerColor = Core.Types.Color.Default; borderColor = Core.Types.Color.Default; width = width; height = height; hasShadow = false; isRounded = false }
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = width; height = height } }
              Core.Types.Component
                { id = "card-" ++ title
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = false }

            let renderCard (component: Core.Types.Component<CardModel>) (context: Core.Types.RenderContext) : List<String> =
              let model = component.model
              let hasFocus = context.hasFocus && component.state == Core.Types.ComponentState.Focused
              
              let top = if model.isRounded then "╭" else "┌"
              let bottom = if model.isRounded then "╰" else "└"
              let left = "│"
              let right = "│"
              let topRight = if model.isRounded then "╮" else "┐"
              let bottomRight = if model.isRounded then "╯" else "┘"
              let horizontal = "─"
              
              // Create header section
              let headerLines = 
                if Stdlib.String.isEmpty model.title && Stdlib.String.isEmpty model.subtitle then
                  []
                else
                  let titleLine = 
                    if Stdlib.String.isEmpty model.title then
                      ""
                    else
                      let styledTitle = Core.Rendering.colorize model.headerColor (Core.Rendering.bold model.title)
                      let paddedTitle = Core.Rendering.padText styledTitle (model.width - 4L) Core.Types.Alignment.Left
                      left ++ " " ++ paddedTitle ++ " " ++ right
                  
                  let subtitleLine = 
                    if Stdlib.String.isEmpty model.subtitle then
                      ""
                    else
                      let paddedSubtitle = Core.Rendering.padText model.subtitle (model.width - 4L) Core.Types.Alignment.Left
                      left ++ " " ++ paddedSubtitle ++ " " ++ right
                  
                  let headerSeparator = left ++ (Stdlib.String.repeat horizontal (model.width - 2L)) ++ right
                  
                  [titleLine; subtitleLine; headerSeparator]
                  |> Stdlib.List.filter (fun line -> Stdlib.Bool.not (Stdlib.String.isEmpty line))
              
              // Create content section
              let contentLines = 
                let maxContentHeight = model.height - 2L - Stdlib.List.length headerLines - Stdlib.List.length model.footer
                let paddedContent = 
                  model.content
                  |> Stdlib.List.take maxContentHeight
                  |> Stdlib.List.map (fun line ->
                      let truncatedLine = Core.Rendering.truncateText line (model.width - 4L)
                      let paddedLine = Core.Rendering.padText truncatedLine (model.width - 4L) Core.Types.Alignment.Left
                      left ++ " " ++ paddedLine ++ " " ++ right)
                
                let remainingHeight = maxContentHeight - Stdlib.List.length paddedContent
                let emptyLines = 
                  if remainingHeight > 0L then
                    Stdlib.List.repeat remainingHeight (left ++ (Stdlib.String.repeat " " (model.width - 2L)) ++ right)
                  else
                    []
                
                paddedContent
                |> Stdlib.List.append emptyLines
              
              // Create footer section
              let footerLines = 
                if Stdlib.List.isEmpty model.footer then
                  []
                else
                  let footerSeparator = left ++ (Stdlib.String.repeat horizontal (model.width - 2L)) ++ right
                  let footerContent = 
                    model.footer
                    |> Stdlib.List.map (fun line ->
                        let paddedLine = Core.Rendering.padText line (model.width - 4L) Core.Types.Alignment.Left
                        left ++ " " ++ paddedLine ++ " " ++ right)
                  
                  [footerSeparator]
                  |> Stdlib.List.append footerContent
              
              // Create borders
              let topBorder = 
                if Stdlib.List.isEmpty headerLines then
                  top ++ (Stdlib.String.repeat horizontal (model.width - 2L)) ++ topRight
                else
                  top ++ (Stdlib.String.repeat horizontal (model.width - 2L)) ++ topRight
              
              let bottomBorder = bottom ++ (Stdlib.String.repeat horizontal (model.width - 2L)) ++ bottomRight
              
              // Combine all sections
              let cardContent = 
                [topBorder]
                |> Stdlib.List.append headerLines
                |> Stdlib.List.append contentLines
                |> Stdlib.List.append footerLines
                |> Stdlib.List.append [bottomBorder]
              
              // Apply shadow effect if enabled
              if model.hasShadow then
                let shadowedContent = 
                  cardContent
                  |> Stdlib.List.indexedMap (fun i line ->
                      if i == Stdlib.List.length cardContent - 1L then
                        line ++ " " ++ (Core.Rendering.dim (Stdlib.String.repeat "▄" (model.width - 1L)))
                      else
                        line ++ Core.Rendering.dim "▌")
                
                let shadowBottom = " " ++ (Core.Rendering.dim (Stdlib.String.repeat "▀" model.width))
                shadowedContent
                |> Stdlib.List.append [shadowBottom]
              else
                cardContent

            let setCardTitle (component: Core.Types.Component<CardModel>) (title: String) : Core.Types.Component<CardModel> =
              let model = component.model
              { component with model = { model with title = title } }

            let setCardSubtitle (component: Core.Types.Component<CardModel>) (subtitle: String) : Core.Types.Component<CardModel> =
              let model = component.model
              { component with model = { model with subtitle = subtitle } }

            let setCardContent (component: Core.Types.Component<CardModel>) (content: List<String>) : Core.Types.Component<CardModel> =
              let model = component.model
              { component with model = { model with content = content } }

            let setCardFooter (component: Core.Types.Component<CardModel>) (footer: List<String>) : Core.Types.Component<CardModel> =
              let model = component.model
              { component with model = { model with footer = footer } }

            let setCardColors (component: Core.Types.Component<CardModel>) (headerColor: Core.Types.Color) (borderColor: Core.Types.Color) : Core.Types.Component<CardModel> =
              let model = component.model
              { component with model = { model with headerColor = headerColor; borderColor = borderColor } }

            let enableCardShadow (component: Core.Types.Component<CardModel>) : Core.Types.Component<CardModel> =
              let model = component.model
              { component with model = { model with hasShadow = true } }

            let enableCardRounding (component: Core.Types.Component<CardModel>) : Core.Types.Component<CardModel> =
              let model = component.model
              { component with model = { model with isRounded = true } }

            // Media Card Component (for cards with image/media content)
            type MediaCardModel =
              { title: String
                description: String
                mediaPlaceholder: String
                mediaWidth: Int64
                mediaHeight: Int64
                actions: List<String>
                width: Int64
                height: Int64 }

            let createMediaCard (title: String) (description: String) (mediaWidth: Int64) (mediaHeight: Int64) : Core.Types.Component<MediaCardModel> =
              let totalWidth = mediaWidth + 4L
              let totalHeight = mediaHeight + 6L
              let model = MediaCardModel { title = title; description = description; mediaPlaceholder = "📷"; mediaWidth = mediaWidth; mediaHeight = mediaHeight; actions = []; width = totalWidth; height = totalHeight }
              let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = totalWidth; height = totalHeight } }
              Core.Types.Component
                { id = "mediacard-" ++ title
                  model = model
                  state = Core.Types.ComponentState.Normal
                  bounds = bounds
                  visible = true
                  focusable = false }

            let renderMediaCard (component: Core.Types.Component<MediaCardModel>) (context: Core.Types.RenderContext) : List<String> =
              let model = component.model
              
              let topBorder = "┌" ++ (Stdlib.String.repeat "─" (model.width - 2L)) ++ "┐"
              let bottomBorder = "└" ++ (Stdlib.String.repeat "─" (model.width - 2L)) ++ "┘"
              
              // Create media placeholder
              let mediaLines = 
                let centerY = Stdlib.Int64.divide model.mediaHeight 2L
                (Stdlib.List.range 0L model.mediaHeight)
                |> Stdlib.List.map (fun i ->
                    if i == centerY then
                      let centeredPlaceholder = Core.Rendering.padText model.mediaPlaceholder model.mediaWidth Core.Types.Alignment.Center
                      let borderedLine = Core.Rendering.padText centeredPlaceholder (model.width - 4L) Core.Types.Alignment.Center
                      "│ " ++ borderedLine ++ " │"
                    else
                      let emptyLine = Stdlib.String.repeat " " (model.width - 4L)
                      "│ " ++ emptyLine ++ " │")
              
              // Create title and description
              let titleLine = 
                let styledTitle = Core.Rendering.bold model.title
                let paddedTitle = Core.Rendering.padText styledTitle (model.width - 4L) Core.Types.Alignment.Left
                "│ " ++ paddedTitle ++ " │"
              
              let descLine = 
                let paddedDesc = Core.Rendering.padText model.description (model.width - 4L) Core.Types.Alignment.Left
                "│ " ++ paddedDesc ++ " │"
              
              let separatorLine = "├" ++ (Stdlib.String.repeat "─" (model.width - 2L)) ++ "┤"
              
              // Create actions if any
              let actionLines = 
                if Stdlib.List.isEmpty model.actions then
                  []
                else
                  let actionText = Stdlib.String.join " | " model.actions
                  let paddedActions = Core.Rendering.padText actionText (model.width - 4L) Core.Types.Alignment.Center
                  ["│ " ++ paddedActions ++ " │"]
              
              [topBorder]
              |> Stdlib.List.append mediaLines
              |> Stdlib.List.append [separatorLine; titleLine; descLine]
              |> Stdlib.List.append actionLines
              |> Stdlib.List.append [bottomBorder]

            let setMediaCardActions (component: Core.Types.Component<MediaCardModel>) (actions: List<String>) : Core.Types.Component<MediaCardModel> =
              let model = component.model
              { component with model = { model with actions = actions } }