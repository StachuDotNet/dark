module Darklang.Cli.Experiments.UICatalog.Components.Navigation


// Menu Item Type
type MenuItem =
  { id: String
    label: String
    shortcut: String
    action: (Unit -> Unit)
    enabled: Bool
    submenu: List<MenuItem> }

// Menu Component
type MenuModel =
  { items: List<MenuItem>
    selectedIndex: Int64
    isOpen: Bool
    title: String }

let createMenu (title: String) (items: List<MenuItem>) : Core.Types.Component<MenuModel> =
  let model = MenuModel { items = items; selectedIndex = 0L; isOpen = false; title = title }
  let maxWidth =
    items
    |> Stdlib.List.map (fun item -> Stdlib.String.length item.label + Stdlib.String.length item.shortcut + 4L)
    |> Stdlib.List.fold 20L (fun acc len -> if len > acc then len else acc)
  let height = if model.isOpen then Stdlib.List.length items + 2L else 1L
  let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = maxWidth; height = height } }
  Core.Types.Component
    { id = "menu-" ++ title
      model = model
      state = Core.Types.ComponentState.Normal
      bounds = bounds
      visible = true
      focusable = true }

let renderMenu (component: Core.Types.Component<MenuModel>) (context: Core.Types.RenderContext) : List<String> =
  let model = component.model
  let hasFocus = context.hasFocus && component.state == Core.Types.ComponentState.Focused

  let titleColor = if hasFocus then Core.Types.Color.Primary else Core.Types.Color.Default
  let styledTitle = Core.Rendering.colorize titleColor model.title
  let focusIndicator = if hasFocus then "► " else "  "

  if model.isOpen then
    let menuItems =
      model.items
      |> Stdlib.List.indexedMap (fun i item ->
          let isSelected = i == model.selectedIndex
          let prefix = if isSelected then "►" else " "
          let itemColor =
            if Stdlib.Bool.not item.enabled then Core.Types.Color.Dark
            else if isSelected then Core.Types.Color.Primary
            else Core.Types.Color.Default

          let label = Core.Rendering.padText item.label (component.bounds.dimensions.width - 6L - Stdlib.String.length item.shortcut) Core.Types.Alignment.Left
          let shortcut = if Stdlib.String.isEmpty item.shortcut then "" else "[" ++ item.shortcut ++ "]"
          let styledItem = Core.Rendering.colorize itemColor (prefix ++ " " ++ label ++ " " ++ shortcut)
          "│" ++ styledItem ++ "│")

    let topBorder = "┌" ++ Stdlib.String.repeat "─" (component.bounds.dimensions.width - 2L) ++ "┐"
    let bottomBorder = "└" ++ Stdlib.String.repeat "─" (component.bounds.dimensions.width - 2L) ++ "┘"
    let titleLine = "│" ++ Core.Rendering.padText styledTitle (component.bounds.dimensions.width - 2L) Core.Types.Alignment.Center ++ "│"

    [ topBorder; titleLine ]
    |> Stdlib.List.append menuItems
    |> Stdlib.List.append [ bottomBorder ]
  else
    [focusIndicator ++ styledTitle ++ " ▼"]

let selectMenuItem (component: Core.Types.Component<MenuModel>) (index: Int64) : Core.Types.Component<MenuModel> =
  let model = component.model
  if index >= 0L && index < Stdlib.List.length model.items then
    { component with model = { model with selectedIndex = index } }
  else
    component

let toggleMenu (component: Core.Types.Component<MenuModel>) : Core.Types.Component<MenuModel> =
  let model = component.model
  { component with model = { model with isOpen = Stdlib.Bool.not model.isOpen } }

// Tab Component
type TabModel =
  { tabs: List<String>
    activeIndex: Int64
    tabWidth: Int64 }

let createTabs (tabs: List<String>) (activeIndex: Int64) : Core.Types.Component<TabModel> =
  let model = TabModel { tabs = tabs; activeIndex = activeIndex; tabWidth = 12L }
  let totalWidth = Stdlib.List.length tabs * model.tabWidth
  let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = totalWidth; height = 2L } }
  Core.Types.Component
    { id = "tabs"
      model = model
      state = Core.Types.ComponentState.Normal
      bounds = bounds
      visible = true
      focusable = true }

let renderTabs (component: Core.Types.Component<TabModel>) (context: Core.Types.RenderContext) : List<String> =
  let model = component.model
  let hasFocus = context.hasFocus && component.state == Core.Types.ComponentState.Focused

  let tabHeaders =
    model.tabs
    |> Stdlib.List.indexedMap (fun i tab ->
        let isActive = i == model.activeIndex
        let isFocused = hasFocus && isActive

        let tabColor =
          if isFocused then Core.Types.Color.Primary
          else if isActive then Core.Types.Color.Success
          else Core.Types.Color.Default

        let paddedTab = Core.Rendering.padText tab model.tabWidth Core.Types.Alignment.Center
        let styledTab = Core.Rendering.colorize tabColor paddedTab

        if isActive then
          "┌" ++ Stdlib.String.repeat "─" (model.tabWidth - 2L) ++ "┐"
        else
          " " ++ Stdlib.String.repeat " " (model.tabWidth - 2L) ++ " ")
    |> Stdlib.String.join ""

  let tabLabels =
    model.tabs
    |> Stdlib.List.indexedMap (fun i tab ->
        let isActive = i == model.activeIndex
        let isFocused = hasFocus && isActive

        let tabColor =
          if isFocused then Core.Types.Color.Primary
          else if isActive then Core.Types.Color.Success
          else Core.Types.Color.Default

        let paddedTab = Core.Rendering.padText tab (model.tabWidth - 2L) Core.Types.Alignment.Center
        let styledTab = Core.Rendering.colorize tabColor paddedTab

        if isActive then
          "│" ++ styledTab ++ "│"
        else
          " " ++ styledTab ++ " ")
    |> Stdlib.String.join ""

  [ tabHeaders; tabLabels ]

let selectTab (component: Core.Types.Component<TabModel>) (index: Int64) : Core.Types.Component<TabModel> =
  let model = component.model
  if index >= 0L && index < Stdlib.List.length model.tabs then
    { component with model = { model with activeIndex = index } }
  else
    component

// Breadcrumb Component
type BreadcrumbModel =
  { crumbs: List<String>
    separator: String
    maxWidth: Int64 }

let createBreadcrumb (crumbs: List<String>) (separator: String) : Core.Types.Component<BreadcrumbModel> =
  let model = BreadcrumbModel { crumbs = crumbs; separator = separator; maxWidth = 50L }
  let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = model.maxWidth; height = 1L } }
  Core.Types.Component
    { id = "breadcrumb"
      model = model
      state = Core.Types.ComponentState.Normal
      bounds = bounds
      visible = true
      focusable = false }

let renderBreadcrumb (component: Core.Types.Component<BreadcrumbModel>) (context: Core.Types.RenderContext) : List<String> =
  let model = component.model

  let breadcrumbText =
    model.crumbs
    |> Stdlib.List.indexedMap (fun i crumb ->
        if i == Stdlib.List.length model.crumbs - 1L then
          Core.Rendering.colorize Core.Types.Color.Primary crumb  // Last crumb is highlighted
        else
          crumb)
    |> Stdlib.String.join (" " ++ model.separator ++ " ")

  let truncatedText = Core.Rendering.truncateText breadcrumbText model.maxWidth
  [truncatedText]

// Navigation Bar Component
type NavBarModel =
  { items: List<MenuItem>
    selectedIndex: Int64
    title: String }

let createNavBar (title: String) (items: List<MenuItem>) : Core.Types.Component<NavBarModel> =
  let model = NavBarModel { items = items; selectedIndex = 0L; title = title }
  let totalWidth =
    (Stdlib.String.length title + 4L) +
    (items |> Stdlib.List.map (fun item -> Stdlib.String.length item.label + 4L) |> Stdlib.List.fold 0L (fun acc len -> acc + len))
  let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = totalWidth; height = 1L } }
  Core.Types.Component
    { id = "navbar-" ++ title
      model = model
      state = Core.Types.ComponentState.Normal
      bounds = bounds
      visible = true
      focusable = true }

let renderNavBar (component: Core.Types.Component<NavBarModel>) (context: Core.Types.RenderContext) : List<String> =
  let model = component.model
  let hasFocus = context.hasFocus && component.state == Core.Types.ComponentState.Focused

  let styledTitle = Core.Rendering.colorize Core.Types.Color.Primary (Core.Rendering.bold model.title)

  let navItems =
    model.items
    |> Stdlib.List.indexedMap (fun i item ->
        let isSelected = i == model.selectedIndex && hasFocus
        let itemColor =
          if Stdlib.Bool.not item.enabled then Core.Types.Color.Dark
          else if isSelected then Core.Types.Color.Primary
          else Core.Types.Color.Default

        let styledItem = Core.Rendering.colorize itemColor item.label
        if isSelected then
          "[" ++ styledItem ++ "]"
        else
          " " ++ styledItem ++ " ")
    |> Stdlib.String.join " | "

  [styledTitle ++ " | " ++ navItems]

let selectNavItem (component: Core.Types.Component<NavBarModel>) (index: Int64) : Core.Types.Component<NavBarModel> =
  let model = component.model
  if index >= 0L && index < Stdlib.List.length model.items then
    { component with model = { model with selectedIndex = index } }
  else
    component