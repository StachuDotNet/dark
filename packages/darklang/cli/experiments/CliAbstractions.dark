module Darklang =
  module Cli =
    module Experiments =
      module Abstractions =
      // ==========================================
      // Enhanced CLI Abstractions and Utilities
      // ==========================================

      // ---------- Screen Management ----------
      module Screen =
        let clear () : Unit =
          Builtin.print "\u001b[2J\u001b[H"

        let clearLine () : Unit =
          Builtin.print "\u001b[2K\r"

        let moveCursor (x: Int64) (y: Int64) : Unit =
          Builtin.print ("\u001b[" ++ Stdlib.Int64.toString y ++ ";" ++ Stdlib.Int64.toString x ++ "H")

        let saveCursor () : Unit =
          Builtin.print "\u001b[s"

        let restoreCursor () : Unit =
          Builtin.print "\u001b[u"

        let hideCursor () : Unit =
          Builtin.print "\u001b[?25l"

        let showCursor () : Unit =
          Builtin.print "\u001b[?25h"

        let getSize () : (Int64 * Int64) =
          // Default to 80x24 if unable to detect
          (80L, 24L)

      // ---------- Input Utilities ----------
      module Input =
        type InputResult = { text: String; cancelled: Bool }

        let readLineLoop (current: String) : InputResult =
          let key = Stdlib.Cli.Stdin.readKey ()
          match key.key with
          | Enter -> InputResult { text = current; cancelled = false }
          | Escape -> InputResult { text = ""; cancelled = true }
          | Backspace ->
              if Stdlib.String.length current > 0L then
                let newText = Stdlib.String.slice current 0L (Stdlib.String.length current - 1L)
                Builtin.print "\b \b"
                readLineLoop newText
              else
                readLineLoop current
          | _ ->
              if key.keyChar != "" then
                Builtin.print key.keyChar
                readLineLoop (current ++ key.keyChar)
              else
                readLineLoop current

        let readLine (prompt: String) : InputResult =
          Builtin.print prompt
          readLineLoop ""

        let readPasswordLoop (current: String) : InputResult =
          let key = Stdlib.Cli.Stdin.readKey ()
          match key.key with
          | Enter -> InputResult { text = current; cancelled = false }
          | Escape -> InputResult { text = ""; cancelled = true }
          | Backspace ->
              if Stdlib.String.length current > 0L then
                let newText = Stdlib.String.slice current 0L (Stdlib.String.length current - 1L)
                Builtin.print "\b \b"
                readPasswordLoop newText
              else
                readPasswordLoop current
          | _ ->
              if key.keyChar != "" then
                Builtin.print "*"
                readPasswordLoop (current ++ key.keyChar)
              else
                readPasswordLoop current

        let readPassword (prompt: String) : InputResult =
          Builtin.print prompt
          readPasswordLoop ""

        let confirm (message: String) : Bool =
          Builtin.print (message ++ " (y/N): ")
          let key = Stdlib.Cli.Stdin.readKey ()
          if key.keyChar == "y" || key.keyChar == "Y" then
            Builtin.printLine "y"
            true
          else
            Builtin.printLine "n"
            false

      // ---------- Progress Indicators ----------
      module Progress =
        type ProgressBar = { current: Int64; total: Int64; width: Int64; message: String }

        let create (total: Int64) (width: Int64) (message: String) : ProgressBar =
          ProgressBar { current = 0L; total = total; width = width; message = message }

        let update (bar: ProgressBar) (current: Int64) : ProgressBar =
          ProgressBar { bar with current = current }

        let render (bar: ProgressBar) : Unit =
          let percentage = if bar.total == 0L then 0L else Stdlib.Int64.divide (bar.current * 100L) bar.total
          let filled = if bar.total == 0L then 0L else Stdlib.Int64.divide (bar.current * bar.width) bar.total
          let empty = bar.width - filled
          
          let progressStr = "[" ++ Stdlib.String.repeat "█" filled ++ Stdlib.String.repeat "░" empty ++ "]"
          let statusStr = " " ++ Stdlib.Int64.toString bar.current ++ "/" ++ Stdlib.Int64.toString bar.total ++ " (" ++ Stdlib.Int64.toString percentage ++ "%)"
          
          Screen.clearLine ()
          Builtin.print (bar.message ++ " " ++ progressStr ++ statusStr)

        let finish (bar: ProgressBar) : Unit =
          render (update bar bar.total)
          Builtin.printLine ""

      // ---------- Loading Spinner ----------
      module Spinner =
        type Spinner = { frames: List<String>; current: Int64; message: String }

        let create (message: String) : Spinner =
          Spinner { frames = ["⠋"; "⠙"; "⠹"; "⠸"; "⠼"; "⠴"; "⠦"; "⠧"; "⠇"; "⠏"]; current = 0L; message = message }

        let next (spinner: Spinner) : Spinner =
          let newCurrent = (spinner.current + 1L) % Stdlib.List.length spinner.frames
          Spinner { spinner with current = newCurrent }

        let render (spinner: Spinner) : Unit =
          match Stdlib.List.getAt spinner.frames spinner.current with
          | Some frame ->
              Screen.clearLine ()
              Builtin.print (frame ++ " " ++ spinner.message)
          | None -> ()

        let stop (spinner: Spinner) (finalMessage: String) : Unit =
          Screen.clearLine ()
          Builtin.printLine ("✓ " ++ finalMessage)

      // ---------- Menu System ----------
      module Menu =
        type MenuItem = { label: String; value: String; enabled: Bool }
        type MenuResult = { selectedValue: String; cancelled: Bool }

        let menuLoop (title: String) (items: List<MenuItem>) (selectedIndex: Int64) : MenuResult =
          Screen.clear ()
          Builtin.printLine (Darklang.Cli.Colors.boldText title)
          Builtin.printLine ""

          items
          |> Stdlib.List.indexedMap (fun i item ->
            let marker = if i == selectedIndex then "▶ " else "  "
            let text = if item.enabled then item.label else Darklang.Cli.Colors.dimText item.label
            let display = if i == selectedIndex then Darklang.Cli.Colors.boldText (Darklang.Cli.Colors.info text) else text
            Builtin.printLine (marker ++ display))

          Builtin.printLine ""
          Builtin.printLine (Darklang.Cli.Colors.hint "Use ↑/↓ to navigate, Enter to select, Esc to cancel")

          let key = Stdlib.Cli.Stdin.readKey ()
          match key.key with
          | UpArrow ->
              let newIndex = if selectedIndex > 0L then selectedIndex - 1L else Stdlib.List.length items - 1L
              menuLoop title items newIndex
          | DownArrow ->
              let newIndex = if selectedIndex < Stdlib.List.length items - 1L then selectedIndex + 1L else 0L
              menuLoop title items newIndex
          | Enter ->
              match Stdlib.List.getAt items selectedIndex with
              | Some item when item.enabled -> MenuResult { selectedValue = item.value; cancelled = false }
              | _ -> menuLoop title items selectedIndex
          | Escape ->
              MenuResult { selectedValue = ""; cancelled = true }
          | _ -> menuLoop title items selectedIndex

        let show (title: String) (items: List<MenuItem>) : MenuResult =
          menuLoop title items 0L

      // ---------- Table Display ----------
      module Table =
        type TableColumn = { header: String; width: Int64; align: String }
        type TableData = List<List<String>>

        let display (columns: List<TableColumn>) (data: TableData) : Unit =
          // Print header
          let headerLine =
            columns
            |> Stdlib.List.map (fun col ->
              let padding = col.width - Stdlib.String.length col.header
              col.header ++ Stdlib.String.repeat " " padding)
            |> Stdlib.String.join " │ "
          
          Builtin.printLine ("│ " ++ headerLine ++ " │")
          
          // Print separator
          let separator =
            columns
            |> Stdlib.List.map (fun col -> Stdlib.String.repeat "─" col.width)
            |> Stdlib.String.join "─┼─"
          
          Builtin.printLine ("├─" ++ separator ++ "─┤")
          
          // Print data rows
          data
          |> Stdlib.List.iter (fun row ->
            let rowLine =
              row
              |> Stdlib.List.indexedMap (fun i cell ->
                match Stdlib.List.getAt columns i with
                | Some col ->
                    let truncated = 
                      if Stdlib.String.length cell > col.width then
                        Stdlib.String.slice cell 0L (col.width - 3L) ++ "..."
                      else
                        cell
                    let padding = col.width - Stdlib.String.length truncated
                    truncated ++ Stdlib.String.repeat " " padding
                | None -> cell)
              |> Stdlib.String.join " │ "
            
            Builtin.printLine ("│ " ++ rowLine ++ " │"))

      // ---------- Form Builder ----------
      module Form =
        type FieldType = | Text | Password | Number | Email | Choice of List<String>
        type FormField = { name: String; label: String; fieldType: FieldType; required: Bool; value: String }
        type FormResult = { values: List<(String * String)>; cancelled: Bool }

        let createField (name: String) (label: String) (fieldType: FieldType) (required: Bool) : FormField =
          FormField { name = name; label = label; fieldType = fieldType; required = required; value = "" }

        let show (title: String) (fields: List<FormField>) : FormResult =
          Screen.clear ()
          Builtin.printLine (Darklang.Cli.Colors.boldText title)
          Builtin.printLine ""

          let (results, cancelled) = 
            fields
            |> Stdlib.List.fold ([], false) (fun (acc, wasCancelled) field ->
              if wasCancelled then
                (acc, true)
              else
                let prompt = field.label ++ (if field.required then " *" else "") ++ ": "
                let result =
                  match field.fieldType with
                  | Text -> Input.readLine prompt
                  | Password -> Input.readPassword prompt
                  | Number -> Input.readLine prompt
                  | Email -> Input.readLine prompt
                  | Choice options ->
                      let menuItems = options |> Stdlib.List.map (fun opt -> Menu.MenuItem { label = opt; value = opt; enabled = true })
                      let menuResult = Menu.show ("Select " ++ field.label) menuItems
                      Input.InputResult { text = menuResult.selectedValue; cancelled = menuResult.cancelled }
                
                if result.cancelled then
                  (acc, true)
                else
                  (acc ++ [(field.name, result.text)], false))

          FormResult { values = results; cancelled = cancelled }

      // ---------- Notification System ----------
      module Notifications =
        type NotificationType = | Info | Success | Warning | Error
        type Notification = { message: String; notificationType: NotificationType; timestamp: String }

        let show (notification: Notification) : Unit =
          let icon = 
            match notification.notificationType with
            | Info -> "ℹ"
            | Success -> "✓"
            | Warning -> "⚠"
            | Error -> "✗"
          
          let color = 
            match notification.notificationType with
            | Info -> Darklang.Cli.Colors.info
            | Success -> Darklang.Cli.Colors.success
            | Warning -> Darklang.Cli.Colors.warning
            | Error -> Darklang.Cli.Colors.error

          Builtin.printLine (color (icon ++ " " ++ notification.message))

        let showToast (message: String) (notificationType: NotificationType) (durationMs: Int64) : Unit =
          let notification = Notification { message = message; notificationType = notificationType; timestamp = "now" }
          show notification
          // In a real implementation, this would use a timer to hide the toast
          // For demo purposes, we'll just show it immediately

      // ---------- Command Line Argument Parser ----------
      module Args =
        type ArgValue = | StringValue of String | IntValue of Int64 | BoolValue of Bool
        type ParsedArgs = List<(String * ArgValue)>

        let parseArgsLoop (remaining: List<String>) (result: ParsedArgs) : ParsedArgs =
          match remaining with
          | [] -> result
          | flag :: value :: rest when Stdlib.String.startsWith flag "--" ->
              let key = Stdlib.String.dropFirst flag 2L
              let parsedValue = 
                if value == "true" then BoolValue true
                else if value == "false" then BoolValue false
                else
                  match Stdlib.Int64.parse value with
                  | Ok intVal -> IntValue intVal
                  | Error _ -> StringValue value
              parseArgsLoop rest (result ++ [(key, parsedValue)])
          | flag :: rest when Stdlib.String.startsWith flag "--" ->
              let key = Stdlib.String.dropFirst flag 2L
              parseArgsLoop rest (result ++ [(key, BoolValue true)])
          | _ :: rest ->
              parseArgsLoop rest result

        let parseArgs (args: List<String>) : ParsedArgs =
          parseArgsLoop args []

        let getStringArg (args: ParsedArgs) (key: String) (defaultValue: String) : String =
          match Stdlib.List.findFirst args (fun (k, _) -> k == key) with
          | Some (_, StringValue value) -> value
          | _ -> defaultValue

        let getIntArg (args: ParsedArgs) (key: String) (defaultValue: Int64) : Int64 =
          match Stdlib.List.findFirst args (fun (k, _) -> k == key) with
          | Some (_, IntValue value) -> value
          | _ -> defaultValue

        let getBoolArg (args: ParsedArgs) (key: String) (defaultValue: Bool) : Bool =
          match Stdlib.List.findFirst args (fun (k, _) -> k == key) with
          | Some (_, BoolValue value) -> value
          | _ -> defaultValue