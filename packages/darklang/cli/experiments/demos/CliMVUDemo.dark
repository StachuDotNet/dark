module Darklang =
  module Cli =
    module CliMVUDemo =
      // ==========================================
      // MVU-Based CLI Interface Demo
      // ==========================================

      // ---------- Model Types ----------
      type CommandHistory = List<String>
      type CompletionState = { suggestions: List<String>; selectedIndex: Int64; active: Bool }
      
      type CliMode = | CommandMode | HelpMode | CompletionMode
      
      type CliModel =
        { currentInput: String
          cursorPosition: Int64
          history: CommandHistory
          historyIndex: Int64
          output: List<String>
          mode: CliMode
          completion: CompletionState
          showWelcome: Bool }

      // ---------- Messages ----------
      type CliMsg =
        | InputChar of String
        | DeleteChar
        | MoveCursor of Int64
        | SubmitCommand
        | ShowHelp
        | HideHelp
        | StartCompletion
        | SelectCompletion of Int64
        | AcceptCompletion
        | CancelCompletion
        | HistoryUp
        | HistoryDown
        | ClearScreen
        | Exit

      // ---------- Commands Registry ----------
      type Command = { name: String; description: String; syntax: String; aliases: List<String> }
      
      let availableCommands : List<Command> =
        [ Command { name = "help"; description = "Show available commands"; syntax = "help [command]"; aliases = ["?"] }
        ; Command { name = "clear"; description = "Clear the screen"; syntax = "clear"; aliases = ["cls"] }
        ; Command { name = "history"; description = "Show command history"; syntax = "history"; aliases = ["hist"] }
        ; Command { name = "echo"; description = "Echo text to output"; syntax = "echo <text>"; aliases = [] }
        ; Command { name = "date"; description = "Show current date/time"; syntax = "date"; aliases = ["time"] }
        ; Command { name = "status"; description = "Show system status"; syntax = "status"; aliases = ["info"] }
        ; Command { name = "version"; description = "Show CLI version"; syntax = "version"; aliases = ["ver"] }
        ; Command { name = "tree"; description = "Show package tree structure"; syntax = "tree [path]"; aliases = ["ls", "dir"] }
        ; Command { name = "exit"; description = "Exit the CLI"; syntax = "exit"; aliases = ["quit", "q"] } ]

      // ---------- Model Functions ----------
      let initCliModel () : CliModel =
        CliModel
          { currentInput = ""
            cursorPosition = 0L
            history = []
            historyIndex = -1L
            output = []
            mode = CliMode.CommandMode
            completion = CompletionState { suggestions = []; selectedIndex = 0L; active = false }
            showWelcome = true }

      let addToHistory (history: CommandHistory) (command: String) : CommandHistory =
        if Stdlib.String.trim command == "" then
          history
        else
          let trimmed = Stdlib.String.trim command
          let filtered = history |> Stdlib.List.filter (fun h -> h != trimmed)
          Stdlib.List.append filtered [trimmed]

      let getCompletions (input: String) : List<String> =
        let inputLower = Stdlib.String.toLowercase input
        availableCommands
        |> Stdlib.List.filter (fun cmd ->
          Stdlib.String.startsWith cmd.name inputLower ||
          Stdlib.Option.isSome (Stdlib.List.findFirst cmd.aliases (fun alias -> Stdlib.String.startsWith alias inputLower)))
        |> Stdlib.List.map (fun cmd -> cmd.name)

      // ---------- Command Execution ----------
      let executeCommand (model: CliModel) (input: String) : CliModel =
        let parts = Stdlib.String.split (Stdlib.String.trim input) " "
        match parts with
        | [] -> model
        | command :: args ->
          let cmd = Stdlib.String.toLowercase command
          let output =
            match cmd with
            | "help" ->
                let helpText =
                  if Stdlib.List.isEmpty args then
                    ["Available commands:"; ""] ++
                    (availableCommands
                     |> Stdlib.List.map (fun c ->
                       let aliases = if Stdlib.List.isEmpty c.aliases then "" else " (" ++ Stdlib.String.join c.aliases ", " ++ ")"
                       "  " ++ Darklang.Cli.Colors.boldText c.name ++ aliases ++ " - " ++ c.description))
                  else
                    match Stdlib.List.head args with
                    | Some helpCmd ->
                        match Stdlib.List.findFirst availableCommands (fun c -> c.name == helpCmd) with
                        | Some cmd -> 
                            ["Command: " ++ Darklang.Cli.Colors.boldText cmd.name;
                             "Description: " ++ cmd.description;
                             "Syntax: " ++ cmd.syntax]
                        | None -> ["Unknown command: " ++ helpCmd]
                    | None -> ["Available commands listed above"]
                model.output ++ ["$ " ++ input] ++ helpText ++ [""]

            | "clear" ->
                []

            | "history" ->
                let historyLines =
                  model.history
                  |> Stdlib.List.indexedMap (fun i cmd -> 
                    Stdlib.Int64.toString (i + 1L) ++ ": " ++ cmd)
                model.output ++ ["$ " ++ input] ++ historyLines ++ [""]

            | "echo" ->
                let message = args |> Stdlib.String.join " "
                model.output ++ ["$ " ++ input; message; ""]

            | "date" ->
                model.output ++ ["$ " ++ input; "Current time: 2025-01-14 (simulated)"; ""]

            | "status" ->
                let statusInfo =
                  ["System Status:";
                   "  CLI Version: 2.0.0";
                   "  Commands Available: " ++ Stdlib.Int64.toString (Stdlib.List.length availableCommands);
                   "  History Size: " ++ Stdlib.Int64.toString (Stdlib.List.length model.history);
                   "  Mode: " ++ (match model.mode with CommandMode -> "Command" | HelpMode -> "Help" | CompletionMode -> "Completion")]
                model.output ++ ["$ " ++ input] ++ statusInfo ++ [""]

            | "version" ->
                model.output ++ ["$ " ++ input; "Darklang CLI v2.0.0 (MVU Demo)"; ""]

            | "tree" ->
                let treeView =
                  ["Package Structure:";
                   "📁 Darklang/";
                   "  📁 Stdlib/";
                   "    📄 List.dark";
                   "    📄 String.dark";
                   "    📄 Int64.dark";
                   "  📁 Cli/";
                   "    📄 Colors.dark";
                   "    📄 UIComponents.dark";
                   "    📄 CliMVUDemo.dark"]
                model.output ++ ["$ " ++ input] ++ treeView ++ [""]

            | "exit" | "quit" | "q" ->
                model.output ++ ["$ " ++ input; "Goodbye!"]

            | _ ->
                model.output ++ ["$ " ++ input; Darklang.Cli.Colors.error ("Unknown command: " ++ cmd); "Type 'help' for available commands"; ""]

          { model with
              output = output
              currentInput = ""
              cursorPosition = 0L
              history = addToHistory model.history input
              historyIndex = -1L
              completion = CompletionState { suggestions = []; selectedIndex = 0L; active = false } }

      // ---------- Update Function ----------
      let updateCliModel (model: CliModel) (msg: CliMsg) : CliModel =
        match msg with
        | InputChar char ->
            let newInput = 
              let before = Stdlib.String.slice model.currentInput 0L model.cursorPosition
              let after = Stdlib.String.dropFirst model.currentInput model.cursorPosition
              before ++ char ++ after
            let newCompletion = 
              if Stdlib.String.length newInput > 0L then
                let suggestions = getCompletions newInput
                CompletionState { suggestions = suggestions; selectedIndex = 0L; active = Stdlib.List.length suggestions > 0L }
              else
                CompletionState { suggestions = []; selectedIndex = 0L; active = false }
            { model with
                currentInput = newInput
                cursorPosition = model.cursorPosition + 1L
                completion = newCompletion }

        | DeleteChar ->
            if model.cursorPosition > 0L then
              let before = Stdlib.String.slice model.currentInput 0L (model.cursorPosition - 1L)
              let after = Stdlib.String.dropFirst model.currentInput model.cursorPosition
              let newInput = before ++ after
              let newCompletion = 
                if Stdlib.String.length newInput > 0L then
                  let suggestions = getCompletions newInput
                  CompletionState { suggestions = suggestions; selectedIndex = 0L; active = Stdlib.List.length suggestions > 0L }
                else
                  CompletionState { suggestions = []; selectedIndex = 0L; active = false }
              { model with
                  currentInput = newInput
                  cursorPosition = model.cursorPosition - 1L
                  completion = newCompletion }
            else
              model

        | MoveCursor offset ->
            let newPos = Stdlib.Int64.max 0L (Stdlib.Int64.min (Stdlib.String.length model.currentInput) (model.cursorPosition + offset))
            { model with cursorPosition = newPos }

        | SubmitCommand ->
            if model.completion.active && Stdlib.List.length model.completion.suggestions > 0L then
              updateCliModel model AcceptCompletion
            else if Stdlib.String.trim model.currentInput == "" then
              { model with output = model.output ++ ["$ "] }
            else
              executeCommand model model.currentInput

        | ShowHelp ->
            { model with mode = CliMode.HelpMode }

        | HideHelp ->
            { model with mode = CommandMode }

        | StartCompletion ->
            if Stdlib.String.length model.currentInput > 0L then
              let suggestions = getCompletions model.currentInput
              { model with
                  mode = CliMode.CompletionMode
                  completion = CompletionState { suggestions = suggestions; selectedIndex = 0L; active = true } }
            else
              model

        | SelectCompletion index ->
            let maxIndex = Stdlib.List.length model.completion.suggestions - 1L
            let newIndex = Stdlib.Int64.max 0L (Stdlib.Int64.min maxIndex index)
            { model with completion = CompletionState { model.completion with selectedIndex = newIndex } }

        | AcceptCompletion ->
            if model.completion.active then
              match Stdlib.List.getAt model.completion.suggestions model.completion.selectedIndex with
              | Some suggestion ->
                  { model with
                      currentInput = suggestion
                      cursorPosition = Stdlib.String.length suggestion
                      mode = CliMode.CommandMode
                      completion = CompletionState { suggestions = []; selectedIndex = 0L; active = false } }
              | None -> model
            else
              model

        | CancelCompletion ->
            { model with
                mode = CliMode.CommandMode
                completion = CompletionState { suggestions = []; selectedIndex = 0L; active = false } }

        | HistoryUp ->
            if Stdlib.List.length model.history > 0L then
              let newIndex = 
                if model.historyIndex == -1L then
                  Stdlib.List.length model.history - 1L
                else
                  Stdlib.Int64.max 0L (model.historyIndex - 1L)
              match Stdlib.List.getAt model.history newIndex with
              | Some cmd ->
                  { model with
                      currentInput = cmd
                      cursorPosition = Stdlib.String.length cmd
                      historyIndex = newIndex }
              | None -> model
            else
              model

        | HistoryDown ->
            if model.historyIndex >= 0L then
              let newIndex = model.historyIndex + 1L
              if newIndex >= Stdlib.List.length model.history then
                { model with
                    currentInput = ""
                    cursorPosition = 0L
                    historyIndex = -1L }
              else
                match Stdlib.List.getAt model.history newIndex with
                | Some cmd ->
                    { model with
                        currentInput = cmd
                        cursorPosition = Stdlib.String.length cmd
                        historyIndex = newIndex }
                | None -> model
            else
              model

        | ClearScreen ->
            { model with output = [] }

        | Exit ->
            executeCommand model "exit"

      // ---------- View Functions ----------
      let formatPrompt () : String =
        Darklang.Cli.Colors.info "darklang" ++ Darklang.Cli.Colors.dimText "@" ++ Darklang.Cli.Colors.boldText "cli" ++ Darklang.Cli.Colors.dimText " $ "

      let formatWelcome () : List<String> =
        [ Darklang.Cli.Colors.boldText "╔══════════════════════════════════════════════════════════════╗"
        ; Darklang.Cli.Colors.boldText "║                    Darklang CLI v2.0 (MVU Demo)             ║"
        ; Darklang.Cli.Colors.boldText "║                     Interactive Command Line                 ║"
        ; Darklang.Cli.Colors.boldText "╚══════════════════════════════════════════════════════════════╝"
        ; ""
        ; Darklang.Cli.Colors.hint "Type 'help' for available commands"
        ; Darklang.Cli.Colors.hint "Use Tab for autocompletion, ↑/↓ for history"
        ; Darklang.Cli.Colors.hint "Press Ctrl+C to exit"
        ; "" ]

      let formatCompletionBox (completion: CompletionState) : List<String> =
        if completion.active && Stdlib.List.length completion.suggestions > 0L then
          let suggestions =
            completion.suggestions
            |> Stdlib.List.indexedMap (fun i suggestion ->
              if i == completion.selectedIndex then
                "  ▶ " ++ Darklang.Cli.Colors.boldText (Darklang.Cli.Colors.info suggestion)
              else
                "    " ++ suggestion)
          let boxContent = (Darklang.Cli.UIComponents.Box.create 30L (Stdlib.List.length suggestions + 2L) Darklang.Cli.UIComponents.Box.Style.Single (["Completions:"] ++ suggestions))
          [""] ++ (Stdlib.String.split boxContent "\n")
        else
          []

      let viewCliModel (model: CliModel) : String =
        let outputLines =
          if model.showWelcome then
            formatWelcome () ++ model.output
          else
            model.output

        let promptLine = formatPrompt () ++ model.currentInput

        let completionLines = formatCompletionBox model.completion

        let helpSection =
          if model.mode == CliMode.HelpMode then
            let helpBox = 
              Darklang.Cli.UIComponents.Box.create 60L 8L Darklang.Cli.UIComponents.Box.Style.Double
                [ Darklang.Cli.Colors.boldText "Quick Help"
                ; ""
                ; "Tab: Show completions    ↑/↓: History navigation"
                ; "Enter: Execute command   Ctrl+C: Exit"
                ; "Ctrl+L: Clear screen     Esc: Cancel completion" ]
            [""] ++ (Stdlib.String.split helpBox "\n")
          else
            []

        let allLines = outputLines ++ [promptLine] ++ completionLines ++ helpSection
        Stdlib.String.join allLines "\n"

      // ---------- Main MVU Loop ----------
      let mvuLoop (model: CliModel) : Int64 =
        // Clear screen and render
        Builtin.print "\u001b[2J\u001b[H"
        Builtin.print (viewCliModel model)

        // Read input
        let keyInput = Stdlib.Cli.Stdin.readKey ()

        // Process input
        let newModel =
          match keyInput.key with
          // Character input
          | _ when Stdlib.Cli.Stdin.Key.isTextual keyInput.key ->
              if keyInput.keyChar != "" then
                updateCliModel model (CliMsg.InputChar keyInput.keyChar)
              else
                model

          // Control keys
          | Enter -> updateCliModel model CliMsg.SubmitCommand
          | Backspace -> updateCliModel model CliMsg.DeleteChar
          | LeftArrow -> updateCliModel model (CliMsg.MoveCursor (-1L))
          | RightArrow -> updateCliModel model (CliMsg.MoveCursor 1L)
          | UpArrow -> 
              if model.completion.active then
                updateCliModel model (CliMsg.SelectCompletion (model.completion.selectedIndex - 1L))
              else
                updateCliModel model CliMsg.HistoryUp
          | DownArrow -> 
              if model.completion.active then
                updateCliModel model (CliMsg.SelectCompletion (model.completion.selectedIndex + 1L))
              else
                updateCliModel model CliMsg.HistoryDown
          | Tab -> updateCliModel model CliMsg.StartCompletion
          | Escape -> updateCliModel model CliMsg.CancelCompletion
          | F1 -> updateCliModel model CliMsg.ShowHelp

          // Ctrl combinations
          | L when keyInput.modifiers.ctrl -> updateCliModel model CliMsg.ClearScreen
          | C when keyInput.modifiers.ctrl -> updateCliModel model CliMsg.Exit

          | _ -> model

        // Check for exit
        if Stdlib.Option.isSome (Stdlib.List.findFirst model.output (fun line -> Stdlib.String.contains line "Goodbye!")) then
          Builtin.print "\u001b[2J\u001b[H"
          0L
        else
          mvuLoop { newModel with showWelcome = false }

      let runCliMVUDemo (unit: Unit) : Int64 =
        let initialModel = initCliModel ()
        mvuLoop initialModel