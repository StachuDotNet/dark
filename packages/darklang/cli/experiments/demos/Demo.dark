// TODO rebrand as counter list demo
module Darklang.Cli.Demo


module Counter =
  type Model =
    { id: Int64
      value: Int64
      label: String }


  type Msg =
    | Increment
    | Decrement
    | Reset
    | SetValue of Int64


  let init (id: Int64) (label: String) : Model =
    Model { id = id; value = 0L; label = label }


  let update (model: Model) (msg: Msg) : Model =
    match msg with
    | Increment -> { model with value = model.value + 1L }
    | Decrement -> { model with value = model.value - 1L }
    | Reset -> { model with value = 0L }
    | SetValue v -> { model with value = v }


  let view (model: Model) : String =
    let coloredValue =
      if model.value > 0L then
        Colors.success (Stdlib.Int64.toString model.value)
      else if model.value < 0L then
        Colors.error (Stdlib.Int64.toString model.value)
      else
        Colors.info (Stdlib.Int64.toString model.value)

    $"[{model.label}]: {coloredValue}"


module CounterList =
  type Model =
    { counters: List<Counter.Model>
      nextId: Int64
      selectedIndex: Int64 }


  type Msg =
    | AddCounter of String
    | RemoveCounter of Int64
    | UpdateCounter of counterId: Int64 * counterMsg: Counter.Msg
    | SelectNext
    | SelectPrevious
    | IncrementSelected
    | DecrementSelected
    | ResetSelected
    | ResetAll


  let init () : Model =
    Model
      { counters =
          [ Counter.init 0L "Main"
            Counter.init 1L "Secondary"
            Counter.init 2L "Tertiary" ]
        nextId = 3L
        selectedIndex = 0L }


  let update (model: Model) (msg: CounterList.Msg) : Model =
    match msg with
    | AddCounter label ->
      let newCounter = Counter.init model.nextId label
      { model with
          counters = Stdlib.List.append model.counters [newCounter]
          nextId = model.nextId + 1L }

    | RemoveCounter id ->
      let newCounters = model.counters |> Stdlib.List.filter (fun c -> c.id != id)

      let newIndex =
        if model.selectedIndex >= Stdlib.List.length newCounters then
          Stdlib.Int64.max 0L (Stdlib.List.length newCounters - 1L)
        else
          model.selectedIndex

      { model with counters = newCounters; selectedIndex = newIndex }

    | UpdateCounter (counterId, counterMsg) ->
      let newCounters =
        model.counters
        |> Stdlib.List.map (fun c ->
          if c.id == counterId then
            Counter.update c counterMsg
          else
            c)
      { model with counters = newCounters }

    | SelectNext ->
      let maxIndex = Stdlib.List.length model.counters - 1L
      let newIndex =
        if model.selectedIndex < maxIndex then
          model.selectedIndex + 1L
        else
          0L
      { model with selectedIndex = newIndex }

    | SelectPrevious ->
      let maxIndex = Stdlib.List.length model.counters - 1L
      let newIndex =
        if model.selectedIndex > 0L then
          model.selectedIndex - 1L
        else
          maxIndex
      { model with selectedIndex = newIndex }

    | IncrementSelected ->
      match Stdlib.List.getAt model.counters model.selectedIndex with
      | Some counter ->
        update model (Msg.UpdateCounter (counter.id, Counter.Msg.Increment))
      | None -> model

    | DecrementSelected ->
      match Stdlib.List.getAt model.counters model.selectedIndex with
      | Some counter ->
        update model (Msg.UpdateCounter (counter.id, Counter.Msg.Decrement))
      | None -> model

    | ResetSelected ->
      match Stdlib.List.getAt model.counters model.selectedIndex with
      | Some counter ->
        update model (Msg.UpdateCounter (counter.id, Counter.Msg.Reset))
      | None -> model

    | ResetAll ->
        let newCounters =
          model.counters
          |> Stdlib.List.map (fun c -> updateCounter c Counter.Msg.Reset)
        { model with counters = newCounters }


  let view (model: Model) : String =
    let header = Colors.boldText "=== Counter List MVU Demo ==="

    let countersView =
      model.counters
      |> Stdlib.List.indexedMap (fun index counter ->
        let selector =
          if index == model.selectedIndex then
            Colors.boldText "> "
          else
            "  "
        selector ++ viewCounter counter)
      |> Stdlib.String.join "\n"

    let controls =
      "\n" ++ Colors.hint "Controls:" ++
      "\n  ↑/↓: Select counter | ←/→: Dec/Inc selected" ++
      "\n  +/-: Increment/Decrement selected" ++
      "\n  A: Add counter | D: Delete selected" ++
      "\n  R: Reset selected | Q: Quit demo" ++
      "\n  (lowercase keys also work)"

    let stats =
      let total =
        model.counters
        |> Stdlib.List.map (fun c -> c.value)
        |> Stdlib.List.fold 0L (fun acc v -> acc + v)
      $"\nTotal: {Colors.boldText (Stdlib.Int64.toString total)} | Counters: {Stdlib.Int64.toString (Stdlib.List.length model.counters)}"

    header ++ "\n\n" ++ countersView ++ "\n" ++ stats ++ "\n" ++ controls


let loop (model: CounterList.Model) : Int64 =
  // Clear screen and render
  Stdlib.print "\u001b[2J\u001b[H"
  Stdlib.printLine (viewCounterList model)

  // Read input
  let keyInput = Stdlib.Cli.Stdin.readKey ()

  // Process input
  let newModel =
    match keyInput.key with
    | UpArrow -> CounterList.update model CounterList.Msg.SelectPrevious
    | DownArrow -> CounterList.update model CounterList.Msg.SelectNext
    | LeftArrow -> CounterList.update model CounterList.Msg.DecrementSelected
    | RightArrow -> CounterList.update model CounterList.Msg.IncrementSelected
    | A ->
        let labelNum = model.nextId
        CounterList.update model (CounterList.Msg.AddCounter $"Counter {Stdlib.Int64.toString labelNum}")
    | D ->
        match Stdlib.List.getAt model.counters model.selectedIndex with
        | Some counter -> CounterList.update model (CounterList.Msg.RemoveCounter counter.id)
        | None -> model
    | R -> CounterList.update model CounterList.Msg.ResetSelected
    | Q -> model // Will exit on next check
    | OemPlus -> CounterList.update model CounterList.Msg.IncrementSelected
    | OemMinus -> CounterList.update model CounterList.Msg.DecrementSelected


  // Check for exit
  match keyInput.key with
  | Q ->
    Stdlib.print "\u001b[2J\u001b[H"
    Stdlib.printLine "Exiting MVU Counter Demo..."
    0L
  | _ ->
    loop newModel


let runMVUDemo (unit: Unit) : Int64 =
  loop (CounterList.init ())