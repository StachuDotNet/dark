module Darklang =
  module Cli =
    module ClassicUIDemo =
      // ==========================================
      // Darklang Classic UI Replica in CLI
      // ==========================================

      // ---------- Canvas & Function Types ----------
      type FunctionParameter = { name: String; typeName: String; description: String }
      type FunctionDef =
        { name: String
          parameters: List<FunctionParameter>
          returnType: String
          body: String
          isLambda: Bool }

      type HttpHandlerVerb = | GET | POST | PUT | DELETE | PATCH
      type HttpHandler =
        { verb: HttpHandlerVerb
          path: String
          fn: FunctionDef }

      type DataStore =
        { name: String
          fields: List<FunctionParameter>
          records: Int64 }

      type DarkType =
        { name: String
          definition: String
          usageCount: Int64 }

      type Canvas =
        { handlers: List<HttpHandler>
          functions: List<FunctionDef>
          datastores: List<DataStore>
          types: List<DarkType>
          selectedItem: String
          canvasName: String }

      // ---------- Editor State ----------
      type EditorMode = | FunctionEditor | HandlerEditor | DataStoreEditor | TypeEditor
      type ViewMode = | CanvasView | CodeView | LogsView | DocsView

      type ClassicUIModel =
        { canvas: Canvas
          currentView: ViewMode
          editorMode: EditorMode
          editingItem: String
          sidebarVisible: Bool
          notifications: List<String>
          realtimeData: (Int64 * Int64 * Int64) // requests, errors, latency
          executionTrace: List<String>
          searchQuery: String
          selectedFunction: String }

      // ---------- Messages ----------
      type ClassicUIMsg =
        | SwitchView of ViewMode
        | ToggleSidebar
        | SelectItem of String
        | EditItem of String * EditorMode
        | UpdateItem of String
        | AddHandler of HttpHandlerVerb * String
        | AddFunction of String
        | AddDataStore of String
        | AddType of String
        | DeleteItem of String
        | ExecuteFunction of String
        | UpdateSearch of String
        | RefreshData
        | ViewLogs
        | ShowDocs
        | NextItem
        | PreviousItem
        | Exit

      // ---------- Sample Data ----------
      let sampleHandlers () : List<HttpHandler> =
        [ HttpHandler
            { verb = HttpHandlerVerb.GET
              path = "/users"
              fn =
                FunctionDef
                  { name = "getUsers"
                    parameters = []
                    returnType = "List<User>"
                    body = "Db.getAll User"
                    isLambda = false } }
          HttpHandler
            { verb = HttpHandlerVerb.POST
              path = "/users"
              fn =
                FunctionDef
                  { name = "createUser"
                    parameters = [
                      FunctionParameter
                        { name = "user"
                          typeName = "User"
                          description = "User to create" } ]
                    returnType = "User"
                    body = "let newUser = User { name = user.name; email = user.email; id = Uuid.generate () }\nDb.insert newUser"
                    isLambda = false } }
        ; HttpHandler
            { verb = HttpHandlerVerb.GET
              path = "/health"
              fn =
                FunctionDef
                  { name = "healthCheck"
                    parameters = []
                    returnType = "String"
                    body = "\"OK\""
                    isLambda = false } } ]

      let sampleFunctions () : List<FunctionDef> =
        [ FunctionDef
            { name = "validateEmail"
              parameters = [
                FunctionParameter
                  { name = "email"
                    typeName = "String"
                    description = "Email to validate" } ]
              returnType = "Bool"
              body = "Stdlib.String.contains email \"@\""
              isLambda = false }
        ; FunctionDef
            { name = "hashPassword"
              parameters = [
                FunctionParameter
                  { name = "password"
                    typeName = "String"
                    description = "Password to hash" } ]
              returnType = "String"
              body = "Crypto.sha256 password"
              isLambda = false }
        ; FunctionDef
            { name = "formatUser"
              parameters = [
                FunctionParameter
                  { name = "user"
                    typeName = "User"
                    description = "User to format" } ]
              returnType = "String"
              body = "user.name ++ \" (\" ++ user.email ++ \")\""
              isLambda = false } ]

      let sampleDataStores () : List<DataStore> =
        let userFields =
          [ FunctionParameter
              { name = "id"
                typeName = "Uuid"
                description = "Unique identifier" }
          ; FunctionParameter
              { name = "name"
                typeName = "String"
                description = "Full name" }
          ; FunctionParameter
              { name = "email"
                typeName = "String"
                description = "Email address" }
          ; FunctionParameter
              { name = "createdAt"
                typeName = "DateTime"
                description = "Creation timestamp" } ]
        
        let sessionFields =
          [ FunctionParameter
              { name = "id"
                typeName = "String"
                description = "Session ID" }
          ; FunctionParameter
              { name = "userId"
                typeName = "Uuid"
                description = "User ID" }
          ; FunctionParameter
              { name = "expiresAt"
                typeName = "DateTime"
                description = "Expiration time" } ]
        
        [ DataStore
            { name = "User"
              fields = userFields
              records = 1247L }
        ; DataStore
            { name = "Session"
              fields = sessionFields
              records = 89L } ]

      let sampleTypes () : List<DarkType> =
        [ DarkType
            { name = "User"
              definition = "{ id: Uuid; name: String; email: String; createdAt: DateTime }"
              usageCount = 15L }
        ; DarkType
            { name = "Session"
              definition = "{ id: String; userId: Uuid; expiresAt: DateTime }"
              usageCount = 8L }
        ; DarkType
            { name = "ApiResponse"
              definition = "{ success: Bool; data: Any; message: String }"
              usageCount = 23L } ]

      // ---------- Model Functions ----------
      let initClassicUIModel () : ClassicUIModel =
        let canvas =
          Canvas
            { handlers = sampleHandlers ()
              functions = sampleFunctions ()
              datastores = sampleDataStores ()
              types = sampleTypes ()
              selectedItem = "/users GET"
              canvasName = "user-management-v2" }

        ClassicUIModel
          { canvas = canvas
            currentView = ViewMode.CanvasView
            editorMode = EditorMode.HandlerEditor
            editingItem = ""
            sidebarVisible = true
            notifications = ["Canvas loaded successfully"; "3 handlers active"; "Live traffic detected"]
            realtimeData = (1247L, 12L, 95L)
            executionTrace = ["[14:32:15] GET /users → 200 (12ms)"; "[14:32:18] POST /users → 201 (34ms)"; "[14:32:21] GET /health → 200 (2ms)"]
            searchQuery = ""
            selectedFunction = "getUsers" }

      // ---------- View Helper Functions ----------
      let formatHttpVerb (verb: HttpHandlerVerb) : String =
        let verbStr =
          match verb with
          | GET -> "GET"
          | POST -> "POST"
          | PUT -> "PUT"
          | DELETE -> "DELETE"
          | PATCH -> "PATCH"

        let color =
          match verb with
          | GET -> Darklang.Cli.Colors.info
          | POST -> Darklang.Cli.Colors.success
          | PUT -> Darklang.Cli.Colors.warning
          | DELETE -> Darklang.Cli.Colors.error
          | PATCH -> Darklang.Cli.Colors.hint

        color verbStr

      let formatDataStoreStats (ds: DataStore) : String =
        let recordsColor =
          if ds.records > 1000L then Darklang.Cli.Colors.success
          else if ds.records > 100L then Darklang.Cli.Colors.warning
          else Darklang.Cli.Colors.dimText

        recordsColor (Stdlib.Int64.toString ds.records ++ " records")

      let formatRealTimeStats (stats: (Int64 * Int64 * Int64)) : List<String> =
        let (requests, errors, latency) = stats
        let errorRate = if requests == 0L then 0L else Stdlib.Int64.divide (errors * 100L) requests
        
        let errorColor = 
          if errors > 0L then
            Darklang.Cli.Colors.error
          else
            Darklang.Cli.Colors.success
        
        let rateColor = 
          if errorRate > 5L then
            Darklang.Cli.Colors.error
          else
            Darklang.Cli.Colors.success
        
        let latencyColor = 
          if latency > 100L then
            Darklang.Cli.Colors.warning
          else
            Darklang.Cli.Colors.success

        [ Darklang.Cli.Colors.boldText "🚀 Live Statistics"
        ; "Requests: " ++ Darklang.Cli.Colors.info (Stdlib.Int64.toString requests)
        ; "Errors: " ++ errorColor (Stdlib.Int64.toString errors)
        ; "Error Rate: " ++ rateColor (Stdlib.Int64.toString errorRate ++ "%")
        ; "Avg Latency: " ++ latencyColor (Stdlib.Int64.toString latency ++ "ms") ]

      // ---------- View Functions ----------
      let viewSidebar (model: ClassicUIModel) : List<String> =
        if model.sidebarVisible then
          let canvasHeader = 
            [ Darklang.Cli.Colors.boldText ("📦 " ++ model.canvas.canvasName)
            ; ""
            ; Darklang.Cli.Colors.boldText ("🌐 HTTP Handlers (" ++ Stdlib.Int64.toString (Stdlib.List.length model.canvas.handlers) ++ ")") ]
          
          let handlersList =
            model.canvas.handlers
            |> Stdlib.List.map (fun h ->
               let isSelected = model.canvas.selectedItem == (h.path ++ " " ++ (match h.verb with GET -> "GET" | POST -> "POST" | PUT -> "PUT" | DELETE -> "DELETE" | PATCH -> "PATCH"))
               let marker = if isSelected then "▶ " else "  "
               marker ++ formatHttpVerb h.verb ++ " " ++ h.path)
          
          let canvasSection = Stdlib.List.append canvasHeader handlersList

          let functionsSection =
            Stdlib.List.append
              [""; Darklang.Cli.Colors.boldText ("⚡ Functions (" ++ Stdlib.Int64.toString (Stdlib.List.length model.canvas.functions) ++ ")")]
              (model.canvas.functions
             |> Stdlib.List.map (fun f ->
               let isSelected = model.canvas.selectedItem == f.name
               let marker = if isSelected then "▶ " else "  "
               marker ++ f.name ++ "(" ++ Stdlib.Int64.toString (Stdlib.List.length f.parameters) ++ ")"))

          let datastoreSection =
            Stdlib.List.append
              [""; Darklang.Cli.Colors.boldText ("🗄️ DataStores (" ++ Stdlib.Int64.toString (Stdlib.List.length model.canvas.datastores) ++ ")")]
              (model.canvas.datastores
             |> Stdlib.List.map (fun ds ->
               let isSelected = model.canvas.selectedItem == ds.name
               let marker = if isSelected then "▶ " else "  "
               marker ++ ds.name ++ " (" ++ formatDataStoreStats ds ++ ")"))

          let typeSection =
            Stdlib.List.append
              [""; Darklang.Cli.Colors.boldText ("📋 Types (" ++ Stdlib.Int64.toString (Stdlib.List.length model.canvas.types) ++ ")")]
              (model.canvas.types
             |> Stdlib.List.map (fun t ->
               let isSelected = model.canvas.selectedItem == t.name
               let marker = if isSelected then "▶ " else "  "
               marker ++ t.name ++ " (" ++ Stdlib.Int64.toString t.usageCount ++ " uses)"))

          canvasSection
          |> Stdlib.List.append functionsSection
          |> Stdlib.List.append datastoreSection
          |> Stdlib.List.append typeSection
        else
          []

      let viewMainPanel (model: ClassicUIModel) : List<String> =
        match model.currentView with
        | CanvasView ->
            let header = [Darklang.Cli.Colors.boldText "✨ Darklang Classic Canvas"; ""]

            let selectedItemInfo =
              if model.canvas.selectedItem == "/users GET" then
                let selectedHeader = 
                  ["Currently editing: " ++ Darklang.Cli.Colors.info "GET /users";
                   "Function: getUsers";
                   "Returns: List<User>";
                   "";
                   Darklang.Cli.Colors.boldText "Function Body:"]
                let boxLines = Stdlib.String.split (Darklang.Cli.UIComponents.Box.create 50L 3L Darklang.Cli.UIComponents.Box.Style.Single ["Db.getAll User"]) "\n"
                Stdlib.List.append selectedHeader boxLines
              else if model.canvas.selectedItem == "getUsers" then
                let selectedHeader =
                  ["Currently editing: " ++ Darklang.Cli.Colors.warning "Function getUsers";
                   "Parameters: none";
                   "Return Type: List<User>";
                   "";
                   Darklang.Cli.Colors.boldText "Implementation:"]
                let boxLines = 
                  Stdlib.String.split (Darklang.Cli.UIComponents.Box.create 50L 5L Darklang.Cli.UIComponents.Box.Style.Single
                    ["// Fetch all users from database";
                     "let users = Db.getAll User";
                     "// Return user list";
                     "users"]) "\n"
                Stdlib.List.append selectedHeader boxLines
              else
                ["Select an item from the sidebar to edit"]

            Stdlib.List.append header selectedItemInfo

        | CodeView ->
            let codeHeader = [Darklang.Cli.Colors.boldText "💻 Code Editor - " ++ model.selectedFunction; ""]
            let codeBox =
              Darklang.Cli.UIComponents.Box.create 70L 15L Darklang.Cli.UIComponents.Box.Style.Double
                ["// Function: " ++ model.selectedFunction;
                 "let " ++ model.selectedFunction ++ " = ";
                 "  // Implementation here";
                 "  let users = Db.getAll User";
                 "  |> Stdlib.List.filter (fun user -> ";
                 "    validateEmail user.email)";
                 "  |> Stdlib.List.map (fun user ->";
                 "    formatUser user)";
                 "";
                 "  users";
                 "";
                 "// Tests:";
                 "// ✅ Returns empty list when no users";
                 "// ✅ Filters invalid emails";
                 "// ⏳ Performance test pending"]
            let codeContent = Stdlib.String.split codeBox "\n"
            Stdlib.List.append codeHeader codeContent

        | LogsView ->
            let logsHeader = [Darklang.Cli.Colors.boldText "📊 Execution Logs"; ""]
            let logsBox =
              Darklang.Cli.UIComponents.Box.create 70L 12L Darklang.Cli.UIComponents.Box.Style.Single
                (model.executionTrace ++
                 ["[14:32:25] GET /users → " ++ Darklang.Cli.Colors.success "200" ++ " (8ms)";
                  "[14:32:28] POST /users → " ++ Darklang.Cli.Colors.success "201" ++ " (22ms)";
                  "[14:32:30] GET /health → " ++ Darklang.Cli.Colors.success "200" ++ " (1ms)";
                  "[14:32:33] GET /users/123 → " ++ Darklang.Cli.Colors.error "404" ++ " (5ms)";
                  "[14:32:35] POST /users → " ++ Darklang.Cli.Colors.error "400" ++ " (15ms) - Validation failed"])
            let logsContent = Stdlib.String.split logsBox "\n"
            Stdlib.List.append logsHeader logsContent

        | DocsView ->
            let docsHeader = [Darklang.Cli.Colors.boldText "📚 Documentation"; ""]
            let docsBox =
              Darklang.Cli.UIComponents.Box.create 70L 15L Darklang.Cli.UIComponents.Box.Style.Rounded
                ["Welcome to Darklang Classic!";
                 "";
                 "🚀 Quick Start:";
                 "  • Create HTTP handlers to expose APIs";
                 "  • Define functions for business logic";
                 "  • Set up datastores for persistence";
                 "  • Create custom types for structure";
                 "";
                 "⌨️ Keyboard Shortcuts:";
                 "  • F1: Canvas View    F2: Code Editor";
                 "  • F3: Logs View      F4: Documentation";
                 "  • Tab: Toggle Sidebar";
                 "  • Ctrl+N: New Function";
                 "  • Ctrl+S: Save Changes"]
            let docsContent = Stdlib.String.split docsBox "\n"
            Stdlib.List.append docsHeader docsContent

      let viewStatusBar (model: ClassicUIModel) : String =
        let mode = 
          match model.currentView with
          | CanvasView -> "Canvas"
          | CodeView -> "Code"
          | LogsView -> "Logs"
          | DocsView -> "Docs"

        let stats = (formatRealTimeStats model.realtimeData) |> Stdlib.String.join " | "

        let statusModel = 
          Darklang.CLI.Experiments.UICatalog.Components.StatusBar.StatusBarModel
            { leftText = Darklang.Cli.Colors.boldText ("Mode: " ++ mode ++ " | Selected: " ++ model.canvas.selectedItem)
            ; rightText = Darklang.Cli.Colors.hint (stats)
            ; centerText = ""
            ; width = 80L
            ; backgroundColor = Darklang.CLI.Experiments.UICatalog.Core.Types.Color.Default }
        Darklang.CLI.Experiments.UICatalog.Components.StatusBar.renderStatusBar statusModel

      let viewNotifications (model: ClassicUIModel) : List<String> =
        if Stdlib.List.length model.notifications > 0L then
          let notificationContent = Stdlib.List.append [Darklang.Cli.Colors.boldText "🔔 Notifications"] model.notifications
          let notificationBox = Darklang.Cli.UIComponents.Box.create 80L (Stdlib.List.length model.notifications + 2L) Darklang.Cli.UIComponents.Box.Style.Dashed notificationContent
          Stdlib.List.append [""] (Stdlib.String.split notificationBox "\n")
        else
          []

      let viewClassicUIModel (model: ClassicUIModel) : String =
        let sidebar = viewSidebar model
        let mainPanel = viewMainPanel model
        let statusBar = [viewStatusBar model]
        let notifications = viewNotifications model

        let contentLines =
          if model.sidebarVisible then
            let sidebarBox = Darklang.Cli.UIComponents.Box.create 32L (Stdlib.List.length sidebar + 2L) Darklang.Cli.UIComponents.Box.Style.Single sidebar
            let mainBox = Darklang.Cli.UIComponents.Box.create 45L (Stdlib.List.length mainPanel + 2L) Darklang.Cli.UIComponents.Box.Style.Single mainPanel
            // Merge boxes side by side with 1 space gap
            let sidebarLines = Stdlib.String.split sidebarBox "\n"
            let mainLines = Stdlib.String.split mainBox "\n"
            let maxLines = Stdlib.Int64.max (Stdlib.List.length sidebarLines) (Stdlib.List.length mainLines)
            let mergedLines = 
              (Stdlib.List.range 0L (maxLines - 1L))
              |> Stdlib.List.map (fun i ->
                let leftLine = 
                  match Stdlib.List.getAt sidebarLines i with
                  | Some line -> line
                  | None -> Stdlib.String.repeat " " 32L
                let rightLine = 
                  match Stdlib.List.getAt mainLines i with
                  | Some line -> line
                  | None -> ""
                leftLine ++ " " ++ rightLine)
            let mergedBoxes = Stdlib.String.join mergedLines "\n"
            Stdlib.String.split mergedBoxes "\n"
          else
            mainPanel

        let allLines = 
          contentLines
          |> Stdlib.List.append statusBar
          |> Stdlib.List.append notifications
        Stdlib.String.join allLines "\n"

      // ---------- Update Function ----------
      let updateClassicUIModel (model: ClassicUIModel) (msg: ClassicUIMsg) : ClassicUIModel =
        match msg with
        | SwitchView view ->
            { model with currentView = view }

        | ToggleSidebar ->
            { model with sidebarVisible = Stdlib.Bool.not model.sidebarVisible }

        | SelectItem item ->
            { model with canvas = Canvas { model.canvas with selectedItem = item } }

        | EditItem (item, mode) ->
            { model with editingItem = item; editorMode = mode; currentView = ViewMode.CodeView }

        | UpdateItem item ->
            let newNotifications = Stdlib.List.append model.notifications ["Updated " ++ item ++ " successfully"]
            { model with notifications = newNotifications }

        | AddHandler (verb, path) ->
            let verbStr = 
              match verb with
              | GET -> "GET"
              | POST -> "POST"
              | PUT -> "PUT"
              | DELETE -> "DELETE"
              | PATCH -> "PATCH"
            let newHandler =
              HttpHandler
                { verb = verb
                  path = path
                  fn =
                    FunctionDef
                      { name = "newHandler"
                        parameters = []
                        returnType = "String"
                        body = "\"Hello World\""
                        isLambda = false } }
            let newCanvas = Canvas { model.canvas with handlers = Stdlib.List.append model.canvas.handlers [newHandler] }
            let newNotifications = Stdlib.List.append model.notifications ["Added " ++ verbStr ++ " " ++ path ++ " handler"]
            { model with canvas = newCanvas; notifications = newNotifications }

        | AddFunction name ->
            let newFunction =
              FunctionDef
                { name = name
                  parameters = []
                  returnType = "String"
                  body = "\"TODO\""
                  isLambda = false }
            let newCanvas = Canvas { model.canvas with functions = Stdlib.List.append model.canvas.functions [newFunction] }
            let newNotifications = Stdlib.List.append model.notifications ["Added fn " ++ name]
            { model with canvas = newCanvas; notifications = newNotifications }

        | AddDataStore name ->
            let newDataStore =
              DataStore
                { name = name
                  fields = []
                  records = 0L }
            let newCanvas = Canvas { model.canvas with datastores = Stdlib.List.append model.canvas.datastores [newDataStore] }
            let newNotifications = Stdlib.List.append model.notifications ["Added datastore " ++ name]
            { model with canvas = newCanvas; notifications = newNotifications }

        | AddType name ->
            let newType =
              DarkType
                { name = name
                  definition = "{}"
                  usageCount = 0L }
            let newCanvas = Canvas { model.canvas with types = Stdlib.List.append model.canvas.types [newType] }
            let newNotifications = Stdlib.List.append model.notifications ["Added type " ++ name]
            { model with canvas = newCanvas; notifications = newNotifications }

        | DeleteItem item ->
            let newNotifications = Stdlib.List.append model.notifications ["Deleted " ++ item]
            { model with notifications = newNotifications }

        | ExecuteFunction funcName ->
            let (requests, errors, latency) = model.realtimeData
            let newStats = (requests + 1L, errors, latency)
            let newTrace = Stdlib.List.append model.executionTrace ["[Now] Executed " ++ funcName ++ " → Success (12ms)"]
            let newNotifications = Stdlib.List.append model.notifications ["Executed " ++ funcName ++ " successfully"]
            { model with realtimeData = newStats; executionTrace = newTrace; notifications = newNotifications }

        | UpdateSearch query ->
            { model with searchQuery = query }

        | RefreshData ->
            let (requests, errors, latency) = model.realtimeData
            let newStats = (requests + Stdlib.Random.int64Between 1L 10L, errors + Stdlib.Random.int64Between 0L 1L, Stdlib.Random.int64Between 50L 150L)
            { model with realtimeData = newStats }

        | ViewLogs ->
            { model with currentView = LogsView }

        | ShowDocs ->
            { model with currentView = ViewMode.DocsView }

        | NextItem | PreviousItem ->
            model

        | Exit ->
            model

      // ---------- Main MVU Loop ----------
      let mvuLoop (model: ClassicUIModel) : Int64 =
        // Clear screen and render
        Builtin.print "\u001b[2J\u001b[H"
        Builtin.printLine (viewClassicUIModel model)

        // Read input
        let keyInput = Stdlib.Cli.Stdin.readKey ()

        // Process input
        let newModel =
          match keyInput.key with
          | F1 -> updateClassicUIModel model (ClassicUIMsg.SwitchView ViewMode.CanvasView)
          | F2 -> updateClassicUIModel model (ClassicUIMsg.SwitchView ViewMode.CodeView)
          | F3 -> updateClassicUIModel model (ClassicUIMsg.SwitchView ViewMode.LogsView)
          | F4 -> updateClassicUIModel model (ClassicUIMsg.SwitchView ViewMode.DocsView)
          | Tab -> updateClassicUIModel model ClassicUIMsg.ToggleSidebar
          | R -> updateClassicUIModel model ClassicUIMsg.RefreshData
          | E -> updateClassicUIModel model (ClassicUIMsg.ExecuteFunction model.selectedFunction)
          | N when keyInput.modifiers.ctrl -> updateClassicUIModel model (ClassicUIMsg.AddFunction "newFunction")
          | Q when keyInput.modifiers.ctrl -> updateClassicUIModel model ClassicUIMsg.Exit
          | Q -> updateClassicUIModel model ClassicUIMsg.Exit
          | _ -> model

        // Check for exit
        match keyInput.key with
        | Q when keyInput.modifiers.ctrl ->
            Builtin.print "\u001b[2J\u001b[H"
            Builtin.printLine "Exiting Darklang Classic UI..."
            0L
        | Q ->
            Builtin.print "\u001b[2J\u001b[H"
            Builtin.printLine "Exiting Darklang Classic UI..."
            0L
        | _ -> mvuLoop newModel

      let runClassicUIDemo (unit: Unit) : Int64 =
        let initialModel = initClassicUIModel ()
        mvuLoop initialModel