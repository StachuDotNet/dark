module Darklang =
  module Cli =
    module MVUCli =
      // ==========================================
      // MVU-based CLI Implementation
      // ==========================================

      // ---------- Model Types ----------
      type CompletionState =
        { suggestions: List<String>
          selectedIndex: Int64
          isVisible: Bool }

      type CliModel =
        { // Core input state
          currentInput: String
          cursorPosition: Int64
          isExiting: Bool

          // Command execution
          outputHistory: List<String>
          isExecutingCommand: Bool
          lastCommand: String
          lastOutput: String

          // Package navigation (retain existing functionality)
          currentPath: List<String>  // PackagePath
          pathHistory: List<List<String>>

          // Interactive features
          commandHistory: List<String>
          historyIndex: Int64

          // UI state
          completions: CompletionState
          showHelp: Bool
          helpCommand: String
          errorMessage: String

          // Display state
          needsRedraw: Bool
          terminalWidth: Int64
          terminalHeight: Int64 }

      // ---------- Messages ----------
      type CliMsg =
        | InputCharacter of String
        | SpecialKey of Stdlib.Cli.Stdin.Key.Key
        | ExecuteCommand
        | ShowCompletions
        | HideCompletions
        | SelectCompletion of Int64
        | NavigateHistory of direction: Int64  // -1 for up, 1 for down
        | ClearScreen
        | ShowCommandHelp of String
        | HideHelp
        | ChangeDirectory of List<String>
        | UpdatePath of List<String>
        | DisplayError of String
        | ClearError
        | Exit
        | Redraw

      // ---------- Model Initialization ----------
      let initCliModel () : CliModel =
        CliModel
          { currentInput = ""
            cursorPosition = 0L
            isExiting = false
            outputHistory = []
            isExecutingCommand = false
            lastCommand = ""
            lastOutput = ""
            currentPath = []
            pathHistory = []
            commandHistory = []
            historyIndex = -1L
            completions = CompletionState { suggestions = []; selectedIndex = 0L; isVisible = false }
            showHelp = false
            helpCommand = ""
            errorMessage = ""
            needsRedraw = true
            terminalWidth = 80L
            terminalHeight = 24L }

      // ---------- Command Integration ----------
      // Wrapper to integrate existing command handlers with MVU
      type MVUCommandResult =
        { newModel: CliModel
          outputLines: List<String>
          shouldExit: Bool }

      let executeMVUCommand (model: CliModel) (commandName: String) (args: List<String>) : MVUCommandResult =
        // Convert CliModel to legacy AppState for compatibility
        let legacyState =
          AppState
            { isExiting = false
              lastCommand = model.lastCommand
              output = model.lastOutput
              mainPrompt = ""
              needsFullRedraw = false
              currentPath = model.currentPath
              pathHistory = model.pathHistory
              currentLocation = Packages.Path.pathToLocation model.currentPath
              currentPage = Page.MainPrompt
              commandHistory = model.commandHistory
              historyIndex = model.historyIndex }

        // Execute command using existing registry
        let resultState = Registry.executeCommand commandName legacyState args

        // Convert back to CliModel
        let updatedModel =
          { model with
              lastCommand = resultState.lastCommand
              lastOutput = resultState.output
              currentPath = resultState.currentPath
              pathHistory = resultState.pathHistory
              commandHistory = resultState.commandHistory
              historyIndex = resultState.historyIndex
              outputHistory = Stdlib.List.append model.outputHistory [resultState.output]
              isExecutingCommand = false
              needsRedraw = true }

        MVUCommandResult
          { newModel = updatedModel
            outputLines = [resultState.output]
            shouldExit = resultState.isExiting }

      // ---------- Completion System ----------
      let updateCompletions (model: CliModel) : CliModel =
        if Stdlib.String.isEmpty model.currentInput then
          { model with completions = CompletionState { suggestions = []; selectedIndex = 0L; isVisible = false } }
        else
          // Use existing completion system
          let legacyState =
            Darklang.Cli.AppState
              { isExiting = false
                lastCommand = model.lastCommand
                output = model.lastOutput
                mainPrompt = ""
                needsFullRedraw = false
                currentPath = model.currentPath
                pathHistory = model.pathHistory
                currentLocation = Packages.Path.pathToLocation model.currentPath
                currentPage = Page.MainPrompt
                commandHistory = model.commandHistory
                historyIndex = model.historyIndex }

          let suggestions = Registry.getCompletions legacyState model.currentInput
          let shouldShow = Stdlib.List.length suggestions > 0L

          { model with
              completions =
                CompletionState
                  { suggestions = suggestions
                    selectedIndex = 0L
                    isVisible = shouldShow } }

      // ---------- Update Function ----------
      let updateCliModel (model: CliModel) (msg: CliMsg) : CliModel =
        match msg with
        | InputCharacter char ->
            let newInput = model.currentInput ++ char
            let updatedModel = { model with currentInput = newInput; cursorPosition = model.cursorPosition + 1L }
            updateCompletions updatedModel

        | SpecialKey key ->
            match key with
            | Backspace ->
                if model.cursorPosition > 0L then
                  let newInput = Stdlib.String.slice model.currentInput 0L (model.cursorPosition - 1L) ++
                                 Stdlib.String.dropFirst model.currentInput model.cursorPosition
                  let updatedModel = { model with currentInput = newInput; cursorPosition = model.cursorPosition - 1L }
                  updateCompletions updatedModel
                else
                  model

            | Tab ->
                if model.completions.isVisible && Stdlib.List.length model.completions.suggestions > 0L then
                  match Stdlib.List.getAt model.completions.suggestions model.completions.selectedIndex with
                  | Some completion ->
                      { model with
                          currentInput = completion
                          cursorPosition = Stdlib.String.length completion
                          completions = CompletionState { suggestions = model.completions.suggestions; selectedIndex = model.completions.selectedIndex; isVisible = false } }
                  | None -> model
                else
                  updateCompletions model

            | UpArrow ->
                if model.completions.isVisible then
                  let newIndex = if model.completions.selectedIndex > 0L then model.completions.selectedIndex - 1L else 0L
                  { model with completions = CompletionState { suggestions = model.completions.suggestions; selectedIndex = newIndex; isVisible = model.completions.isVisible } }
                else
                  updateCliModel model (NavigateHistory -1L)

            | DownArrow ->
                if model.completions.isVisible then
                  let maxIndex = Stdlib.List.length model.completions.suggestions - 1L
                  let newIndex = if model.completions.selectedIndex < maxIndex then model.completions.selectedIndex + 1L else maxIndex
                  { model with completions = CompletionState { suggestions = model.completions.suggestions; selectedIndex = newIndex; isVisible = model.completions.isVisible } }
                else
                  updateCliModel model (NavigateHistory 1L)

            | Escape ->
                { model with
                    completions = CompletionState { suggestions = model.completions.suggestions; selectedIndex = model.completions.selectedIndex; isVisible = false }
                    showHelp = false
                    errorMessage = "" }

            | _ -> model

        | ExecuteCommand ->
            if Stdlib.String.isEmpty (Stdlib.String.trim model.currentInput) then
              model
            else
              let trimmed = Stdlib.String.trim model.currentInput
              let parts = Stdlib.String.split trimmed " "
              match parts with
              | [] -> model
              | commandName :: args ->
                  // Add to history
                  let newHistory = Stdlib.List.append model.commandHistory [trimmed]
                  let updatedModel = { model with
                                         commandHistory = newHistory
                                         historyIndex = -1L
                                         currentInput = ""
                                         cursorPosition = 0L
                                         completions = CompletionState { suggestions = model.completions.suggestions; selectedIndex = model.completions.selectedIndex; isVisible = false }
                                         isExecutingCommand = true }

                  // Execute command
                  let result = executeMVUCommand updatedModel commandName args
                  if result.shouldExit then
                    { result.newModel with isExiting = true }
                  else
                    result.newModel

        | NavigateHistory direction ->
            let historySize = Stdlib.List.length model.commandHistory
            if historySize > 0L then
              let newIndex =
                if direction < 0L then
                  // Going up (to older commands)
                  if model.historyIndex == -1L then
                    historySize - 1L
                  else if model.historyIndex > 0L then
                    model.historyIndex - 1L
                  else
                    model.historyIndex
                else
                  // Going down (to newer commands)
                  if model.historyIndex == -1L then
                    -1L
                  else if model.historyIndex < historySize - 1L then
                    model.historyIndex + 1L
                  else
                    -1L

              let newInput =
                if newIndex == -1L then
                  ""
                else
                  match Stdlib.List.getAt model.commandHistory newIndex with
                  | Some cmd -> cmd
                  | None -> ""

              { model with
                  currentInput = newInput
                  cursorPosition = Stdlib.String.length newInput
                  historyIndex = newIndex }
            else
              model

        | ClearScreen ->
            { model with
                outputHistory = []
                needsRedraw = true }

        | ShowCommandHelp helpCmd ->
            { model with
                showHelp = true
                helpCommand = helpCmd
                needsRedraw = true }

        | HideHelp ->
            { model with
                showHelp = false
                needsRedraw = true }

        | DisplayError errorMsg ->
            { model with
                errorMessage = errorMsg
                needsRedraw = true }

        | ClearError ->
            { model with
                errorMessage = ""
                needsRedraw = true }

        | Exit ->
            { model with isExiting = true }

        | _ -> model

      // ---------- View Functions ----------
      let formatPath (path: List<String>) : String =
        if Stdlib.List.isEmpty path then
          "~"
        else
          "/" ++ Stdlib.String.join path "/"

      let viewPrompt (model: CliModel) : String =
        let pathStr = formatPath model.currentPath
        let promptText = Colors.info pathStr ++ Colors.boldText " $ "
        let inputText = model.currentInput

        // Add cursor if not at end
        let displayInput =
          if model.cursorPosition == Stdlib.String.length inputText then
            inputText ++ Colors.hint "_"
          else
            let before = Stdlib.String.slice inputText 0L model.cursorPosition
            let cursor = Colors.boldText "_"
            let after = Stdlib.String.dropFirst inputText (model.cursorPosition + 1L)
            before ++ cursor ++ after

        promptText ++ displayInput

      let viewCompletions (model: CliModel) : List<String> =
        if model.completions.isVisible && Stdlib.List.length model.completions.suggestions > 0L then
          // Simple text-based completions without fancy UI boxes
          model.completions.suggestions
          |> Stdlib.List.indexedMap (fun i suggestion ->
              if i == model.completions.selectedIndex then
                "> " ++ suggestion ++ " <"
              else
                "  " ++ suggestion)
        else
          []

      let viewOutput (model: CliModel) : List<String> =
        // Don't show any output history in the view - REPL mode shows output immediately
        []

      let viewHelp (model: CliModel) : String =
        if model.showHelp then
          if Stdlib.String.isEmpty model.helpCommand then
            // Show general help using existing system
            let helpContent = Registry.getCommandList ()
            let helpLines = Stdlib.String.split helpContent "\n"
            UIComponents.Modal.create "Help - All Commands" helpLines ["Close (Esc)"]
          else
            // Show specific command help
            let legacyState = initState ()
            let helpState = Registry.executeCommandHelp model.helpCommand legacyState
            let helpLines = Stdlib.String.split helpState.output "\n"
            UIComponents.Modal.create $"Help - {model.helpCommand}" helpLines ["Close (Esc)"]
        else
          ""

      let viewError (model: CliModel) : List<String> =
        if Stdlib.String.isEmpty model.errorMessage then
          []
        else
          [UIComponents.Notification.create
             UIComponents.Notification.Type.Error
             "Error"
             model.errorMessage]

      let viewCliModel (model: CliModel) : String =
        // REPL-style view: just show completions and current prompt
        let completionSection = viewCompletions model
        let promptLine = viewPrompt model
        let errorSection = viewError model

        let parts = []
        let parts = if Stdlib.List.isEmpty completionSection then parts else Stdlib.List.append parts completionSection
        let parts = Stdlib.List.append parts [promptLine]  
        let parts = if Stdlib.List.isEmpty errorSection then parts else Stdlib.List.append parts errorSection

        Stdlib.String.join parts "\n"

      // ---------- Main MVU Loop ----------
      let handleKeyInput (keyInput: Stdlib.Cli.Stdin.KeyRead.KeyRead) : CliMsg =
        match keyInput.key with
        | Enter -> CliMsg.ExecuteCommand
        | Tab -> CliMsg.SpecialKey keyInput.key
        | Backspace -> CliMsg.SpecialKey keyInput.key
        | UpArrow -> CliMsg.SpecialKey keyInput.key
        | DownArrow -> CliMsg.SpecialKey keyInput.key
        | Escape -> CliMsg.SpecialKey keyInput.key
        | F1 -> CliMsg.ShowCommandHelp ""
        | C when keyInput.modifiers.ctrl -> CliMsg.Exit
        | _ ->
            if Stdlib.String.isEmpty keyInput.keyChar then
              CliMsg.SpecialKey keyInput.key
            else
              CliMsg.InputCharacter keyInput.keyChar

      let mvuCliLoop (model: CliModel) : Int64 =
        if model.isExiting then
          Builtin.printLine "Goodbye!"
          0L
        else
          // REPL-style rendering
          if model.needsRedraw then
            // After command execution, print new output and show fresh prompt
            if Stdlib.Bool.not (Stdlib.String.isEmpty model.lastOutput) then
              Builtin.printLine model.lastOutput
            let promptLine = viewPrompt model
            Builtin.print promptLine
          else
            // During typing, just update the current line in-place
            let promptLine = viewPrompt model
            // Show completions above prompt if visible
            if model.completions.isVisible && Stdlib.List.length model.completions.suggestions > 0L then
              Builtin.printLine ""  // New line
              let completions = viewCompletions model
              if Stdlib.Bool.not (Stdlib.List.isEmpty completions) then
                Builtin.printLine (Stdlib.String.join completions "\n")
            // Use carriage return to go to start of line, then overwrite
            Builtin.print ("\r" ++ promptLine ++ "\u001b[K")

          // Read input
          let keyInput = Stdlib.Cli.Stdin.readKey ()
          let msg = handleKeyInput keyInput
          let newModel = updateCliModel { model with needsRedraw = false } msg

          mvuCliLoop newModel

      // ---------- Entry Points ----------
      let runMVUCli () : Int64 =
        // Print welcome message
        Builtin.printLine "Welcome to Darklang CLI (MVU Edition)"
        Builtin.printLine "Type 'help' to see available commands."
        
        let initialModel = initCliModel ()
        let promptLine = viewPrompt initialModel
        Builtin.print promptLine
        mvuCliLoop initialModel

      let runMVUCliWithArgs (args: List<String>) : Int64 =
        match args with
        | [] -> runMVUCli ()
        | _ ->
            // Execute single command and exit
            let initialModel = initCliModel ()
            let command = Stdlib.String.join args " "
            let parts = Stdlib.String.split command " "
            match parts with
            | [] -> 0L
            | commandName :: cmdArgs ->
                let result = executeMVUCommand initialModel commandName cmdArgs
                Builtin.printLine result.newModel.lastOutput
                if result.shouldExit then 0L else 0L