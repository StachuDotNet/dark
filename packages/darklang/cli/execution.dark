module Darklang =
  module Cli =
    module Execution =
      // Run command - execute functions or scripts
      let executeRun (state: AppState) (args: List<String>) : AppState =
        match args with
        | [] ->
          Builtin.printLine "Usage: run @function_name [args...] | run script_path [args...]"
          Builtin.printLine "  run @Stdlib.Int64.add 5L 3L    - Run a function"
          Builtin.printLine "  run script.dark arg1 arg2      - Run a script file"
          { state with lastCommand = "run error"; output = "run usage displayed" }
        | thingToRun :: restArgs ->
          if Stdlib.String.startsWith thingToRun "@" then
            // Function execution
            let fnName = Stdlib.String.dropFirst thingToRun 1L
            executeFunction state fnName restArgs
          else
            // Script execution
            executeScript state thingToRun restArgs

      // Helper function to execute a function
      let executeFunction (state: AppState) (fnName: String) (args: List<String>) : AppState =
        let onMissing = LanguageTools.NameResolver.OnMissing.Allow
        let pm = LanguageTools.PackageManager.pm ()

        let (parsedArgs, _unres) =
          args
          |> Stdlib.List.map (fun arg ->
            arg
            |> LanguageTools.Parser.parseToSimplifiedTree
            |> LanguageTools.Parser.parseFromTree
            |> Builtin.unwrap
            |> fun parsedFile ->
              match parsedFile with
              | SourceFile source -> source.exprsToEval)
          |> Stdlib.List.flatten
          |> Stdlib.List.map (fun arg ->
            LanguageTools.WrittenTypesToProgramTypes.Expr.toPT onMissing pm "" [] arg)
          |> Stdlib.List.unzip

        match Builtin.cliExecuteFunction fnName parsedArgs with
        | Ok result ->
          Builtin.printLine result
          { state with lastCommand = "run"; output = result }
        | Error err ->
          Builtin.printLine $"Error: {err}"
          { state with lastCommand = "run error"; output = $"error: {err}" }

      // Helper function to execute a script
      let executeScript (state: AppState) (scriptPath: String) (args: List<String>) : AppState =
        match Builtin.fileRead scriptPath with
        | Ok script ->
          let scriptSourceCode = Stdlib.String.fromBytesWithReplacement script
          let result = Builtin.cliParseAndExecuteScript scriptPath scriptSourceCode args

          match result with
          | Ok exitCode ->
            let message = $"Script executed with exit code: {Stdlib.Int64.toString exitCode}"
            Builtin.printLine message
            { state with lastCommand = "run"; output = message }
          | Error e ->
            let prettyError = PrettyPrinter.RuntimeTypes.RuntimeError.toString e
            Builtin.printLine $"Script error: {prettyError}"
            { state with lastCommand = "run error"; output = $"script error: {prettyError}" }
        | Error e ->
          Builtin.printLine $"File error: {e}"
          { state with lastCommand = "run error"; output = $"file error: {e}" }

      let runHelp (state: AppState) : AppState =
        Builtin.printLine "Usage: run @function_name [args...] | run script_path [args...]"
        Builtin.printLine "Run a function from the package manager or execute a Dark script file."
        Builtin.printLine ""
        Builtin.printLine "Function execution:"
        Builtin.printLine "  run @Stdlib.Int64.add 5L 3L      - Run a function with arguments"
        Builtin.printLine "  run @Stdlib.Bool.and true false   - Another function example"
        Builtin.printLine ""
        Builtin.printLine "Script execution:"
        Builtin.printLine "  run script.dark                  - Run a script file"
        Builtin.printLine "  run script.dark arg1 arg2        - Run script with arguments"
        { state with lastCommand = "help run"; output = "run help displayed" }

      // Get files in a directory - returns just filenames
      let getDirectoryContents (path: String) : List<String> =
        let currentDir = Builtin.directoryCurrent ()

        let fullPath =
          if Stdlib.String.startsWith path "/" then
            path
          else
            // Normalize path by removing leading "./" if present
            let normalizedPath =
              if Stdlib.String.startsWith path "./" then
                Stdlib.String.dropFirst path 2L
              else
                path
            $"{currentDir}/{normalizedPath}"

        let files = Builtin.directoryList fullPath

        files
        |> Stdlib.List.map (fun fullFilePath ->
          // Extract just the filename from the full path
          match Stdlib.String.split fullFilePath "/" with
          | [] -> fullFilePath
          | parts ->
            match Stdlib.List.last parts with
            | Some filename -> filename
            | None -> fullFilePath)

      // Check if a path is a directory - expects full path
      let isDirectoryAtPath (dirPath: String) (fileName: String) : Bool =
        let currentDir = Builtin.directoryCurrent ()
        let normalizedDirPath =
          if Stdlib.String.startsWith dirPath "/" then
            dirPath
          else if Stdlib.String.startsWith dirPath "./" then
            let withoutDot = Stdlib.String.dropFirst dirPath 2L
            $"{currentDir}/{withoutDot}"
          else
            $"{currentDir}/{dirPath}"
        let fullPath = $"{normalizedDirPath}/{fileName}"
        Builtin.fileIsDirectory fullPath

      let runComplete (state: AppState) (args: List<String>) : List<String> =
        match args with
        | [] ->
          // Complete with function prefix or show current directory contents
          let currentDirFiles = getDirectoryContents "."
          let currentDir = Builtin.directoryCurrent ()
          let directories = currentDirFiles |> Stdlib.List.filter (fun file -> isDirectoryAtPath currentDir file)
          let darkFiles = currentDirFiles |> Stdlib.List.filter (fun file -> Stdlib.String.endsWith file ".dark")
          // Just show directories and .dark files - no hardcoded function prefixes
          Stdlib.List.append directories darkFiles

        | [partialArg] ->
          if Stdlib.String.startsWith partialArg "@" then
            // Complete function names - query actual package manager
            let pm = LanguageTools.PackageManager.pm ()
            let allFunctions = LanguageTools.PackageManager.allFunctions pm
            allFunctions
            |> Stdlib.List.map (fun fn -> $"@{fn.name}")
            |> Stdlib.List.filter (fun name ->
              Stdlib.String.startsWith name partialArg)
          else if partialArg == "." then
            // Special case: "." means show all files in current directory
            let currentDir = Builtin.directoryCurrent ()
            let files = getDirectoryContents "."
            files
            |> Stdlib.List.map (fun file ->
              if isDirectoryAtPath currentDir file then
                $"{file}/"
              else
                file)
          else if partialArg == ".." then
            // Special case: ".." means parent directory
            ["../"]
          else
            // Complete filesystem paths
            let currentDir = Builtin.directoryCurrent ()
            if Stdlib.String.contains partialArg "/" then
              // Has directory separator, get directory part
              match Stdlib.String.lastIndexOf partialArg "/" with
              | Some idx ->
                let dirPart = Stdlib.String.slice partialArg 0L (idx + 1L)
                let filePart = Stdlib.String.dropFirst partialArg (idx + 1L)
                let fullDirPath =
                  if Stdlib.String.startsWith dirPart "/" then
                    dirPart
                  else
                    $"{currentDir}/{dirPart}"
                let files = getDirectoryContents fullDirPath
                files
                |> Stdlib.List.filter (fun file ->
                  Stdlib.String.startsWith file filePart)
                |> Stdlib.List.map (fun file ->
                  if isDirectoryAtPath fullDirPath file then
                    $"{dirPart}{file}/"
                  else
                    $"{dirPart}{file}")
              | None -> []
            else
              // No directory separator, complete in current directory
              let files = getDirectoryContents "."
              files
              |> Stdlib.List.filter (fun file ->
                Stdlib.String.startsWith file partialArg)
              |> Stdlib.List.map (fun file ->
                if isDirectoryAtPath currentDir file then
                  $"{file}/"
                else
                  file)
        | _ -> []

      // Eval command - evaluate Dark expressions
      let executeEval (state: AppState) (args: List<String>) : AppState =
        match args with
        | [] ->
          Builtin.printLine "Usage: eval <expression>"
          Builtin.printLine "  eval 1L + 2L                    - Evaluate arithmetic"
          Builtin.printLine "  eval \"hello\" ++ \"world\"        - String concatenation"
          Builtin.printLine "  eval [1L; 2L; 3L] |> List.length - List operations"
          { state with lastCommand = "eval error"; output = "eval usage displayed" }
        | _ ->
          let expr = Stdlib.String.join args " "
          match Builtin.cliEvaluateExpression expr with
          | Ok result ->
            Builtin.printLine result
            { state with lastCommand = "eval"; output = result }
          | Error err ->
            let prettyError = PrettyPrinter.RuntimeTypes.RuntimeError.toString err
            Builtin.printLine $"Error: {prettyError}"
            { state with lastCommand = "eval error"; output = $"error: {prettyError}" }

      let evalHelp (state: AppState) : AppState =
        Builtin.printLine "Usage: eval <expression>"
        Builtin.printLine "Evaluate a Dark expression and display the result."
        Builtin.printLine ""
        Builtin.printLine "Examples:"
        Builtin.printLine "  eval 1L + 2L                     - Arithmetic operations"
        Builtin.printLine "  eval \"hello\" ++ \"world\"         - String concatenation"
        Builtin.printLine "  eval [1L; 2L; 3L] |> List.length  - List operations"
        Builtin.printLine "  eval Stdlib.String.length \"test\" - Function calls"
        { state with lastCommand = "help eval"; output = "eval help displayed" }

      let evalComplete (state: AppState) (args: List<String>) : List<String> =
        // For eval completion, we could potentially complete function names, but for now keep it simple
        []