module Darklang =
  module Cli =
    module Tests =
      type TestResult =
        | Pass
        | Fail of message: String

      let runCliCommand (args: List<String>): String =
        let escapedArgs =
          args
          |> Stdlib.List.map (fun arg ->
            if Stdlib.String.contains arg " " ||
               Stdlib.String.contains arg "|" ||
               Stdlib.String.contains arg "\""
            then
              let escapedArg = Stdlib.String.replaceAll arg "\"" "\\\""
              $"'{escapedArg}'"
            else arg)
        let argsString = Stdlib.String.join escapedArgs " "
        let command = $"./scripts/run-cli {argsString}"
        let result = Stdlib.Cli.Unix.executeInDirectoryWithOutput "." command
        if result.exitCode == 0L
        then Stdlib.String.trim result.stdout
        else $"ERROR: {result.stderr}"


      let testHelpCommand (): TestResult =
        let output = runCliCommand ["help"]
        if Stdlib.String.contains output "Available commands:" &&
           Stdlib.String.contains output "help" &&
           Stdlib.String.contains output "version" &&
           Stdlib.String.contains output "status"
        then TestResult.Pass
        else TestResult.Fail "Expected help text with available commands"

      let testVersionCommand (): TestResult =
        let output = runCliCommand ["version"]
        if Stdlib.String.contains output "Darklang CLI" &&
           Stdlib.String.contains output "alpha-"
        then TestResult.Pass
        else TestResult.Fail "Expected version string with 'Darklang CLI alpha-'"

      let testStatusCommand (): TestResult =
        let output = runCliCommand ["status"]
        if Stdlib.String.contains output "Darklang CLI" &&
           Stdlib.String.contains output "Location:" &&
           Stdlib.String.contains output "Mode:"
        then TestResult.Pass
        else TestResult.Fail "Expected status output with CLI info, Location, and Mode"

      let testRunBoolAnd (): TestResult =
        let output = runCliCommand ["run"; "@Darklang.Stdlib.Bool.and true false"]
        if output == "false"
        then TestResult.Pass
        else TestResult.Fail $"Expected 'false', got '{output}'"

      let testRunInt64Add (): TestResult =
        let output = runCliCommand ["run"; "@Darklang.Stdlib.Int64.add 5L 3L"]
        if output == "8"
        then TestResult.Pass
        else TestResult.Fail $"Expected '8', got '{output}'"

      let testEvalStringLength (): TestResult =
        let output = runCliCommand ["eval"; "Darklang.Stdlib.String.length \"hello\""]
        if output == "5"
        then TestResult.Pass
        else TestResult.Fail $"Expected '5', got '{output}'"

      let testEvalListLength (): TestResult =
        let output = runCliCommand ["eval"; "[1L; 2L; 3L] |> Darklang.Stdlib.List.length"]
        if output == "3"
        then TestResult.Pass
        else TestResult.Fail $"Expected '3', got '{output}'"

      let testListFunctions (): TestResult =
        let output = runCliCommand ["ls"; "Darklang.Stdlib.List"]
        if Stdlib.String.contains output "Items in current directory:" &&
           Stdlib.String.contains output "functions"
        then TestResult.Pass
        else TestResult.Fail "Expected directory listing with functions"

      let testViewFunction (): TestResult =
        let output = runCliCommand ["view"; "Darklang.Stdlib.List.head"]
        if Stdlib.String.contains output "List.head" &&
           (Stdlib.String.contains output "Option" || Stdlib.String.contains output "->")
        then TestResult.Pass
        else TestResult.Fail "Expected function signature for List.head"

      let testListTypes (): TestResult =
        let output = runCliCommand ["ls"; "Darklang.Stdlib.Option"]
        if Stdlib.String.contains output "Items in current directory:" &&
           Stdlib.String.contains output "types"
        then TestResult.Pass
        else TestResult.Fail "Expected directory listing with types"

      let testHelpForRun (): TestResult =
        let output = runCliCommand ["help"; "run"]
        if Stdlib.String.contains output "run" &&
           (Stdlib.String.contains output "function" || Stdlib.String.contains output "execute")
        then TestResult.Pass
        else TestResult.Fail "Expected help text for 'run' command"

      let testHelpForLs (): TestResult =
        let output = runCliCommand ["help"; "ls"]
        if Stdlib.String.contains output "ls" &&
           (Stdlib.String.contains output "list" || Stdlib.String.contains output "List")
        then TestResult.Pass
        else TestResult.Fail "Expected help text for 'ls' command"

      let testEvalSimpleExpression (): TestResult =
        let output = runCliCommand ["eval"; "2L + 3L"]
        if output == "5"
        then TestResult.Pass
        else TestResult.Fail $"Expected '5', got '{output}'"

      let testEvalStringExpression (): TestResult =
        let output = runCliCommand ["eval"; "\"hello\" ++ \"world\""]
        if output == "helloworld"
        then TestResult.Pass
        else TestResult.Fail $"Expected 'helloworld', got '{output}'"

      type TestFunction = Unit -> TestResult

      let allTests (): List<String * TestFunction> =
        [ ("CLI Help Command", fun () -> testHelpCommand ())
          ("CLI Version Command", fun () -> testVersionCommand ())
          ("CLI Status Command", fun () -> testStatusCommand ())
          ("CLI Run Bool.and", fun () -> testRunBoolAnd ())
          ("CLI Run Int64.add", fun () -> testRunInt64Add ())
          ("CLI Eval String Length", fun () -> testEvalStringLength ())
          ("CLI Eval List Length", fun () -> testEvalListLength ())
          ("CLI List Functions", fun () -> testListFunctions ())
          ("CLI View Function", fun () -> testViewFunction ())
          ("CLI List Types", fun () -> testListTypes ())
          ("CLI Help for Run", fun () -> testHelpForRun ())
          ("CLI Help for Ls", fun () -> testHelpForLs ())
          ("CLI Eval Simple Expression", fun () -> testEvalSimpleExpression ())
          ("CLI Eval String Expression", fun () -> testEvalStringExpression ()) ]

      type TestSummary =
        { totalTests: Int64
          passedTests: Int64
          failedTests: Int64
          failedTestNames: List<String> }

      let runAllTests (): Int64 =
        let tests = allTests ()

        Builtin.printLine ""
        Builtin.printLine "Darklang CLI Tests"
        Builtin.printLine "=================="

        let initialSummary =
          TestSummary
            { totalTests = 0L
              passedTests = 0L
              failedTests = 0L
              failedTestNames = [] }

        let finalSummary =
          tests
          |> Stdlib.List.fold initialSummary (fun summary (name, testFn) ->
            Builtin.printLine ""
            Builtin.printLine $"Running: {name} ..."

            let newSummary =
              { summary with totalTests = summary.totalTests + 1L }

            match testFn () with
            | Pass ->
              Builtin.printLine $"âœ“ PASS - {name}"
              { newSummary with passedTests = newSummary.passedTests + 1L }
            | Fail message ->
              Builtin.printLine $"âœ— FAIL - {name}"
              Builtin.printLine $"  Reason: {message}"
              { newSummary with
                  failedTests = newSummary.failedTests + 1L
                  failedTestNames = Stdlib.List.push newSummary.failedTestNames name })

        Builtin.printLine ""
        Builtin.printLine "ðŸ“Š Test Results Summary"
        Builtin.printLine "======================"
        Builtin.printLine $"Total tests:  {Stdlib.Int64.toString finalSummary.totalTests}"
        Builtin.printLine $"Passed:       {Stdlib.Int64.toString finalSummary.passedTests}"
        Builtin.printLine $"Failed:       {Stdlib.Int64.toString finalSummary.failedTests}"

        if finalSummary.failedTests == 0L then
          Builtin.printLine "ðŸŽ‰ All tests passed!"
          0L
        else
          Builtin.printLine "ðŸš¨ Some tests failed!"
          if Stdlib.Bool.not (Stdlib.List.isEmpty finalSummary.failedTestNames) then
            Builtin.printLine "Failed tests:"
            finalSummary.failedTestNames
            |> Stdlib.List.iter (fun testName ->
              Builtin.printLine $"  âœ— {testName}")
          1L


// # Plans for Interactive CLI Testing Support

// ## Current Limitation
// We can test CLI commands that take input and immediately return output, but we cannot test the interactive CLI mode where the CLI shows a prompt, waits for user input, processes it, shows results, and waits for more input.

// For example, we cannot currently test:
// 1. Starting the CLI in interactive mode
// 2. Typing "help" and seeing the help output
// 3. Typing "version" and seeing version info
// 4. Typing "quit" to exit

// This requires process spawning and bidirectional communication with a running process.

// ## Proposed API Design Options

// ### Option 1: High-level interaction API
// ```dark
// // Simple step-by-step interaction
// type InteractionStep =
//   | Send of input: String                    // Send input to process
//   | ExpectContains of text: String           // Expect output to contain text
//   | ExpectExact of text: String              // Expect exact output match
//   | ExpectPrompt                             // Wait for CLI prompt ("> ")
//   | ExpectExit of exitCode: Int64            // Expect process to exit
//   | Sleep of milliseconds: Int64             // Wait before next step

// let runInteractiveTest (command: List<String>) (steps: List<InteractionStep>): TestResult =
//   // Implementation would spawn process and execute steps sequentially
//   // Returns Pass or Fail based on whether all steps succeeded

// // Example usage:
// let testInteractiveHelp (): TestResult =
//   runInteractiveTest
//     ["./scripts/run-cli"]
//     [ ExpectPrompt
//       Send "help\n"
//       ExpectContains "Available commands:"
//       ExpectPrompt
//       Send "quit\n"
//       ExpectExit 0L ]
// ```

// ### Option 2: Process handle API
// ```dark
// type ProcessHandle = // Opaque type representing running process

// module Process =
//   let spawn (command: List<String>): ProcessHandle
//   let sendInput (process: ProcessHandle) (input: String): Unit
//   let readOutput (process: ProcessHandle): String            // Non-blocking read
//   let readOutputUntil (process: ProcessHandle) (delimiter: String): String  // Block until delimiter
//   let isRunning (process: ProcessHandle): Bool
//   let waitForExit (process: ProcessHandle): Int64
//   let kill (process: ProcessHandle): Unit

// // Example usage:
// let testInteractiveFlow (): TestResult =
//   let process = Process.spawn ["./scripts/run-cli"]
//   let initialOutput = Process.readOutputUntil process "> "
//   let _ = Process.sendInput process "help\n"
//   let helpOutput = Process.readOutputUntil process "> "
//   let _ = Process.sendInput process "quit\n"
//   let exitCode = Process.waitForExit process

//   if Stdlib.String.contains helpOutput "Available commands:" && exitCode == 0L
//   then Pass
//   else Fail "Interactive test failed"
// ```

// ### Option 3: Callback-based API
// ```dark
// let withInteractiveProcess
//   (command: List<String>)
//   (fn: ProcessHandle -> TestResult): TestResult =
//   // Spawn process, call fn with handle, ensure cleanup

// // Example usage:
// let testInteractiveSession (): TestResult =
//   withInteractiveProcess ["./scripts/run-cli"] (fun process ->
//     let _ = Process.readOutputUntil process "> "
//     let _ = Process.sendInput process "version\n"
//     let output = Process.readOutputUntil process "> "
//     let _ = Process.sendInput process "quit\n"

//     if Stdlib.String.contains output "Darklang CLI"
//     then Pass
//     else Fail "Version command failed"
//   )
// ```

// ## Implementation Considerations

// 1. **Buffering and Timing**
//    - How do we handle partial output that arrives in chunks?
//    - Do we need timeouts for readOutputUntil operations?
//    - How do we detect when the CLI is ready for input vs still processing?

// 2. **Platform Compatibility**
//    - Need to work on Linux, macOS, Windows
//    - Different process spawning mechanisms (fork/exec, CreateProcess, etc.)
//    - Different signal handling and process termination

// 3. **Error Handling**
//    - What if the process crashes unexpectedly?
//    - What if the process hangs and never produces expected output?
//    - How do we clean up zombie processes?

// 4. **Resource Management**
//    - Ensure processes are always terminated even if tests fail
//    - Handle stdin/stdout/stderr file descriptors properly
//    - Prevent file descriptor leaks

// 5. **Testing Robustness**
//    - Tests should be deterministic and not flaky
//    - Need to handle timing variations between different machines
//    - Consider CI environment differences

// ## Next Steps

// 1. **Prototype with existing tools**: Before implementing process spawning in Darklang, we could prototype interactive tests using external tools like `expect` or `pexpect` called via executeInDirectoryWithOutput

// 2. **Design the Darklang API**: Based on prototyping results, design the cleanest API for process interaction that fits Darklang's style

// 3. **Implement minimal process spawning**: Start with basic spawn/read/write/wait functionality and expand as needed

// 4. **Add interactive test cases**: Once the API exists, add tests for:
//    - Interactive help navigation
//    - Multi-command sessions
//    - Error handling in interactive mode
//    - Tab completion (if supported)
//    - History navigation (if supported)

// ## Recommendation

// For now, we'll stick with the simple non-interactive tests. When ready to tackle interactive testing, we should start with **Option 2 (Process handle API)** as it provides the most flexibility while still being reasonably simple to use.