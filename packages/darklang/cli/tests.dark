module Darklang =
  module Cli =
    module Tests =
      type TestResult =
        | Pass
        | Fail of message: String


      let runWithCommand (args: List<String>): String =
        let escapedArgs =
          args
          |> Stdlib.List.map (fun arg ->
            if Stdlib.String.contains arg " " ||
               Stdlib.String.contains arg "|" ||
               Stdlib.String.contains arg "\""
            then
              let escapedArg = Stdlib.String.replaceAll arg "\"" "\\\""
              $"'{escapedArg}'"
            else arg)

        let argsString = Stdlib.String.join escapedArgs " "
        let command = $"./scripts/run-cli {argsString}"
        let result = Stdlib.Cli.Unix.executeInDirectoryWithOutput "." command

        if result.exitCode == 0L then
          Stdlib.String.trim result.stdout
        else
          $"ERROR: {result.stderr}"


      let testHelpCommand (): TestResult =
        let output = runWithCommand ["help"]

        if Stdlib.String.contains output "Available commands:" &&
           Stdlib.String.contains output "help" &&
           Stdlib.String.contains output "version" &&
           Stdlib.String.contains output "status" then
            TestResult.Pass
        else
          TestResult.Fail "Expected help text with available commands"


      let testVersionCommand (): TestResult =
        let output = runWithCommand ["version"]
        if Stdlib.String.contains output "Darklang CLI" &&
           Stdlib.String.contains output "alpha-" then
           TestResult.Pass
        else
          TestResult.Fail "Expected version string with 'Darklang CLI alpha-'"


      let testStatusCommand (): TestResult =
        let output = runWithCommand ["status"]
        if Stdlib.String.contains output "Darklang CLI" &&
           Stdlib.String.contains output "Location:" &&
           Stdlib.String.contains output "Mode:" then
          TestResult.Pass
        else
          TestResult.Fail "Expected status output with CLI info, Location, and Mode"


      let testRunBoolAnd (): TestResult =
        let output = runWithCommand ["run"; "@Stdlib.Bool.and true false"]
        if output == "false" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected 'false', got '{output}'"


      let testRunInt64Add (): TestResult =
        let output = runWithCommand ["run"; "@Stdlib.Int64.add 5L 3L"]
        if output == "8" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected '8', got '{output}'"


      let testEvalStringLength (): TestResult =
        let output = runWithCommand ["eval"; "Stdlib.String.length \"hello\""]
        if output == "5" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected '5', got '{output}'"


      let testEvalListLength (): TestResult =
        let output = runWithCommand ["eval"; "[1L; 2L; 3L] |> Stdlib.List.length"]
        if output == "3" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected '3', got '{output}'"


      let testListFunctions (): TestResult =
        let output = runWithCommand ["ls"; "Stdlib.List"]
        if Stdlib.String.contains output "Functions" &&
           Stdlib.String.contains output "head" then
            TestResult.Pass
        else
          TestResult.Fail "Expected directory listing with functions"


      let testViewFunction (): TestResult =
        let output = runWithCommand ["view"; "Stdlib.List.head"]
        Builtin.debug "output" output
        if Stdlib.String.contains output "head"
          && Stdlib.String.contains output "Option"
          && Stdlib.String.contains output "->"
        then
            TestResult.Pass
        else
          TestResult.Fail "Expected function signature for List.head"


      let testListTypes (): TestResult =
        let output = runWithCommand ["ls"; "Stdlib.Option"]
        if Stdlib.String.contains output "Types" &&
           Stdlib.String.contains output "Option" then
            TestResult.Pass
        else
          TestResult.Fail "Expected directory listing with types"


      let testHelpForRun (): TestResult =
        let output = runWithCommand ["help"; "run"]
        if Stdlib.String.contains output "run" &&
           (Stdlib.String.contains output "function" || Stdlib.String.contains output "execute") then
            TestResult.Pass
        else
          TestResult.Fail "Expected help text for 'run' command"


      let testHelpForLs (): TestResult =
        let output = runWithCommand ["help"; "ls"]
        if Stdlib.String.contains output "ls" &&
           (Stdlib.String.contains output "list" || Stdlib.String.contains output "List") then
            TestResult.Pass
        else
          TestResult.Fail "Expected help text for 'ls' command"


      let testEvalSimpleExpression (): TestResult =
        let output = runWithCommand ["eval"; "2L + 3L"]
        if output == "5" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected '5', got '{output}'"


      let testEvalStringExpression (): TestResult =
        let output = runWithCommand ["eval"; "\"hello\" ++ \"world\""]
        if output == "helloworld" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected 'helloworld', got '{output}'"


      type TestFunction = Unit -> TestResult

      let allTests (): List<String * TestFunction> =
        [ ("Help", fun () -> testHelpCommand ())
          ("Version", fun () -> testVersionCommand ())
          ("Status", fun () -> testStatusCommand ())

          ("Run Bool.and", fun () -> testRunBoolAnd ())
          ("Run Int64.add", fun () -> testRunInt64Add ())

          ("Eval String Length", fun () -> testEvalStringLength ())
          ("Eval List Length", fun () -> testEvalListLength ())

          ("List Functions", fun () -> testListFunctions ())
          ("View Function", fun () -> testViewFunction ())
          ("List Types", fun () -> testListTypes ())

          ("Help for Run", fun () -> testHelpForRun ())
          ("Help for Ls", fun () -> testHelpForLs ())

          ("Eval Simple Expression", fun () -> testEvalSimpleExpression ())
          ("Eval String Expression", fun () -> testEvalStringExpression ())
        ]

      type TestSummary =
        { totalTests: Int64
          passedTests: Int64
          failedTests: Int64
          failedTestNames: List<String> }

      // Sequential test execution - proven to be ~30-50% faster than parallel for CLI tests
      // due to process startup overhead and resource contention
      let runAllTests (): Int64 =
        let tests = allTests ()

        Builtin.printLine ""
        Builtin.printLine "Darklang CLI Tests"
        Builtin.printLine "=================="

        let initialSummary =
          TestSummary
            { totalTests = 0L
              passedTests = 0L
              failedTests = 0L
              failedTestNames = [] }

        let finalSummary =
          tests
          |> Stdlib.List.fold initialSummary (fun summary (name, testFn) ->
            Builtin.printLine ""
            Builtin.printLine $"Running: {name} ..."

            let newSummary =
              { summary with totalTests = summary.totalTests + 1L }

            match testFn () with
            | Pass ->
              Builtin.printLine $"âœ“ PASS - {name}"
              { newSummary with passedTests = newSummary.passedTests + 1L }
            | Fail message ->
              Builtin.printLine $"âœ— FAIL - {name}"
              Builtin.printLine $"  Reason: {message}"
              { newSummary with
                  failedTests = newSummary.failedTests + 1L
                  failedTestNames = Stdlib.List.push newSummary.failedTestNames name })

        Builtin.printLine ""
        Builtin.printLine "ðŸ“Š Test Results Summary"
        Builtin.printLine "======================"
        Builtin.printLine $"Total tests:  {Stdlib.Int64.toString finalSummary.totalTests}"
        Builtin.printLine $"Passed:       {Stdlib.Int64.toString finalSummary.passedTests}"
        Builtin.printLine $"Failed:       {Stdlib.Int64.toString finalSummary.failedTests}"

        if finalSummary.failedTests == 0L then
          Builtin.printLine "ðŸŽ‰ All tests passed!"
          0L
        else
          Builtin.printLine "ðŸš¨ Some tests failed!"
          if Stdlib.Bool.not (Stdlib.List.isEmpty finalSummary.failedTestNames) then
            Builtin.printLine "Failed tests:"
            finalSummary.failedTestNames
            |> Stdlib.List.iter (fun testName ->
              Builtin.printLine $"  âœ— {testName}")
          1L