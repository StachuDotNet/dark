module Darklang =
  module Cli =
    // ================================
    // TYPES - Core type definitions
    // ================================
    
    type Msg =
      | ProcessInput of String
      | KeyPressed of key: Stdlib.Cli.Stdin.Key.Key * modifiers: Stdlib.Cli.Stdin.Modifiers.Modifiers * keyChar: Stdlib.Option.Option<String>
      | Exit


    // CLEANUP ugh the tree stuff has bled into this... why?
    // we should refactor back to some Page situation
    // on most pages, we render the normal Prompt stuff
    // ... but not on all pages.

    // Interactive UI modes
    type InteractiveUIMode =
      | PromptMode        // Normal command prompt
      | TreeNavigationMode of TreeNavState  // Interactive tree navigation

    // Tree navigation state
    type TreeNavState =
      { startPath: PackagePath
        showIcons: Bool
        maxDepth: Int64
        selectedIndex: Int64
        expandedPaths: List<PackagePath>
        currentNodes: List<TreeNavNode>
        scrollOffset: Int64 }

    // Tree navigation node
    type TreeNavNode =
      { path: PackagePath
        name: String
        nodeType: TreeNodeType
        isExpanded: Bool
        entityCount: EntityCount
        depth: Int64 }

    type TreeNodeType =
      | RootNode
      | ModuleNode
      | FunctionNode
      | TypeNode
      | ConstantNode

    type EntityCount =
      { functions: Int64
        types: Int64
        constants: Int64 }

    // Package path as list of components (e.g., ["Darklang"; "Stdlib"; "List"])
    type PackagePath = List<String>

    type AppState =
      { isExiting: Bool
        lastCommand: String
        output: String
        mainPrompt: String
        needsFullRedraw: Bool
        currentPath: PackagePath
        pathHistory: List<PackagePath>
        uiMode: InteractiveUIMode
        commandHistory: List<String>
        historyIndex: Int64 }

    let initState () : AppState =
      AppState
        { isExiting = false
          lastCommand = ""
          output = ""
          mainPrompt = ""
          needsFullRedraw = true
          currentPath = []
          pathHistory = []
          uiMode = InteractiveUIMode.PromptMode  // Default to prompt mode
          commandHistory = []
          historyIndex = -1L }

    // Helper to update core state fields while preserving package navigation fields
    let updateCoreFields (state: AppState) (isExiting: Bool) (lastCommand: String) (output: String) (mainPrompt: String) (needsFullRedraw: Bool) : AppState =
      { state with
          isExiting = isExiting
          lastCommand = lastCommand
          output = output
          mainPrompt = mainPrompt
          needsFullRedraw = needsFullRedraw }


    // ================================
    // EXECUTION ERROR - Error handling
    // ================================
    
    module ExecutionError =
      // TODO migrate this to some ParseAndExecuteScript submodule
      type ExecutionError =
        { msg: String; metadata: Dict<String> }

      let toString (err: ExecutionError) : String =
        let metadataStr =
          err.metadata
          |> Stdlib.Dict.toList
          |> Stdlib.List.map (fun (k, v) -> $"- {k}: {v}")
          |> Stdlib.String.join "\n"
        $"Error: {err.msg}\n{metadataStr}"


    // ================================
    // COMPLETION - Tab completion logic
    // ================================
    
    module Completion =
      // Types for structured input parsing
      type ParsedInput =
        { commandName: String
          args: List<String>
          isCompletingCommand: Bool }

      // Parse an input string into structured form
      let parseInput (input: String) : ParsedInput =
        let trimmed = Stdlib.String.trim input

        if Stdlib.String.isEmpty trimmed then
          ParsedInput { commandName = ""; args = []; isCompletingCommand = true }
        else
          let words = Stdlib.String.split trimmed " "
          match words with
          | [] -> ParsedInput { commandName = ""; args = []; isCompletingCommand = true }
          | [command] -> ParsedInput { commandName = command; args = []; isCompletingCommand = true }
          | command :: args -> ParsedInput { commandName = command; args = args; isCompletingCommand = false }

      // Get the partial string being completed
      let getPartialCompletion (parsed: ParsedInput) : String =
        if parsed.isCompletingCommand then
          parsed.commandName
        else
          match Stdlib.List.last parsed.args with
          | Some lastArg -> lastArg
          | None -> ""

      // Build completed command string from parsed input and completion
      let buildCompletedCommand (parsed: ParsedInput) (completion: String) : String =
        if parsed.isCompletingCommand then
          completion
        else
          // Replace last argument with completion
          let argsWithoutLast = Stdlib.List.dropLast parsed.args
          let newArgs = Stdlib.List.append argsWithoutLast [completion]
          let fullCommand = Stdlib.List.append [parsed.commandName] newArgs
          Stdlib.String.join fullCommand " "

      // Generate completion hint from partial and completions
      let getHintFromCompletions (partial: String) (completions: List<String>) : String =
        match completions with
        | [] -> ""
        | [singleCompletion] ->
          if Stdlib.String.startsWith singleCompletion partial then
            Stdlib.String.dropFirst singleCompletion (Stdlib.String.length partial)
          else
            ""
        | multiple ->
          let commonPrefix = findCommonPrefix multiple
          if Stdlib.String.startsWith commonPrefix partial && Stdlib.String.length commonPrefix > Stdlib.String.length partial then
            Stdlib.String.dropFirst commonPrefix (Stdlib.String.length partial)
          else
            ""

      let noArgsCompletion (_state: AppState) (_args: List<String>) : List<String> =
        []

      // Standard completion for commands that complete with other command names
      // (right now, just `help`)
      let commandNamesCompletion (_state: AppState) (args: List<String>) : List<String> =
        match args with
        | [] ->
          // Suggest all command names and aliases
          let commands = Registry.allCommands ()
          let commandNames = Stdlib.List.map commands (fun cmd -> cmd.name)
          let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
          Stdlib.List.append commandNames allAliases
        | [partialArg] ->
          // Filter by partial match
          let commands = Registry.allCommands ()
          let commandNames = Stdlib.List.map commands (fun cmd -> cmd.name)
          let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
          let allOptions = Stdlib.List.append commandNames allAliases
          Stdlib.List.filter allOptions (fun name -> Stdlib.String.startsWith name partialArg)
        | _ ->
          // Only complete first argument
          []

      // Helper functions for finding common prefixes in completions
      let findCommonLength (str1: String) (str2: String) (index: Int64) (maxLen: Int64) : Int64 =
        if index >= maxLen then
          index
        else
          let char1 = Stdlib.String.slice str1 index (index + 1L)
          let char2 = Stdlib.String.slice str2 index (index + 1L)
          if char1 == char2 then
            findCommonLength str1 str2 (index + 1L) maxLen
          else
            index

      let findCommonPrefix (strings: List<String>) : String =
        match strings with
        | [] -> ""
        | [single] -> single
        | first :: rest ->
          Stdlib.List.fold rest first (fun acc next ->
            let maxLen = Stdlib.Int64.min (Stdlib.String.length acc) (Stdlib.String.length next)
            let commonLen = findCommonLength acc next 0L maxLen
            Stdlib.String.slice acc 0L commonLen)

