module Darklang =
  module Cli =
    module Commands =
      let parseAndExecute (state: Types.AppState) (input: String) : Types.AppState =
        let trimmed = Stdlib.String.trim input
        let parts = Stdlib.String.split trimmed " "
        match parts with
        | [] -> state
        | commandName :: args ->
          Registry.executeCommand commandName state args

      // Clear command - clear the screen
      let executeClear (state: Types.AppState) (args: List<String>) : Types.AppState =
        Builtin.stdoutClear ()
        Types.AppState { 
          isExiting = state.isExiting; 
          lastCommand = "clear"; 
          output = "screen cleared"; 
          mainPrompt = state.mainPrompt; 
          needsFullRedraw = true;
          currentPath = state.currentPath; 
          pathHistory = state.pathHistory; 
          viewMode = state.viewMode;
          commandHistory = state.commandHistory;
          historyIndex = state.historyIndex
        }

      let clearHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: clear"
        Builtin.printLine "Clear the terminal screen."
        Builtin.printLine ""
        Builtin.printLine "Aliases: cls"
        Types.AppState { 
          isExiting = state.isExiting; 
          lastCommand = "help clear"; 
          output = "clear help displayed"; 
          mainPrompt = state.mainPrompt; 
          needsFullRedraw = state.needsFullRedraw; 
          currentPath = state.currentPath; 
          pathHistory = state.pathHistory; 
          viewMode = state.viewMode;
          commandHistory = state.commandHistory;
          historyIndex = state.historyIndex
        }

      let clearComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

