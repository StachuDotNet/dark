/// Navigate between packages, modules, and entities
module Darklang.Cli.Packages.Nav


let execute (state: AppState) (args: List<String>) : AppState =
  match args with
  | [] ->
    // TODO: interactive experience to navigate up/down the tree
    // until we reach something we want to 'stick' to
    Stdlib.printLine "TODO interactive experience..."

    state

  | [pathArg] ->
    // // Use pure function to compute navigation result
    // let (newLocation, locationStr) = Commands.computeNavigation state.currentLocation pathArg

    // // Check if navigation failed (same location + error message)
    // if newLocation == state.currentLocation && Stdlib.String.contains locationStr "not found" then
    //   // Navigation failed - show error and don't change location
    //   Stdlib.printLine (Colors.error locationStr)
    //   state
    // else
    //   // Navigation succeeded
    //   let newHistory = Stdlib.List.append state.locationHistory [state.currentLocation]
    //   Stdlib.printLine (Colors.success ("Changed to: " ++ locationStr))

    //   { state with
    //       needsFullRedraw = true
    //       currentLocation = newLocation
    //       locationHistory = newHistory }
    state
  | _ ->
    help state


let help (_state: AppState) : Unit =
  [
    "Usage: nav [path]"
    "Navigate package space - modules, types, fns, and values."
    ""
    "If you supply a [path] arg, we'll take you there immediately."
    "If you don't, you'll enter a keyboard-controlled navigation flow"
    ""
    "Examples:"
    "  nav /                - Go to root"
    "  nav /Darklang/Stdlib - Go to absolute path, from root"
    "  nav ..               - Go to parent"
    "  nav ../..            - Go to grandparent"
    "  nav Submodule        - Go to a submodule of where you are"
    "  nav Stdlib/List      - Go to Stdlib.List module"
    "  nav equals           - Go to equals function"
    "  nav Option           - Go to Option type"
    "  nav ../Stdlib/Option           - Go to Option type"
  ] |>  Stdlib.printLines


let complete (state: AppState) (args: List<String>) : List<String> =
  // match args with
  // | [] ->
  //   // At root, suggest top-level packages
  //   let currentPath = Packages.Path.locationToPath state.currentLocation
  //   if Stdlib.List.isEmpty currentPath then
  //     // Get top-level packages from the package manager
  //     let query = Utils.createSearchQuery []
  //     let searchResults = LanguageTools.PackageManager.Search.search query

  //     // Extract unique owners from module paths
  //     let owners =
  //       match Stdlib.List.head searchResults.submodules with
  //       | Some moduleList ->
  //         moduleList
  //         |> Stdlib.List.filterMap (fun path ->
  //           match path with
  //           | owner :: _ -> Stdlib.Option.Option.Some owner
  //           | [] -> Stdlib.Option.Option.None)
  //         |> Stdlib.List.unique
  //         |> Stdlib.List.sort
  //       | None -> []

  //     // Add basic navigation options
  //     Stdlib.List.append ["/"; ".."] owners
  //   else
  //     // Inside a module, suggest submodules AND entities (functions, types, constants)
  //     let query = Utils.createSearchQuery currentPath
  //     let searchResults = LanguageTools.PackageManager.Search.search query

  //     // Extract submodule names - only direct children
  //     let submodules =
  //       match Stdlib.List.head searchResults.submodules with
  //       | Some moduleList ->
  //         // Filter to only direct children by checking path length
  //         let expectedLength = (Stdlib.List.length currentPath) + 1L
  //         moduleList
  //         |> Stdlib.List.filter (fun path -> Stdlib.List.length path == expectedLength)
  //         // Get the last part of the path as the submodule name
  //         |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
  //         |> Stdlib.List.unique
  //         |> Stdlib.List.sort
  //       | None -> []

  //     // Extract entity names (functions, types, constants)
  //     let functionNames =
  //       searchResults.fns
  //       |> Stdlib.List.map (fun fn ->
  //         let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
  //         Utils.extractEntityShortName name)

  //     let typeNames =
  //       searchResults.types
  //       |> Stdlib.List.map (fun typ ->
  //         let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
  //         Utils.extractEntityShortName name)

  //     let constantNames =
  //       searchResults.constants
  //       |> Stdlib.List.map (fun constant ->
  //         let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
  //         Utils.extractEntityShortName name)

  //     // Combine all navigation options
  //     let allOptions =
  //       Stdlib.List.append ["/"; ".."]
  //         (Stdlib.List.append submodules
  //           (Stdlib.List.append functionNames
  //             (Stdlib.List.append typeNames constantNames)))

  //     allOptions |> Stdlib.List.unique |> Stdlib.List.sort

  // | [partialPath] ->
  //   // Handle dot-notation completion like "Darklang.St"
  //   if Stdlib.String.contains partialPath "." then
  //     // Parse the partial path to understand context
  //     let pathParts = Stdlib.String.split partialPath "."
  //     match Stdlib.List.reverse pathParts with
  //     | [] -> []
  //     | [lastPart] ->
  //       // Single part with dot, shouldn't happen but handle gracefully
  //       let allCompletions = complete state []
  //       let lowerPartial = Stdlib.String.toLowercase partialPath
  //       Stdlib.List.filter allCompletions (fun path ->
  //         Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
  //     | lastPartial :: reversedPrefixParts ->
  //       // Multi-part dot notation like "Darklang.St"
  //       let prefixParts = Stdlib.List.reverse reversedPrefixParts
  //       let lowerLastPartial = Stdlib.String.toLowercase lastPartial

  //       // Search in the specified module context
  //       let query = Utils.createSearchQuery prefixParts
  //       let searchResults = LanguageTools.PackageManager.Search.search query

  //       // Extract submodule names that match the partial
  //       match Stdlib.List.head searchResults.submodules with
  //       | Some moduleList ->
  //         let expectedLength = (Stdlib.List.length prefixParts) + 1L
  //         let suggestions =
  //           moduleList
  //           |> Stdlib.List.filter (fun path -> Stdlib.List.length path == expectedLength)
  //           |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
  //           |> Stdlib.List.filter (fun name ->
  //             Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerLastPartial)
  //           |> Stdlib.List.map (fun name ->
  //             let prefix = Stdlib.String.join prefixParts "."
  //             prefix ++ "." ++ name)
  //           |> Stdlib.List.sort
  //         suggestions
  //       | None -> []
  //   else
  //     // Regular prefix matching for simple paths
  //     let allCompletions = complete state []
  //     let lowerPartial = Stdlib.String.toLowercase partialPath
  //     Stdlib.List.filter allCompletions (fun path ->
  //       Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
  // | _ -> []
  ["TODO Nav.complete"]