module Darklang =
  module Cli =
    module Packages =
      module Tree =
        // Tree command - display package hierarchy
        
        // Interactive tree state types
        type TreeNode =
          { path: PackagePath
            name: String
            nodeType: NodeType
            isExpanded: Bool
            children: List<TreeNode>
            entityCount: EntityCount }
        
        type NodeType =
          | RootNode
          | PackageNode
          | ModuleNode
          | EntityNode of EntityType
        
        type EntityType =
          | FunctionEntity
          | TypeEntity
          | ConstantEntity
        
        type EntityCount =
          { functions: Int64
            types: Int64
            constants: Int64 }
        
        type InteractiveTreeState =
          { rootNode: TreeNode
            selectedIndex: Int64
            visibleNodes: List<TreeNode>
            showIcons: Bool
            maxDepth: Int64
            scrollOffset: Int64 }
        let executeTree (state: AppState) (args: List<String>) : AppState =
          let showIcons =
            match Stdlib.List.findFirst args (fun arg -> arg == "--icons") with
            | Some _ -> true
            | None -> false

          // Parse depth option
          let maxDepth =
            match Stdlib.List.findFirst args (fun arg -> Stdlib.String.startsWith arg "--depth=") with
            | Some depthArg ->
              let depthStr = Stdlib.String.dropFirst depthArg 8L // Remove "--depth="
              match Stdlib.Int64.parse depthStr with
              | Ok depth ->
                if depth > 0L && depth <= 10L then depth else 3L // Limit to reasonable range
              | Error _ -> 3L
            | None -> 3L // Default max depth to avoid overwhelming output

          // Determine starting path
          let startPath =
            match Stdlib.List.filter args (fun arg -> Stdlib.Bool.not (Stdlib.String.startsWith arg "--")) with
            | [] -> state.currentPath
            | [pathStr] -> Path.parsePath pathStr
            | _ -> state.currentPath

          if Stdlib.List.isEmpty startPath then
            Builtin.printLine "Package tree:"
            Builtin.printLine ""
            displayRootTree showIcons maxDepth
          else
            let pathStr = Path.formatPath startPath
            Builtin.printLine $"Package tree from {pathStr}:"
            Builtin.printLine ""
            displayModuleTree startPath showIcons maxDepth 0L ""

          { state with lastCommand = "tree"; output = "tree displayed" }
        
        // Interactive tree functions will be added later

        // Display tree from root
        let displayRootTree (showIcons: Bool) (maxDepth: Int64) : Unit =
          // Get top-level packages
          let query =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = []
                text = ""
                searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
          let searchResults = LanguageTools.PackageManager.Search.search query

          match Stdlib.List.head searchResults.submodules with
          | Some moduleList ->
            let owners =
              moduleList
              |> Stdlib.List.filterMap (fun path ->
                match path with
                | owner :: _ -> Stdlib.Option.Option.Some owner
                | [] -> Stdlib.Option.Option.None)
              |> Stdlib.List.unique
              |> Stdlib.List.sort

            let ownerCount = Stdlib.List.length owners
            let _ =
              Stdlib.List.fold owners 0L (fun index owner ->
                let isLast = index == (ownerCount - 1L)
                let prefix = if isLast then "â””â”€â”€ " else "â”œâ”€â”€ "
                let icon = if showIcons then "ðŸ“¦ " else ""
                Builtin.printLine $"{prefix}{icon}{owner}/"

                // Display children of this owner
                if maxDepth > 1L then
                  let childPrefix = if isLast then "    " else "â”‚   "
                  displayModuleTree [owner] showIcons (maxDepth - 1L) 1L childPrefix

                index + 1L
              )
            ()
          | None ->
            Builtin.printLine "  (no packages found)"

        // Display tree for a specific module
        let displayModuleTree (path: PackagePath) (showIcons: Bool) (remainingDepth: Int64) (currentDepth: Int64) (prefix: String) : Unit =
          if remainingDepth <= 0L then
            ()
          else
            let query =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = path
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module;
                                  LanguageTools.ProgramTypes.Search.EntityType.Fn;
                                  LanguageTools.ProgramTypes.Search.EntityType.Type;
                                  LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
            let searchResults = LanguageTools.PackageManager.Search.search query

            // Get direct child modules
            let childModules =
              match Stdlib.List.head searchResults.submodules with
              | Some moduleList ->
                let expectedLength = (Stdlib.List.length path) + 1L
                moduleList
                |> Stdlib.List.filter (fun modulePath -> Stdlib.List.length modulePath == expectedLength)
                |> Stdlib.List.filterMap (fun modulePath -> Stdlib.List.last modulePath)
                |> Stdlib.List.unique
                |> Stdlib.List.sort
              | None -> []

            // Count entities
            let fnCount = Stdlib.List.length searchResults.fns
            let typeCount = Stdlib.List.length searchResults.types
            let constCount = Stdlib.List.length searchResults.constants

            // Display child modules
            let childCount = Stdlib.List.length childModules
            let _ =
              Stdlib.List.fold childModules 0L (fun index child ->
                let isLast = index == (childCount - 1L)
                let nodePrefix = if isLast then "â””â”€â”€ " else "â”œâ”€â”€ "
                let icon = if showIcons then "ðŸ“¦ " else ""

                // Get entity counts for this specific child module
                let childPath = Stdlib.List.append path [child]
                let childQuery =
                  LanguageTools.ProgramTypes.Search.SearchQuery
                    { currentModule = childPath
                      text = ""
                      searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                      entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Fn;
                                      LanguageTools.ProgramTypes.Search.EntityType.Type;
                                      LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
                let childResults = LanguageTools.PackageManager.Search.search childQuery
                
                let childFnCount = Stdlib.List.length childResults.fns
                let childTypeCount = Stdlib.List.length childResults.types
                let childConstCount = Stdlib.List.length childResults.constants

                // Show module with entity counts
                let counts = []
                let counts = if childFnCount > 0L then Stdlib.List.append counts [$"{Stdlib.Int64.toString childFnCount} fns"] else counts
                let counts = if childTypeCount > 0L then Stdlib.List.append counts [$"{Stdlib.Int64.toString childTypeCount} types"] else counts
                let counts = if childConstCount > 0L then Stdlib.List.append counts [$"{Stdlib.Int64.toString childConstCount} consts"] else counts
                let countsStr =
                  if Stdlib.List.isEmpty counts then
                    ""
                  else
                    $" ({Stdlib.String.join counts ", "})"

                Builtin.printLine $"{prefix}{nodePrefix}{icon}{child}/{countsStr}"

                // Recursively display children
                if remainingDepth > 1L then
                  let childPrefix = if isLast then $"{prefix}    " else $"{prefix}â”‚   "
                  let childPath = Stdlib.List.append path [child]
                  displayModuleTree childPath showIcons (remainingDepth - 1L) (currentDepth + 1L) childPrefix

                index + 1L
              )
            ()

            // If this is a leaf module with entities, show summary
            if Stdlib.List.isEmpty childModules && currentDepth > 0L then
              let summaries = []
              let summaries =
                if fnCount > 0L then
                  let icon = if showIcons then "ðŸ”§ " else ""
                  Stdlib.List.append summaries [$"{prefix}    {icon}{Stdlib.Int64.toString fnCount} functions"]
                else summaries
              let summaries =
                if typeCount > 0L then
                  let icon = if showIcons then "ðŸ“‹ " else ""
                  Stdlib.List.append summaries [$"{prefix}    {icon}{Stdlib.Int64.toString typeCount} types"]
                else summaries
              let summaries =
                if constCount > 0L then
                  let icon = if showIcons then "ðŸ’Ž " else ""
                  Stdlib.List.append summaries [$"{prefix}    {icon}{Stdlib.Int64.toString constCount} constants"]
                else summaries

              summaries |> Stdlib.List.iter (fun line -> Builtin.printLine line)

        // Help function
        let treeHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: tree [path] [--icons] [--depth=N]"
          Builtin.printLine "Display package hierarchy in tree format."
          Builtin.printLine ""
          Builtin.printLine "Options:"
          Builtin.printLine "  --icons       Show icons for different entity types"
          Builtin.printLine "  --depth=N     Set maximum depth (1-10, default: 3)"
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  tree                         - Show tree from current location"
          Builtin.printLine "  tree /                       - Show tree from root"
          Builtin.printLine "  tree Darklang                - Show tree from Darklang package"
          Builtin.printLine "  tree --icons                 - Show tree with icons"
          Builtin.printLine "  tree Darklang.Stdlib --depth=2  - Show Stdlib tree with depth 2"
          Builtin.printLine "  tree Stdlib --icons --depth=1   - Show Stdlib with icons, depth 1"
          { state with lastCommand = "help tree"; output = "tree help displayed" }

        // Completion function
        let treeComplete (state: AppState) (args: List<String>) : List<String> =
          match args with
          | [] ->
            // Suggest common options and current context packages
            let options = ["--icons"; "--depth=1"; "--depth=2"; "--depth=3"; "/"]
            match state.currentPath with
            | Root ->
              // At root, suggest top-level packages
              let query =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = []
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
              let searchResults = LanguageTools.PackageManager.Search.search query
              match Stdlib.List.head searchResults.submodules with
              | Some moduleList ->
                let owners =
                  moduleList
                  |> Stdlib.List.filterMap (fun path ->
                    match path with
                    | owner :: _ -> Stdlib.Option.Option.Some owner
                    | [] -> Stdlib.Option.Option.None)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                Stdlib.List.append options owners
              | None -> options
            | Module _ _ -> options
          | [partial] ->
            // Complete package names or options
            if Stdlib.String.startsWith partial "--" then
              let allOptions = ["--icons"; "--depth=1"; "--depth=2"; "--depth=3"; "--depth=4"; "--depth=5"]
              allOptions |> Stdlib.List.filter (fun opt -> Stdlib.String.startsWith opt partial)
            else
              // Use cd completion logic for paths
              Navigation.cdComplete state [partial]
          | _ -> []