module Darklang =
  module Cli =
    module Packages =
      module Tree =
        // Tree command - display package hierarchy
        let executeTree (state: AppState) (args: List<String>) : AppState =
          // Icons are ON by default, use --no-icons to disable
          let showIcons =
            match Stdlib.List.findFirst args (fun arg -> arg == "--no-icons") with
            | Some _ -> false
            | None -> true

          let isInteractive =
            match Stdlib.List.findFirst args (fun arg -> arg == "--interactive" || arg == "-i") with
            | Some _ -> true
            | None -> false

          // Parse depth option (default is now 2 for better initial view)
          let maxDepth =
            match Stdlib.List.findFirst args (fun arg -> Stdlib.String.startsWith arg "--depth=") with
            | Some depthArg ->
              let depthStr = Stdlib.String.dropFirst depthArg 8L // Remove "--depth="
              match Stdlib.Int64.parse depthStr with
              | Ok depth ->
                if depth > 0L && depth <= 10L then depth else 2L // Limit to reasonable range
              | Error _ -> 2L
            | None -> 2L // Default depth of 2 for concise but useful view

          // Determine starting path
          let startPath =
            match Stdlib.List.filter args (fun arg -> Stdlib.Bool.not (Stdlib.String.startsWith arg "--")) with
            | [] -> state.currentPath
            | [pathStr] -> Path.parsePath pathStr
            | _ -> state.currentPath

          if isInteractive then
            // Start interactive tree mode
            startInteractiveTree state startPath showIcons maxDepth
          else
            // Static tree display
            if Stdlib.List.isEmpty startPath then
              Builtin.printLine "Package tree:"
              Builtin.printLine ""
              displayRootTree showIcons maxDepth
            else
              let pathStr = Path.formatPath startPath
              Builtin.printLine $"Package tree from {pathStr}:"
              Builtin.printLine ""
              displayModuleTree startPath showIcons maxDepth 0L ""

            { state with lastCommand = "tree"; output = "tree displayed" }
        
        // Interactive tree functions
        let startInteractiveTree (state: AppState) (startPath: PackagePath) (showIcons: Bool) (maxDepth: Int64) : AppState =
          // Build initial navigation nodes
          let initialNodes = buildTreeNavNodes startPath maxDepth showIcons 0L
          
          // Create tree navigation state
          let treeNavState =
            TreeNavState
              { startPath = startPath
                showIcons = showIcons
                maxDepth = maxDepth
                selectedIndex = 0L
                expandedPaths = []
                currentNodes = initialNodes
                scrollOffset = 0L }
          
          // Switch to tree navigation mode
          let newState =
            { state with 
                uiMode = InteractiveUIMode.TreeNavigationMode treeNavState
                lastCommand = "tree --interactive"
                output = "interactive tree mode started"
                needsFullRedraw = true }
          
          // Display initial tree
          redrawInteractiveTree newState treeNavState


        // Display tree from root
        let displayRootTree (showIcons: Bool) (maxDepth: Int64) : Unit =
          // Get top-level packages
          let query =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = []
                text = ""
                searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
          let searchResults = LanguageTools.PackageManager.Search.search query

          match Stdlib.List.head searchResults.submodules with
          | Some moduleList ->
            let owners =
              moduleList
              |> Stdlib.List.filterMap (fun path ->
                match path with
                | owner :: _ -> Stdlib.Option.Option.Some owner
                | [] -> Stdlib.Option.Option.None)
              |> Stdlib.List.unique
              |> Stdlib.List.sort

            let ownerCount = Stdlib.List.length owners
            let _ =
              Stdlib.List.fold owners 0L (fun index owner ->
                let isLast = index == (ownerCount - 1L)
                let prefix = if isLast then "‚îî‚îÄ‚îÄ " else "‚îú‚îÄ‚îÄ "
                let icon = if showIcons then "üì¶ " else ""
                Builtin.printLine $"{prefix}{icon}{owner}/"

                // Display children of this owner
                if maxDepth > 1L then
                  let childPrefix = if isLast then "    " else "‚îÇ   "
                  displayModuleTree [owner] showIcons (maxDepth - 1L) 1L childPrefix

                index + 1L
              )
            ()
          | None ->
            Builtin.printLine "  (no packages found)"

        // Display tree for a specific module
        let displayModuleTree (path: PackagePath) (showIcons: Bool) (remainingDepth: Int64) (currentDepth: Int64) (prefix: String) : Unit =
          if remainingDepth <= 0L then
            ()
          else
            let query =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = path
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module;
                                  LanguageTools.ProgramTypes.Search.EntityType.Fn;
                                  LanguageTools.ProgramTypes.Search.EntityType.Type;
                                  LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
            let searchResults = LanguageTools.PackageManager.Search.search query

            // Get direct child modules
            let childModules =
              match Stdlib.List.head searchResults.submodules with
              | Some moduleList ->
                let expectedLength = (Stdlib.List.length path) + 1L
                moduleList
                |> Stdlib.List.filter (fun modulePath -> Stdlib.List.length modulePath == expectedLength)
                |> Stdlib.List.filterMap (fun modulePath -> Stdlib.List.last modulePath)
                |> Stdlib.List.unique
                |> Stdlib.List.sort
              | None -> []

            // Count entities
            let fnCount = Stdlib.List.length searchResults.fns
            let typeCount = Stdlib.List.length searchResults.types
            let constCount = Stdlib.List.length searchResults.constants

            // Display child modules
            let childCount = Stdlib.List.length childModules
            let _ =
              Stdlib.List.fold childModules 0L (fun index child ->
                let isLast = index == (childCount - 1L)
                let nodePrefix = if isLast then "‚îî‚îÄ‚îÄ " else "‚îú‚îÄ‚îÄ "
                let icon = if showIcons then "üìÇ " else ""

                // Get entity counts for this specific child module
                let childPath = Stdlib.List.append path [child]
                let childQuery =
                  LanguageTools.ProgramTypes.Search.SearchQuery
                    { currentModule = childPath
                      text = ""
                      searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                      entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Fn;
                                      LanguageTools.ProgramTypes.Search.EntityType.Type;
                                      LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
                let childResults = LanguageTools.PackageManager.Search.search childQuery
                
                let childFnCount = Stdlib.List.length childResults.fns
                let childTypeCount = Stdlib.List.length childResults.types
                let childConstCount = Stdlib.List.length childResults.constants

                // Show module with entity counts
                let counts = []
                let counts = if childFnCount > 0L then Stdlib.List.append counts [$"{Stdlib.Int64.toString childFnCount} fns"] else counts
                let counts = if childTypeCount > 0L then Stdlib.List.append counts [$"{Stdlib.Int64.toString childTypeCount} types"] else counts
                let counts = if childConstCount > 0L then Stdlib.List.append counts [$"{Stdlib.Int64.toString childConstCount} consts"] else counts
                let countsStr =
                  if Stdlib.List.isEmpty counts then
                    ""
                  else
                    $" ({Stdlib.String.join counts ", "})"

                Builtin.printLine $"{prefix}{nodePrefix}{icon}{child}/{countsStr}"

                // Recursively display children
                if remainingDepth > 1L then
                  let childPrefix = if isLast then $"{prefix}    " else $"{prefix}‚îÇ   "
                  let childPath = Stdlib.List.append path [child]
                  displayModuleTree childPath showIcons (remainingDepth - 1L) (currentDepth + 1L) childPrefix

                index + 1L
              )
            ()

            // If this is a leaf module with entities, show summary
            if Stdlib.List.isEmpty childModules && currentDepth > 0L then
              let summaries = []
              let summaries =
                if fnCount > 0L then
                  let icon = if showIcons then "‚ö° " else ""
                  Stdlib.List.append summaries [$"{prefix}    {icon}{Stdlib.Int64.toString fnCount} functions"]
                else summaries
              let summaries =
                if typeCount > 0L then
                  let icon = if showIcons then "üè∑Ô∏è " else ""
                  Stdlib.List.append summaries [$"{prefix}    {icon}{Stdlib.Int64.toString typeCount} types"]
                else summaries
              let summaries =
                if constCount > 0L then
                  let icon = if showIcons then "üîí " else ""
                  Stdlib.List.append summaries [$"{prefix}    {icon}{Stdlib.Int64.toString constCount} constants"]
                else summaries

              summaries |> Stdlib.List.iter (fun line -> Builtin.printLine line)

        // Help function
        let treeHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: tree [path] [--no-icons] [--depth=N] [--interactive]"
          Builtin.printLine "Display package hierarchy in tree format."
          Builtin.printLine ""
          Builtin.printLine "Options:"
          Builtin.printLine "  --no-icons      Disable icons (icons shown by default)"
          Builtin.printLine "  --depth=N       Set maximum depth (1-10, default: 2)"
          Builtin.printLine "  --interactive   Enable interactive tree navigation (beta)"
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  tree                         - Show tree with icons, depth 2"
          Builtin.printLine "  tree /                       - Show tree from root"
          Builtin.printLine "  tree Darklang                - Show Darklang package tree"
          Builtin.printLine "  tree --no-icons              - Show tree without icons"
          Builtin.printLine "  tree --depth=1               - Show only direct children"
          Builtin.printLine "  tree --depth=5               - Show deeper tree structure"
          Builtin.printLine "  tree Darklang.Stdlib         - Show Stdlib tree"
          Builtin.printLine "  tree --interactive           - Interactive navigation (beta)"
          { state with lastCommand = "help tree"; output = "tree help displayed" }

        // Completion function
        let treeComplete (state: AppState) (args: List<String>) : List<String> =
          match args with
          | [] ->
            // Suggest common options and current context packages
            let options = ["--no-icons"; "--depth=1"; "--depth=3"; "--depth=4"; "--interactive"; "/"]
            if Stdlib.List.isEmpty state.currentPath then
              // At root, suggest top-level packages
              let query =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = []
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
              let searchResults = LanguageTools.PackageManager.Search.search query
              match Stdlib.List.head searchResults.submodules with
              | Some moduleList ->
                let owners =
                  moduleList
                  |> Stdlib.List.filterMap (fun path ->
                    match path with
                    | owner :: _ -> Stdlib.Option.Option.Some owner
                    | [] -> Stdlib.Option.Option.None)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                Stdlib.List.append options owners
              | None -> options
            else
              options
          | [partial] ->
            // Complete package names or options
            if Stdlib.String.startsWith partial "--" then
              let allOptions = ["--no-icons"; "--interactive"; "--depth=1"; "--depth=2"; "--depth=3"; "--depth=4"; "--depth=5"]
              allOptions |> Stdlib.List.filter (fun opt -> Stdlib.String.startsWith opt partial)
            else
              // Use cd completion logic for paths
              Navigation.cdComplete state [partial]
          | _ -> []

        // Interactive tree helper functions
        
        // Recursively build hierarchical tree nodes 
        let buildHierarchicalNodes (parentPath: PackagePath) (expandedPaths: List<PackagePath>) (currentDepth: Int64) (maxDepth: Int64) : List<TreeNavNode> =
          if currentDepth >= maxDepth then
            []
          else
            let query =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = parentPath
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module;
                                  LanguageTools.ProgramTypes.Search.EntityType.Fn;
                                  LanguageTools.ProgramTypes.Search.EntityType.Type;
                                  LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
            let searchResults = LanguageTools.PackageManager.Search.search query

            // Get direct child modules
            let childModules =
              match Stdlib.List.head searchResults.submodules with
              | Some moduleList ->
                let expectedLength = (Stdlib.List.length parentPath) + 1L
                moduleList
                |> Stdlib.List.filter (fun modulePath -> Stdlib.List.length modulePath == expectedLength)
                |> Stdlib.List.filterMap (fun modulePath -> Stdlib.List.last modulePath)
                |> Stdlib.List.unique
                |> Stdlib.List.sort
              | None -> []

            // Build nodes for child modules and their content
            let allNodes =
              childModules
              |> Stdlib.List.map (fun moduleName ->
                let childPath = Stdlib.List.append parentPath [moduleName]
                let childQuery =
                  LanguageTools.ProgramTypes.Search.SearchQuery
                    { currentModule = childPath
                      text = ""
                      searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                      entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Fn;
                                      LanguageTools.ProgramTypes.Search.EntityType.Type;
                                      LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
                let childResults = LanguageTools.PackageManager.Search.search childQuery
                
                let entityCount =
                  EntityCount
                    { functions = Stdlib.List.length childResults.fns
                      types = Stdlib.List.length childResults.types
                      constants = Stdlib.List.length childResults.constants }

                let isExpanded = Stdlib.List.``member`` expandedPaths childPath
                let moduleNode =
                  TreeNavNode
                    { path = childPath
                      name = moduleName
                      nodeType = TreeNodeType.ModuleNode
                      isExpanded = isExpanded
                      entityCount = entityCount
                      depth = currentDepth }

                // If expanded, add entity nodes and recurse into submodules
                if isExpanded then
                  let entityNodes = []
                  
                  // Add function nodes
                  let fnNodes =
                    childResults.fns
                    |> Stdlib.List.map (fun fn ->
                      TreeNavNode
                        { path = childPath
                          name = fn.name.name
                          nodeType = TreeNodeType.FunctionNode
                          isExpanded = false
                          entityCount = EntityCount { functions = 0L; types = 0L; constants = 0L }
                          depth = currentDepth + 1L })
                  
                  // Add type nodes
                  let typeNodes =
                    childResults.types
                    |> Stdlib.List.map (fun typ ->
                      TreeNavNode
                        { path = childPath
                          name = typ.name.name
                          nodeType = TreeNodeType.TypeNode
                          isExpanded = false
                          entityCount = EntityCount { functions = 0L; types = 0L; constants = 0L }
                          depth = currentDepth + 1L })
                  
                  // Add constant nodes
                  let constNodes =
                    childResults.constants
                    |> Stdlib.List.map (fun constDef ->
                      TreeNavNode
                        { path = childPath
                          name = constDef.name.name
                          nodeType = TreeNodeType.ConstantNode
                          isExpanded = false
                          entityCount = EntityCount { functions = 0L; types = 0L; constants = 0L }
                          depth = currentDepth + 1L })

                  // Recursively get submodule nodes
                  let subNodes = buildHierarchicalNodes childPath expandedPaths (currentDepth + 1L) maxDepth

                  // Return module node followed by its content
                  Stdlib.List.append [moduleNode] (Stdlib.List.append fnNodes (Stdlib.List.append typeNodes (Stdlib.List.append constNodes subNodes)))
                else
                  [moduleNode])
              |> Stdlib.List.flatten

            allNodes

        // Build tree navigation nodes with expansion support
        let buildTreeNavNodes (startPath: PackagePath) (maxDepth: Int64) (showIcons: Bool) (currentDepth: Int64) : List<TreeNavNode> =
          buildTreeNavNodesWithExpansion startPath maxDepth showIcons currentDepth []

        // Build tree navigation nodes with expansion tracking
        let buildTreeNavNodesWithExpansion (startPath: PackagePath) (maxDepth: Int64) (showIcons: Bool) (currentDepth: Int64) (expandedPaths: List<PackagePath>) : List<TreeNavNode> =
          if Stdlib.List.isEmpty startPath then
            // At root level, show top-level package owners (like Darklang, Stachu)
            let query =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = []
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
            let searchResults = LanguageTools.PackageManager.Search.search query

            match Stdlib.List.head searchResults.submodules with
            | Some moduleList ->
              let owners =
                moduleList
                |> Stdlib.List.filterMap (fun path ->
                  match path with
                  | owner :: _ -> Stdlib.Option.Option.Some owner
                  | [] -> Stdlib.Option.Option.None)
                |> Stdlib.List.unique
                |> Stdlib.List.sort

              // Build hierarchical structure for each owner
              owners
              |> Stdlib.List.map (fun ownerName ->
                let ownerPath = [ownerName]
                let isExpanded = Stdlib.List.``member`` expandedPaths ownerPath
                let ownerNode =
                  TreeNavNode
                    { path = ownerPath
                      name = ownerName
                      nodeType = TreeNodeType.ModuleNode
                      isExpanded = isExpanded
                      entityCount = EntityCount { functions = 0L; types = 0L; constants = 0L }
                      depth = 0L }

                // If expanded, get children hierarchically
                if isExpanded then
                  let children = buildHierarchicalNodes ownerPath expandedPaths 1L maxDepth
                  Stdlib.List.append [ownerNode] children
                else
                  [ownerNode])
              |> Stdlib.List.flatten
            | None -> []
          else
            buildHierarchicalNodes startPath expandedPaths currentDepth maxDepth

        // Display current tree navigation state with viewport scrolling
        let displayTreeNavigation (state: AppState) (treeState: TreeNavState) : Unit =
          // Calculate viewport dimensions
          let reservedLines = 4L  // Header lines + instructions
          let viewportHeight = Terminal.getViewportHeight reservedLines
          let totalNodes = Stdlib.List.length treeState.currentNodes
          
          // Calculate visible slice of nodes
          let startIndex = treeState.scrollOffset
          let endIndex = Stdlib.Int64.min (startIndex + viewportHeight) totalNodes
          let visibleNodes = 
            treeState.currentNodes
            |> Stdlib.List.drop startIndex
            |> Stdlib.List.take (endIndex - startIndex)
          
          let _ = 
            visibleNodes
            |> Stdlib.List.fold startIndex (fun globalIndex node ->
              let isSelected = globalIndex == treeState.selectedIndex
              let selectionPrefix = if isSelected then "> " else "  "
              
              // Create indentation based on depth
              let indentation = Stdlib.String.repeat "  " node.depth
              
              let icon = if treeState.showIcons then getNodeIcon node.nodeType else ""
              
              // Only show expand icon for modules that can have children
              let expandIcon = 
                match node.nodeType with
                | ModuleNode ->
                  if node.isExpanded then "‚ñº " else "‚ñ∂ "
                | _ -> ""
              
              let countsStr =
                if node.entityCount.functions + node.entityCount.types + node.entityCount.constants > 0L then
                  let counts = []
                  let counts = if node.entityCount.functions > 0L then Stdlib.List.append counts [Stdlib.Int64.toString node.entityCount.functions ++ " fns"] else counts
                  let counts = if node.entityCount.types > 0L then Stdlib.List.append counts [Stdlib.Int64.toString node.entityCount.types ++ " types"] else counts
                  let counts = if node.entityCount.constants > 0L then Stdlib.List.append counts [Stdlib.Int64.toString node.entityCount.constants ++ " consts"] else counts
                  " (" ++ (Stdlib.String.join counts ", ") ++ ")"
                else
                  ""
              
              Builtin.printLine (selectionPrefix ++ indentation ++ expandIcon ++ icon ++ node.name ++ countsStr)
              globalIndex + 1L)
          
          // Show scroll indicator if there are more items
          if totalNodes > viewportHeight then
            let scrollIndicator = "Showing " ++ Stdlib.Int64.toString (startIndex + 1L) ++ "-" ++ Stdlib.Int64.toString endIndex ++ " of " ++ Stdlib.Int64.toString totalNodes
            Builtin.printLine ""
            Builtin.printLine scrollIndicator
          
          ()

        // Redraw interactive tree (clears and redraws) - only for major changes
        let redrawInteractiveTree (state: AppState) (treeState: TreeNavState) : AppState =
          // Clear screen and redisplay - only used for major layout changes
          Builtin.printLine "\x1b[2J\x1b[H"  // ANSI clear screen and move cursor to top
          Builtin.printLine "Interactive Package Tree"
          Builtin.printLine "Navigation: ‚Üë/‚Üì to move, ‚Üê/‚Üí to collapse/expand, Enter to toggle/view, 'q' to quit"
          Builtin.printLine "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
          Builtin.printLine ""
          displayTreeNavigation state treeState
          state

        // Update tree selection without full redraw - for navigation
        let updateTreeSelection (state: AppState) (treeState: TreeNavState) : AppState =
          // Calculate viewport and display only visible portion
          let reservedLines = 4L  // Header lines + instructions
          let viewportHeight = Terminal.getViewportHeight reservedLines
          let totalNodes = Stdlib.List.length treeState.currentNodes
          
          // Calculate visible slice of nodes
          let startIndex = treeState.scrollOffset
          let endIndex = Stdlib.Int64.min (startIndex + viewportHeight) totalNodes
          let visibleNodes = 
            treeState.currentNodes
            |> Stdlib.List.drop startIndex
            |> Stdlib.List.take (endIndex - startIndex)
          
          // Move cursor to start of tree content (after header)
          Builtin.print "\x1b[5;1H"  // Move to row 5, column 1
          
          let _ = 
            visibleNodes
            |> Stdlib.List.fold startIndex (fun globalIndex node ->
              let isSelected = globalIndex == treeState.selectedIndex
              let selectionPrefix = if isSelected then "> " else "  "
              
              // Create indentation based on depth
              let indentation = Stdlib.String.repeat "  " node.depth
              
              // Get appropriate icon
              let icon = getNodeIcon node.nodeType
              
              // Get expansion icon for modules
              let expandIcon = 
                match node.nodeType with
                | ModuleNode ->
                  if Stdlib.List.``member`` treeState.expandedPaths node.path then
                    "‚ñº "
                  else
                    "‚ñ∂ "
                | _ -> ""
              
              // Add entity counts for modules
              let countsStr = 
                let counts = node.entityCount
                if counts.functions > 0L || counts.types > 0L || counts.constants > 0L then
                  let parts = []
                  let parts = if counts.functions > 0L then Stdlib.List.append parts [Stdlib.Int64.toString counts.functions ++ " fns"] else parts
                  let parts = if counts.types > 0L then Stdlib.List.append parts [Stdlib.Int64.toString counts.types ++ " types"] else parts
                  let parts = if counts.constants > 0L then Stdlib.List.append parts [Stdlib.Int64.toString counts.constants ++ " consts"] else parts
                  " (" ++ (Stdlib.String.join parts ", ") ++ ")"
                else
                  ""
              
              // Clear the line and print the updated content
              Builtin.print "\x1b[2K"  // Clear entire line
              Builtin.printLine (selectionPrefix ++ indentation ++ expandIcon ++ icon ++ node.name ++ countsStr)
              globalIndex + 1L)
          
          // Show scroll indicator if there are more items
          if totalNodes > viewportHeight then
            let scrollIndicator = "Showing " ++ Stdlib.Int64.toString (startIndex + 1L) ++ "-" ++ Stdlib.Int64.toString endIndex ++ " of " ++ Stdlib.Int64.toString totalNodes
            Builtin.print "\x1b[2K"  // Clear line
            Builtin.printLine ""
            Builtin.print "\x1b[2K"  // Clear line  
            Builtin.printLine scrollIndicator
          
          state

        // Rebuild and redraw tree (for expansions) - optimized
        let rebuildAndRedrawTree (state: AppState) (treeState: TreeNavState) : AppState =
          // Rebuild nodes with new expansion state
          let updatedNodes = buildTreeNavNodesWithExpansion treeState.startPath treeState.maxDepth treeState.showIcons 0L treeState.expandedPaths
          let newTreeState =
            { treeState with
                currentNodes = updatedNodes }
          let newState =
            { state with
                uiMode = InteractiveUIMode.TreeNavigationMode newTreeState }
          
          // Use full redraw for tree structure changes, but update selection for navigation
          redrawInteractiveTree newState newTreeState

        // Smart tree update - chooses between full redraw or selection update
        let smartTreeUpdate (state: AppState) (treeState: TreeNavState) (isStructuralChange: Bool) : AppState =
          if isStructuralChange then
            // Tree structure changed (expand/collapse) - need full redraw
            rebuildAndRedrawTree state treeState
          else
            // Only selection changed - use targeted update
            let newState =
              { state with
                  uiMode = InteractiveUIMode.TreeNavigationMode treeState }
            updateTreeSelection newState treeState

        // View entity from tree selection
        let viewEntityFromTree (state: AppState) (selectedNode: TreeNavNode) : AppState =
          // Exit tree mode and execute view command
          let newState =
            { state with
                uiMode = InteractiveUIMode.PromptMode }
          let entityPath = Path.formatPath selectedNode.path
          Builtin.printLine ""
          Builtin.printLine $"Viewing {selectedNode.name} at {entityPath}"
          
          // Execute view command for the selected entity
          Packages.Viewing.executeView newState [selectedNode.name]

        // Calculate scroll offset to ensure selected item is visible
        let calculateScrollOffset (selectedIndex: Int64) (currentScrollOffset: Int64) (totalNodes: Int64) : Int64 =
          let reservedLines = 4L  // Header lines + instructions
          let viewportHeight = Terminal.getViewportHeight reservedLines
          
          // If selected item is above current viewport, scroll up
          if selectedIndex < currentScrollOffset then
            selectedIndex
          // If selected item is below current viewport, scroll down  
          else if selectedIndex >= (currentScrollOffset + viewportHeight) then
            selectedIndex - viewportHeight + 1L
          // Selected item is within viewport, no scroll needed
          else
            currentScrollOffset
          |> Terminal.clampScrollOffset totalNodes viewportHeight

        // Get icon for tree node type
        let getNodeIcon (nodeType: TreeNodeType) : String =
          match nodeType with
          | RootNode -> "üè† "
          | ModuleNode -> "üìÇ "
          | FunctionNode -> "‚ö° "
          | TypeNode -> "üè∑Ô∏è "
          | ConstantNode -> "üîí "

