module Darklang =
  module Cli =
    module Packages =
      module Path =
        // Package path utilities
        let formatPath (path: Types.PackagePath) : String =
          if Stdlib.List.isEmpty path then
            "/"
          else
            $"/{Stdlib.String.join path "."}"

        let parsePath (pathStr: String) : Types.PackagePath =
          let trimmed = Stdlib.String.trim pathStr
          if trimmed == "/" || Stdlib.String.isEmpty trimmed then
            []
          else
            let pathToSplit =
              if Stdlib.String.startsWith trimmed "/" then
                Stdlib.String.dropFirst trimmed 1L
              else
                trimmed
            // Only handle dotted paths - dots are the standard separator for package paths
            Stdlib.String.split pathToSplit "."

        // Helper to construct module prefix for search queries
        let constructModulePrefix (owner: String) (submodules: List<String>) : String =
          if Stdlib.List.isEmpty submodules then
            owner
          else
            let modulesList = Stdlib.String.join submodules "."
            $"{owner}.{modulesList}"

        // Convert PackageLocation to display string with icons
        let formatLocation (location: Types.PackageLocation) : String =
          match location with
          | Root -> "/"
          | Module path ->
            if Stdlib.List.isEmpty path then
              "/ 📁"
            else
              $"/{Stdlib.String.join path "."} 📁"
          | Type (name, path) ->
            let pathStr = if Stdlib.List.isEmpty path then "/" else $"/{Stdlib.String.join path "."}"
            $"{pathStr}/{name} 🏷️"
          | Function (name, path) ->
            let pathStr = if Stdlib.List.isEmpty path then "/" else $"/{Stdlib.String.join path "."}"
            $"{pathStr}/{name} ⚡"
          | Constant (name, path) ->
            let pathStr = if Stdlib.List.isEmpty path then "/" else $"/{Stdlib.String.join path "."}"
            $"{pathStr}/{name} 🔒"

        // Convert PackageLocation to underlying path
        let locationToPath (location: Types.PackageLocation) : Types.PackagePath =
          match location with
          | Root -> []
          | Module path -> path
          | Type (_, path) -> path
          | Function (_, path) -> path
          | Constant (_, path) -> path

        // Convert PackagePath to Module location
        let pathToLocation (path: Types.PackagePath) : Types.PackageLocation =
          if Stdlib.List.isEmpty path then
            Types.PackageLocation.Root
          else
            Types.PackageLocation.Module path

        // Create search query from path components
        let createSearchQuery (parts: List<String>) (remainder: String) : LanguageTools.ProgramTypes.Search.SearchQuery =
          match parts with
          | [] ->
            LanguageTools.ProgramTypes.Search.SearchQuery
              { owner = ""; modules = []; name = remainder }
          | [owner] when Stdlib.String.isEmpty remainder ->
            LanguageTools.ProgramTypes.Search.SearchQuery
              { owner = owner; modules = []; name = "" }
          | owner :: modules ->
            LanguageTools.ProgramTypes.Search.SearchQuery
              { owner = owner; modules = modules; name = remainder }