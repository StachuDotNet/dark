module Darklang =
  module Cli =
    module Packages =
      module Path =
        // Package path utilities
        let formatPath (path: PackagePath) : String =
          match path with
          | Root -> "/"
          | Module owner moduleName ->
            if Stdlib.String.isEmpty moduleName then
              $"/{owner}"
            else
              $"/{owner}.{moduleName}"

        let parsePath (pathStr: String) : PackagePath =
          let trimmed = Stdlib.String.trim pathStr
          if trimmed == "/" || Stdlib.String.isEmpty trimmed then
            PackagePath.Root
          else
            let pathToSplit =
              if Stdlib.String.startsWith trimmed "/" then
                Stdlib.String.dropFirst trimmed 1L
              else
                trimmed
            let parts =
              if Stdlib.String.contains pathToSplit "." then
                // Handle dotted paths like "Darklang.Stdlib"
                Stdlib.String.split pathToSplit "."
              else
                // Handle slash paths like "Darklang/Stdlib"
                Stdlib.String.split pathToSplit "/"
            match parts with
            | [owner; moduleName] -> PackagePath.Module owner moduleName
            | [owner] -> PackagePath.Module owner ""
            | _ -> PackagePath.Root

        // Helper to construct module prefix for search queries
        let constructModulePrefix (owner: String) (submodules: List<String>) : String =
          if Stdlib.List.isEmpty submodules then
            owner
          else
            let modulesList = Stdlib.String.join submodules "."
            $"{owner}.{modulesList}"

        // Create search query from path components
        let createSearchQuery (parts: List<String>) (remainder: String) : LanguageTools.ProgramTypes.Search.SearchQuery =
          match parts with
          | [] ->
            LanguageTools.ProgramTypes.Search.SearchQuery
              { owner = ""; modules = []; name = remainder }
          | [owner] when Stdlib.String.isEmpty remainder ->
            LanguageTools.ProgramTypes.Search.SearchQuery
              { owner = owner; modules = []; name = "" }
          | owner :: modules ->
            LanguageTools.ProgramTypes.Search.SearchQuery
              { owner = owner; modules = modules; name = remainder }