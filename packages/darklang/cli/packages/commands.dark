module Darklang =
  module Cli =
    module Packages =
      module Commands =
        // Pure command functions that don't touch AppState directly
        // These extract the core business logic from execute functions
        
        // Pure navigation function that returns navigation decision
        let computeNavigation (currentLocation: Types.PackageLocation) (pathArg: String) : (Types.PackageLocation * String) =
          let currentPath = Path.locationToPath currentLocation
          Navigation.resolveNavigationTarget currentPath pathArg
        
        // Pure back navigation that computes the target location
        let computeBackNavigation (locationHistory: List<Types.PackageLocation>) : Stdlib.Option.Option<Types.PackageLocation> =
          Stdlib.List.last locationHistory
        
        // Pure pwd function that formats current location
        let computePwdOutput (currentLocation: Types.PackageLocation) : String =
          Path.formatLocation currentLocation
        
        // Pure listing function that formats module contents
        let computeListingOutput (location: Types.PackageLocation) : String =
          match location with
          | Root ->
            let query = Utils.createSearchQuery []
            let searchResults = LanguageTools.PackageManager.Search.search query
            formatRootListing searchResults
          | Module path ->
            let query = Utils.createSearchQuery path
            let searchResults = LanguageTools.PackageManager.Search.search query
            formatModuleListing path searchResults
          | Function (name, path) ->
            formatEntityListing "Function" name path
          | Type (name, path) ->
            formatEntityListing "Type" name path  
          | Constant (name, path) ->
            formatEntityListing "Constant" name path
        
        // Helper functions for formatting output (pure string functions)
        let formatRootListing (searchResults: LanguageTools.ProgramTypes.Search.SearchResults) : String =
          let owners =
            if Stdlib.List.isEmpty searchResults.submodules then
              []
            else
              searchResults.submodules
              |> Stdlib.List.filterMap (fun path ->
                match path with
                | owner :: _ -> Stdlib.Option.Option.Some owner
                | [] -> Stdlib.Option.Option.None)
              |> Stdlib.List.unique
              |> Stdlib.List.sort
          
          if Stdlib.List.isEmpty owners then
            "No packages found."
          else
            let ownerLines = 
              owners
              |> Stdlib.List.map (fun owner -> $"📁 {owner}/")
              |> Stdlib.String.join "\n"
            $"Root packages:\n{ownerLines}"
        
        let formatModuleListing (path: Types.PackagePath) (searchResults: LanguageTools.ProgramTypes.Search.SearchResults) : String =
          let lines = []
          
          // Add submodules - extract direct children only
          let lines = 
            if Stdlib.List.isEmpty searchResults.submodules then
              lines
            else
              // searchResults.submodules is List<List<List<String>>>, get the first (and only) list
              let allModulePaths = 
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList -> moduleList
                | None -> []
              
              // Filter to only direct children (path length = current path length + 1)
              let expectedLength = (Stdlib.List.length path) + 1L
              let directChildren = 
                allModulePaths
                |> Stdlib.List.filter (fun modulePath -> Stdlib.List.length modulePath == expectedLength)
                |> Stdlib.List.filterMap (fun modulePath -> Stdlib.List.last modulePath)
                |> Stdlib.List.unique
                |> Stdlib.List.sort
              
              if Stdlib.List.isEmpty directChildren then
                lines
              else
                let submoduleLines = 
                  directChildren
                  |> Stdlib.List.map (fun name -> "📁 " ++ name ++ "/")
                  |> Stdlib.String.join "\n"
                Stdlib.List.append lines ["Submodules:\n" ++ submoduleLines]
          
          // Add functions  
          let lines =
            if Stdlib.List.isEmpty searchResults.fns then
              lines
            else
              let fnLines =
                searchResults.fns
                |> Stdlib.List.map (fun fn ->
                  let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                  let shortName = Utils.extractEntityShortName name
                  "⚡ " ++ shortName)
                |> Stdlib.String.join "\n"
              Stdlib.List.append lines ["Functions:\n" ++ fnLines]
          
          // Add types
          let lines =
            if Stdlib.List.isEmpty searchResults.types then
              lines
            else
              let typeLines =
                searchResults.types
                |> Stdlib.List.map (fun typ ->
                  let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                  let shortName = Utils.extractEntityShortName name
                  "🏷️ " ++ shortName)
                |> Stdlib.String.join "\n"
              Stdlib.List.append lines ["Types:\n" ++ typeLines]
          
          // Add constants
          let lines =
            if Stdlib.List.isEmpty searchResults.constants then
              lines
            else
              let constLines =
                searchResults.constants
                |> Stdlib.List.map (fun constant ->
                  let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                  let shortName = Utils.extractEntityShortName name
                  "🔒 " ++ shortName)
                |> Stdlib.String.join "\n"
              Stdlib.List.append lines ["Constants:\n" ++ constLines]
          
          if Stdlib.List.isEmpty lines then
            let pathStr = Path.formatPath path
            "Module " ++ pathStr ++ " is empty."
          else
            Stdlib.String.join lines "\n\n"
        
        let formatEntityListing (entityType: String) (entityName: String) (modulePath: Types.PackagePath) : String =
          // Search for the specific entity to get its details
          let searchQuery = Utils.createSearchQuery modulePath
          let searchResults = LanguageTools.PackageManager.Search.search searchQuery
          
          match entityType with
          | "Function" ->
            let foundFunction =
              searchResults.fns
              |> Stdlib.List.findFirst (fun fn ->
                let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                let shortName = Utils.extractEntityShortName name
                shortName == entityName)
            
            match foundFunction with
            | Some fn ->
              let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageFn fn
              let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
              $"Function: {entityName}\n\n{highlighted}"
            | None ->
              $"Function '{entityName}' not found."
              
          | "Type" ->
            let foundType =
              searchResults.types
              |> Stdlib.List.findFirst (fun typ ->
                let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                let shortName = Utils.extractEntityShortName name
                shortName == entityName)
            
            match foundType with
            | Some typ ->
              let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageType typ
              let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
              $"Type: {entityName}\n\n{highlighted}"
            | None ->
              $"Type '{entityName}' not found."
              
          | "Constant" ->
            let foundConstant =
              searchResults.constants
              |> Stdlib.List.findFirst (fun constant ->
                let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                let shortName = Utils.extractEntityShortName name
                shortName == entityName)
            
            match foundConstant with
            | Some constant ->
              let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageConstant constant
              let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
              $"Constant: {entityName}\n\n{highlighted}"
            | None ->
              $"Constant '{entityName}' not found."
              
          | _ ->
            $"Unknown entity type: {entityType}"