module Darklang =
  module Cli =
    module Packages =
      module Navigation =
        // CD command - change directory/module
        let executeCD (state: AppState) (args: List<String>) : AppState =
          match args with
          | [] ->
            // No args, show current path
            let currentPathStr = Packages.Path.formatPath state.currentPath
            Builtin.printLine $"Current path: {currentPathStr}"
            { state with lastCommand = "cd"; output = "pwd displayed" }
          | [pathArg] ->
            let newPath =
              // Handle special navigation patterns
              if pathArg == ".." then
                // Go back to parent
                if Stdlib.List.isEmpty state.currentPath then
                  []
                else
                  Stdlib.List.dropLast state.currentPath
              else if pathArg == "../.." then
                // Go back two levels
                if Stdlib.List.length state.currentPath <= 1L then
                  []
                else
                  Stdlib.List.dropLast (Stdlib.List.dropLast state.currentPath)
              else if pathArg == "/" then
                []
              else if Stdlib.String.startsWith pathArg "/" then
                // Absolute path
                Packages.Path.parsePath pathArg
              else if Stdlib.String.startsWith pathArg "../" then
                // Relative path starting with ../
                // Go up one level first, then navigate
                let afterDotDot = Stdlib.String.dropFirst pathArg 3L
                let parentPath = if Stdlib.List.isEmpty state.currentPath then [] else Stdlib.List.dropLast state.currentPath
                if Stdlib.String.isEmpty afterDotDot then
                  parentPath
                else
                  let relativePath = Packages.Path.parsePath afterDotDot
                  Stdlib.List.append parentPath relativePath
              else
                // Regular relative path - append to current path
                let relativePath = Packages.Path.parsePath pathArg
                Stdlib.List.append state.currentPath relativePath

            let newHistory = Stdlib.List.append state.pathHistory [state.currentPath]
            let newPathStr = Packages.Path.formatPath newPath
            Builtin.printLine (Colors.success $"Changed to: {newPathStr}")

            { state with
                lastCommand = "cd"
                output = $"cd to {newPathStr}"
                needsFullRedraw = true
                currentPath = newPath
                pathHistory = newHistory }
          | _ ->
            Builtin.printLine "Usage: cd [path]"
            Builtin.printLine "  cd /           - Go to root"
            Builtin.printLine "  cd ..          - Go to parent"
            Builtin.printLine "  cd owner/module - Go to module"
            { state with lastCommand = "cd"; output = "cd help displayed" }

        // PWD command - show current path
        let executePWD (state: AppState) (args: List<String>) : AppState =
          let currentPathStr = Packages.Path.formatPath state.currentPath
          Builtin.printLine currentPathStr
          { state with lastCommand = "pwd"; output = "pwd displayed" }

        // BACK command - navigate back using history
        let executeBACK (state: AppState) (args: List<String>) : AppState =
          match Stdlib.List.last state.pathHistory with
          | Some previousPath ->
            let newHistory = Stdlib.List.dropLast state.pathHistory
            let pathStr = Packages.Path.formatPath previousPath
            Builtin.printLine (Colors.success $"Back to: {pathStr}")

            { state with
                lastCommand = "back"
                output = $"back to {pathStr}"
                needsFullRedraw = true
                currentPath = previousPath
                pathHistory = newHistory }
          | None ->
            Builtin.printLine "No previous location in history"
            { state with lastCommand = "back"; output = "no history" }

        // Help functions
        let cdHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: cd [path]"
          Builtin.printLine "Navigate between packages and modules."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  cd /                - Go to root"
          Builtin.printLine "  cd ..               - Go to parent"
          Builtin.printLine "  cd Stdlib           - Go to Stdlib owner"
          Builtin.printLine "  cd Stdlib/List      - Go to Stdlib.List module"
          Builtin.printLine "  cd /Darklang/Stdlib - Absolute path"
          { state with lastCommand = "help cd"; output = "cd help displayed" }

        let pwdHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: pwd"
          Builtin.printLine "Show the current package path."
          { state with lastCommand = "help pwd"; output = "pwd help displayed" }

        let backHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: back"
          Builtin.printLine "Navigate back to the previous location in history."
          { state with lastCommand = "help back"; output = "back help displayed" }

        // Completion functions
        let cdComplete (state: AppState) (args: List<String>) : List<String> =
          match args with
          | [] ->
            // At root, suggest top-level packages
            if Stdlib.List.isEmpty state.currentPath then
              // Get top-level packages from the package manager
              let query =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = []
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Extract unique owners from module paths
              let owners =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  moduleList
                  |> Stdlib.List.filterMap (fun path ->
                    match path with
                    | owner :: _ -> Stdlib.Option.Option.Some owner
                    | [] -> Stdlib.Option.Option.None)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Add basic navigation options
              Stdlib.List.append ["/"; ".."] owners
            else
              // Inside a module, suggest submodules
              let query =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = state.currentPath
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Extract submodule names - only direct children
              let submodules =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  // Filter to only direct children by checking path length
                  let expectedLength = (Stdlib.List.length state.currentPath) + 1L
                  moduleList
                  |> Stdlib.List.filter (fun path ->
                    Stdlib.List.length path == expectedLength)
                  |> Stdlib.List.filterMap (fun path ->
                    // Get the last part of the path as the submodule name
                    Stdlib.List.last path)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Add basic navigation options
              Stdlib.List.append ["/"; ".."] submodules

          | [partialPath] ->
            // Handle dot-notation completion like "Darklang.St"
            if Stdlib.String.contains partialPath "." then
              // Parse the partial path to understand context
              let pathParts = Stdlib.String.split partialPath "."
              match Stdlib.List.reverse pathParts with
              | [] -> []
              | [lastPart] ->
                // Single part with dot, shouldn't happen but handle gracefully
                let allCompletions = cdComplete state []
                let lowerPartial = Stdlib.String.toLowercase partialPath
                Stdlib.List.filter allCompletions (fun path ->
                  Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
              | lastPartial :: reversedPrefixParts ->
                // Multi-part dot notation like "Darklang.St"
                let prefixParts = Stdlib.List.reverse reversedPrefixParts
                let lowerLastPartial = Stdlib.String.toLowercase lastPartial

                // Search in the specified module context
                let query =
                  LanguageTools.ProgramTypes.Search.SearchQuery
                    { currentModule = prefixParts
                      text = ""
                      searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                      entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
                let searchResults = LanguageTools.PackageManager.Search.search query

                // Extract submodule names that match the partial
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  let expectedLength = (Stdlib.List.length prefixParts) + 1L
                  let suggestions =
                    moduleList
                    |> Stdlib.List.filter (fun path -> Stdlib.List.length path == expectedLength)
                    |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
                    |> Stdlib.List.filter (fun name ->
                      Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerLastPartial)
                    |> Stdlib.List.map (fun name ->
                      let prefix = Stdlib.String.join prefixParts "."
                      $"{prefix}.{name}")
                    |> Stdlib.List.sort
                  suggestions
                | None -> []
            else
              // Regular prefix matching for simple paths
              let allCompletions = cdComplete state []
              let lowerPartial = Stdlib.String.toLowercase partialPath
              Stdlib.List.filter allCompletions (fun path ->
                Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
          | _ -> []

        let pwdComplete (state: AppState) (args: List<String>) : List<String> = []

        let backComplete (state: AppState) (args: List<String>) : List<String> = []