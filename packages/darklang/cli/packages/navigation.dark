module Darklang =
  module Cli =
    module Packages =
      module Navigation =
        // Helper function to intelligently resolve navigation targets
        let resolveNavigationTarget (currentPath: Types.PackagePath) (target: String) : (Types.PackageLocation * String) =
          // Handle special navigation cases first
          if target == "/" then
            (Root, "/")
          else if target == ".." then
            // Go up one level
            match currentPath with
            | [] -> (Root, "/")
            | _ ->
              let parentPath = Stdlib.List.dropLast currentPath
              let parentLocation = Packages.Path.pathToLocation parentPath
              let parentStr = Packages.Path.formatLocation parentLocation
              (parentLocation, parentStr)
          else if Stdlib.String.contains target "." then
            // Multi-part path - treat as module for now
            let newPath = Utils.resolvePath currentPath target
            let newLocation = Packages.Path.pathToLocation newPath
            let locationStr = Packages.Path.formatLocation newLocation
            (newLocation, locationStr)
          else
            // Single name - check if it's an entity in current context
            let searchQuery = Utils.createFullSearchQuery currentPath
            let searchResults = LanguageTools.PackageManager.Search.search searchQuery
            
            // Check if it's a function
            let foundFunction =
              searchResults.fns
              |> Stdlib.List.findFirst (fun fn ->
                let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                let shortName = Utils.extractEntityShortName name
                shortName == target)
            
            match foundFunction with
            | Some fn ->
              let fnLocation = Function target currentPath
              let locationStr = Packages.Path.formatLocation fnLocation
              (fnLocation, locationStr)
            | None ->
              // Check if it's a type
              let foundType =
                searchResults.types
                |> Stdlib.List.findFirst (fun typ ->
                  let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                  let shortName = Utils.extractEntityShortName name
                  shortName == target)
              
              match foundType with
              | Some typ ->
                let typeLocation = Type target currentPath
                let locationStr = Packages.Path.formatLocation typeLocation
                (typeLocation, locationStr)
              | None ->
                // Check if it's a constant
                let foundConstant =
                  searchResults.constants
                  |> Stdlib.List.findFirst (fun constant ->
                    let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                    let shortName = Utils.extractEntityShortName name
                    shortName == target)
                
                match foundConstant with
                | Some constant ->
                  let constLocation = Constant target currentPath
                  let locationStr = Packages.Path.formatLocation constLocation
                  (constLocation, locationStr)
                | None ->
                  // Fallback - try as module path
                  let newPath = Utils.resolvePath currentPath target
                  let newLocation = Packages.Path.pathToLocation newPath
                  let locationStr = Packages.Path.formatLocation newLocation
                  (newLocation, locationStr)

        // NAV command - navigate between packages, modules, and entities  
        let executeNAV (state: AppState) (args: List<String>) : AppState =
          match args with
          | [] ->
            // No args, show current path
            let currentPathStr = Packages.Path.formatLocation state.currentLocation
            Builtin.printLine $"Current path: {currentPathStr}"
            { state with lastCommand = "nav"; output = "pwd displayed" }
          | [pathArg] ->
            let currentPath = Packages.Path.locationToPath state.currentLocation
            
            // Try to intelligently determine what the user wants to navigate to
            let (newLocation, locationStr) = resolveNavigationTarget currentPath pathArg
            
            let newHistory = Stdlib.List.append state.locationHistory [state.currentLocation]
            Builtin.printLine (Colors.success $"Changed to: {locationStr}")

            { state with
                lastCommand = "nav"
                output = $"nav to {locationStr}"
                needsFullRedraw = true
                currentLocation = newLocation
                locationHistory = newHistory }
          | _ ->
            Builtin.printLine "Usage: nav [path]"
            Builtin.printLine "  nav /             - Go to root"
            Builtin.printLine "  nav ..            - Go to parent"
            Builtin.printLine "  nav owner/module  - Go to module"
            Builtin.printLine "  nav functionName  - Go to function"
            Builtin.printLine "  nav TypeName      - Go to type"
            Builtin.printLine "  nav constantName  - Go to constant"
            { state with lastCommand = "nav"; output = "nav help displayed" }
            
        // CD command - alias for NAV
        let executeCD (state: AppState) (args: List<String>) : AppState =
          executeNAV state args

        // PWD command - show current path
        let executePWD (state: AppState) (args: List<String>) : AppState =
          let currentPathStr = Packages.Path.formatLocation state.currentLocation
          Builtin.printLine currentPathStr
          { state with lastCommand = "pwd"; output = "pwd displayed" }

        // BACK command - navigate back using history
        let executeBACK (state: AppState) (args: List<String>) : AppState =
          match Stdlib.List.last state.locationHistory with
          | Some previousLocation ->
            let newHistory = Stdlib.List.dropLast state.locationHistory
            let pathStr = Packages.Path.formatLocation previousLocation
            Builtin.printLine (Colors.success $"Back to: {pathStr}")

            { state with
                lastCommand = "back"
                output = $"back to {pathStr}"
                needsFullRedraw = true
                currentLocation = previousLocation
                locationHistory = newHistory }
          | None ->
            Builtin.printLine "No previous location in history"
            { state with lastCommand = "back"; output = "no history" }

        // Help functions
        let navHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: nav [path]"
          Builtin.printLine "Navigate between packages, modules, and entities."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  nav /                - Go to root"
          Builtin.printLine "  nav ..               - Go to parent"
          Builtin.printLine "  nav Stdlib           - Go to Stdlib owner"
          Builtin.printLine "  nav Stdlib/List      - Go to Stdlib.List module"
          Builtin.printLine "  nav /Darklang/Stdlib - Absolute path"
          Builtin.printLine "  nav equals           - Go to equals function"
          Builtin.printLine "  nav Option           - Go to Option type"
          { state with lastCommand = "help nav"; output = "nav help displayed" }
          
        let cdHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: cd [path] (alias for nav)"
          Builtin.printLine "Navigate between packages, modules, and entities."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  cd /                - Go to root"
          Builtin.printLine "  cd ..               - Go to parent"
          Builtin.printLine "  cd Stdlib           - Go to Stdlib owner"
          Builtin.printLine "  cd Stdlib/List      - Go to Stdlib.List module"
          Builtin.printLine "  cd /Darklang/Stdlib - Absolute path"
          Builtin.printLine "  cd equals           - Go to equals function"
          Builtin.printLine "  cd Option           - Go to Option type"
          { state with lastCommand = "help cd"; output = "cd help displayed" }

        let pwdHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: pwd"
          Builtin.printLine "Show the current package path."
          { state with lastCommand = "help pwd"; output = "pwd help displayed" }

        let backHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: back"
          Builtin.printLine "Navigate back to the previous location in history."
          { state with lastCommand = "help back"; output = "back help displayed" }

        // Completion functions
        let navComplete (state: AppState) (args: List<String>) : List<String> =
          match args with
          | [] ->
            // At root, suggest top-level packages
            let currentPath = Packages.Path.locationToPath state.currentLocation
            if Stdlib.List.isEmpty currentPath then
              // Get top-level packages from the package manager
              let query =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = []
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Extract unique owners from module paths
              let owners =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  moduleList
                  |> Stdlib.List.filterMap (fun path ->
                    match path with
                    | owner :: _ -> Stdlib.Option.Option.Some owner
                    | [] -> Stdlib.Option.Option.None)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Add basic navigation options
              Stdlib.List.append ["/"; ".."] owners
            else
              // Inside a module, suggest submodules AND entities (functions, types, constants)
              let query = Utils.createFullSearchQuery currentPath
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Extract submodule names - only direct children
              let submodules =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  // Filter to only direct children by checking path length
                  let expectedLength = (Stdlib.List.length currentPath) + 1L
                  moduleList
                  |> Stdlib.List.filter (fun path ->
                    Stdlib.List.length path == expectedLength)
                  |> Stdlib.List.filterMap (fun path ->
                    // Get the last part of the path as the submodule name
                    Stdlib.List.last path)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Extract entity names (functions, types, constants)
              let functionNames =
                searchResults.fns
                |> Stdlib.List.map (fun fn ->
                  let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                  Utils.extractEntityShortName name)

              let typeNames =
                searchResults.types
                |> Stdlib.List.map (fun typ ->
                  let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                  Utils.extractEntityShortName name)

              let constantNames =
                searchResults.constants
                |> Stdlib.List.map (fun constant ->
                  let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                  Utils.extractEntityShortName name)

              // Combine all navigation options
              let allOptions = 
                Stdlib.List.append ["/"; ".."] 
                  (Stdlib.List.append submodules 
                    (Stdlib.List.append functionNames 
                      (Stdlib.List.append typeNames constantNames)))
              
              allOptions |> Stdlib.List.unique |> Stdlib.List.sort

          | [partialPath] ->
            // Handle dot-notation completion like "Darklang.St"
            if Stdlib.String.contains partialPath "." then
              // Parse the partial path to understand context
              let pathParts = Stdlib.String.split partialPath "."
              match Stdlib.List.reverse pathParts with
              | [] -> []
              | [lastPart] ->
                // Single part with dot, shouldn't happen but handle gracefully
                let allCompletions = cdComplete state []
                let lowerPartial = Stdlib.String.toLowercase partialPath
                Stdlib.List.filter allCompletions (fun path ->
                  Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
              | lastPartial :: reversedPrefixParts ->
                // Multi-part dot notation like "Darklang.St"
                let prefixParts = Stdlib.List.reverse reversedPrefixParts
                let lowerLastPartial = Stdlib.String.toLowercase lastPartial

                // Search in the specified module context
                let query =
                  LanguageTools.ProgramTypes.Search.SearchQuery
                    { currentModule = prefixParts
                      text = ""
                      searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                      entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
                let searchResults = LanguageTools.PackageManager.Search.search query

                // Extract submodule names that match the partial
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  let expectedLength = (Stdlib.List.length prefixParts) + 1L
                  let suggestions =
                    moduleList
                    |> Stdlib.List.filter (fun path -> Stdlib.List.length path == expectedLength)
                    |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
                    |> Stdlib.List.filter (fun name ->
                      Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerLastPartial)
                    |> Stdlib.List.map (fun name ->
                      let prefix = Stdlib.String.join prefixParts "."
                      $"{prefix}.{name}")
                    |> Stdlib.List.sort
                  suggestions
                | None -> []
            else
              // Regular prefix matching for simple paths
              let allCompletions = navComplete state []
              let lowerPartial = Stdlib.String.toLowercase partialPath
              Stdlib.List.filter allCompletions (fun path ->
                Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
          | _ -> []

        let cdComplete (state: AppState) (args: List<String>) : List<String> =
          navComplete state args

        let pwdComplete (state: AppState) (args: List<String>) : List<String> = []

        let backComplete (state: AppState) (args: List<String>) : List<String> = []