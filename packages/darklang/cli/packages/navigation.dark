module Darklang =
  module Cli =
    module Packages =
      module Navigation =
        // CD command - change directory/module
        let executeCD (state: Types.AppState) (args: List<String>) : Types.AppState =
          match args with
          | [] ->
            // No args, show current path
            let currentPathStr = Packages.Path.formatPath state.currentPath
            Builtin.printLine $"Current path: {currentPathStr}"
            { state with lastCommand = "cd"; output = "pwd displayed" }
          | [pathArg] ->
            let newPath =
              // Handle special navigation patterns
              if pathArg == ".." then
                // Go back to parent
                match state.currentPath with
                | Root -> Types.PackagePath.Root
                | Module owner moduleName ->
                  if Stdlib.String.isEmpty moduleName then
                    // At owner level, go to root
                    Types.PackagePath.Root
                  else
                    // At module level, go to owner
                    Types.PackagePath.Module owner ""
              else if pathArg == "../.." then
                // Go back two levels - always to root in our simple model
                Types.PackagePath.Root
              else if pathArg == "/" then
                Types.PackagePath.Root
              else if Stdlib.String.startsWith pathArg "/" then
                // Absolute path
                Packages.Path.parsePath pathArg
              else if Stdlib.String.startsWith pathArg "../" then
                // Relative path starting with ../
                // Go up one level first, then navigate
                let afterDotDot = Stdlib.String.dropFirst pathArg 3L
                match state.currentPath with
                | Root -> Packages.Path.parsePath afterDotDot
                | Module owner moduleName ->
                  if Stdlib.String.isEmpty moduleName then
                    // At owner level, go to root then navigate
                    Packages.Path.parsePath afterDotDot
                  else
                    // At module level, go to owner then navigate
                    if Stdlib.String.isEmpty afterDotDot then
                      Types.PackagePath.Module owner ""
                    else
                      Types.PackagePath.Module owner afterDotDot
              else
                // Regular relative path - append to current path
                match state.currentPath with
                | Root ->
                  // From root, just parse as normal
                  Packages.Path.parsePath pathArg
                | Module owner moduleName ->
                  // From inside a module, append the new segment
                  if Stdlib.String.isEmpty moduleName then
                    // We're at owner level (e.g., /Darklang)
                    Types.PackagePath.Module owner pathArg
                  else
                    // We're in a nested module like Darklang.Stdlib, append to the current path
                    Types.PackagePath.Module owner $"{moduleName}.{pathArg}"

            let newHistory = Stdlib.List.append state.pathHistory [state.currentPath]
            let newPathStr = Packages.Path.formatPath newPath
            Builtin.printLine (Colors.success $"Changed to: {newPathStr}")

            { state with
                lastCommand = "cd"
                output = $"cd to {newPathStr}"
                needsFullRedraw = true
                currentPath = newPath
                pathHistory = newHistory }
          | _ ->
            Builtin.printLine "Usage: cd [path]"
            Builtin.printLine "  cd /           - Go to root"
            Builtin.printLine "  cd ..          - Go to parent"
            Builtin.printLine "  cd owner/module - Go to module"
            { state with lastCommand = "cd"; output = "cd help displayed" }

        // PWD command - show current path
        let executePWD (state: Types.AppState) (args: List<String>) : Types.AppState =
          let currentPathStr = Packages.Path.formatPath state.currentPath
          Builtin.printLine currentPathStr
          { state with lastCommand = "pwd"; output = "pwd displayed" }

        // BACK command - navigate back using history
        let executeBACK (state: Types.AppState) (args: List<String>) : Types.AppState =
          match Stdlib.List.last state.pathHistory with
          | Some previousPath ->
            let newHistory = Stdlib.List.dropLast state.pathHistory
            let pathStr = Packages.Path.formatPath previousPath
            Builtin.printLine (Colors.success $"Back to: {pathStr}")

            { state with
                lastCommand = "back"
                output = $"back to {pathStr}"
                needsFullRedraw = true
                currentPath = previousPath
                pathHistory = newHistory }
          | None ->
            Builtin.printLine "No previous location in history"
            { state with lastCommand = "back"; output = "no history" }

        // Help functions
        let cdHelp (state: Types.AppState) : Types.AppState =
          Builtin.printLine "Usage: cd [path]"
          Builtin.printLine "Navigate between packages and modules."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  cd /                - Go to root"
          Builtin.printLine "  cd ..               - Go to parent"
          Builtin.printLine "  cd Stdlib           - Go to Stdlib owner"
          Builtin.printLine "  cd Stdlib/List      - Go to Stdlib.List module"
          Builtin.printLine "  cd /Darklang/Stdlib - Absolute path"
          { state with lastCommand = "help cd"; output = "cd help displayed" }

        let pwdHelp (state: Types.AppState) : Types.AppState =
          Builtin.printLine "Usage: pwd"
          Builtin.printLine "Show the current package path."
          { state with lastCommand = "help pwd"; output = "pwd help displayed" }

        let backHelp (state: Types.AppState) : Types.AppState =
          Builtin.printLine "Usage: back"
          Builtin.printLine "Navigate back to the previous location in history."
          { state with lastCommand = "help back"; output = "back help displayed" }

        // Completion functions
        let cdComplete (state: Types.AppState) (args: List<String>) : List<String> =
          match args with
          | [] ->
            // At root, suggest top-level packages
            match state.currentPath with
            | Root ->
              // Get top-level packages from the package manager
              let query =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = []
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Extract unique owners from module paths
              let owners =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  moduleList
                  |> Stdlib.List.filterMap (fun path ->
                    match path with
                    | owner :: _ -> Stdlib.Option.Option.Some owner
                    | [] -> Stdlib.Option.Option.None)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Add basic navigation options
              Stdlib.List.append ["/"; ".."] owners
            | Module owner moduleName ->
              // Inside a module, suggest submodules
              let currentModule = if Stdlib.String.isEmpty moduleName then [owner] else [owner; moduleName]
              let query =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = currentModule
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Extract submodule names - only direct children
              let submodules =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  // Filter to only direct children by checking path length
                  let expectedLength = (Stdlib.List.length currentModule) + 1L
                  moduleList
                  |> Stdlib.List.filter (fun path ->
                    Stdlib.List.length path == expectedLength)
                  |> Stdlib.List.filterMap (fun path ->
                    // Get the last part of the path as the submodule name
                    Stdlib.List.last path)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Add basic navigation options
              Stdlib.List.append ["/"; ".."] submodules

          | [partialPath] ->
            // Handle dot-notation completion like "Darklang.St"
            if Stdlib.String.contains partialPath "." then
              // Parse the partial path to understand context
              let pathParts = Stdlib.String.split partialPath "."
              match Stdlib.List.reverse pathParts with
              | [] -> []
              | [lastPart] ->
                // Single part with dot, shouldn't happen but handle gracefully
                let allCompletions = cdComplete state []
                let lowerPartial = Stdlib.String.toLowercase partialPath
                Stdlib.List.filter allCompletions (fun path ->
                  Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
              | lastPartial :: reversedPrefixParts ->
                // Multi-part dot notation like "Darklang.St"
                let prefixParts = Stdlib.List.reverse reversedPrefixParts
                let lowerLastPartial = Stdlib.String.toLowercase lastPartial

                // Search in the specified module context
                let query =
                  LanguageTools.ProgramTypes.Search.SearchQuery
                    { currentModule = prefixParts
                      text = ""
                      searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                      entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
                let searchResults = LanguageTools.PackageManager.Search.search query

                // Extract submodule names that match the partial
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  let expectedLength = (Stdlib.List.length prefixParts) + 1L
                  let suggestions =
                    moduleList
                    |> Stdlib.List.filter (fun path -> Stdlib.List.length path == expectedLength)
                    |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
                    |> Stdlib.List.filter (fun name ->
                      Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerLastPartial)
                    |> Stdlib.List.map (fun name ->
                      let prefix = Stdlib.String.join prefixParts "."
                      $"{prefix}.{name}")
                    |> Stdlib.List.sort
                  suggestions
                | None -> []
            else
              // Regular prefix matching for simple paths
              let allCompletions = cdComplete state []
              let lowerPartial = Stdlib.String.toLowercase partialPath
              Stdlib.List.filter allCompletions (fun path ->
                Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
          | _ -> []

        let pwdComplete (state: Types.AppState) (args: List<String>) : List<String> = []

        let backComplete (state: Types.AppState) (args: List<String>) : List<String> = []