module Darklang =
  module Cli =
    module Packages =
      module Navigation =
        // CD command - change directory/module
        let executeCD (state: Types.AppState) (args: List<String>) : Types.AppState =
          match args with
          | [] ->
            // No args, show current path
            let currentPathStr = Packages.Path.formatPath state.currentPath
            Builtin.printLine $"Current path: {currentPathStr}"
            Types.AppState { isExiting = state.isExiting; lastCommand = "cd"; output = "pwd displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
          | [pathArg] ->
            let newPath =
              // Handle special navigation patterns
              if pathArg == ".." then
                // Go back to parent
                match state.currentPath with
                | Root -> Types.PackagePath.Root
                | Module owner moduleName -> 
                  if Stdlib.String.isEmpty moduleName then
                    // At owner level, go to root
                    Types.PackagePath.Root
                  else
                    // At module level, go to owner
                    Types.PackagePath.Module owner ""
              else if pathArg == "../.." then
                // Go back two levels - always to root in our simple model
                Types.PackagePath.Root
              else if pathArg == "/" then
                Types.PackagePath.Root
              else if Stdlib.String.startsWith pathArg "/" then
                // Absolute path
                Packages.Path.parsePath pathArg
              else if Stdlib.String.startsWith pathArg "../" then
                // Relative path starting with ../
                // Go up one level first, then navigate
                let afterDotDot = Stdlib.String.dropFirst pathArg 3L
                match state.currentPath with
                | Root -> Packages.Path.parsePath afterDotDot
                | Module owner moduleName ->
                  if Stdlib.String.isEmpty moduleName then
                    // At owner level, go to root then navigate
                    Packages.Path.parsePath afterDotDot
                  else
                    // At module level, go to owner then navigate
                    if Stdlib.String.isEmpty afterDotDot then
                      Types.PackagePath.Module owner ""
                    else
                      Types.PackagePath.Module owner afterDotDot
              else
                // Regular relative path - append to current path
                match state.currentPath with
                | Root -> 
                  // From root, just parse as normal
                  Packages.Path.parsePath pathArg
                | Module owner moduleName ->
                  // From inside a module, append the new segment
                  if Stdlib.String.isEmpty moduleName then
                    // We're at owner level (e.g., /Darklang)
                    Types.PackagePath.Module owner pathArg
                  else
                    // We're deeper, but our simple model only supports owner/module
                    // For now, just navigate to owner/pathArg
                    Types.PackagePath.Module owner pathArg

            let newHistory = Stdlib.List.append state.pathHistory [state.currentPath]
            let newPathStr = Packages.Path.formatPath newPath
            Builtin.printLine $"Changed to: {newPathStr}"

            Types.AppState {
              isExiting = state.isExiting;
              lastCommand = "cd";
              output = $"cd to {newPathStr}";
              mainPrompt = state.mainPrompt;
              needsFullRedraw = true;
              currentPath = newPath;
              pathHistory = newHistory;
              viewMode = state.viewMode
            }
          | _ ->
            Builtin.printLine "Usage: cd [path]"
            Builtin.printLine "  cd /           - Go to root"
            Builtin.printLine "  cd ..          - Go to parent"
            Builtin.printLine "  cd owner/module - Go to module"
            Types.AppState { isExiting = state.isExiting; lastCommand = "cd"; output = "cd help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

        // PWD command - show current path
        let executePWD (state: Types.AppState) (args: List<String>) : Types.AppState =
          let currentPathStr = Packages.Path.formatPath state.currentPath
          Builtin.printLine currentPathStr
          Types.AppState { isExiting = state.isExiting; lastCommand = "pwd"; output = "pwd displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

        // BACK command - navigate back using history
        let executeBACK (state: Types.AppState) (args: List<String>) : Types.AppState =
          match Stdlib.List.last state.pathHistory with
          | Some previousPath ->
            let newHistory = Stdlib.List.dropLast state.pathHistory
            let pathStr = Packages.Path.formatPath previousPath
            Builtin.printLine $"Back to: {pathStr}"

            Types.AppState {
              isExiting = state.isExiting;
              lastCommand = "back";
              output = $"back to {pathStr}";
              mainPrompt = state.mainPrompt;
              needsFullRedraw = true;
              currentPath = previousPath;
              pathHistory = newHistory;
              viewMode = state.viewMode
            }
          | None ->
            Builtin.printLine "No previous location in history"
            Types.AppState { isExiting = state.isExiting; lastCommand = "back"; output = "no history"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

        // Help functions
        let cdHelp (state: Types.AppState) : Types.AppState =
          Builtin.printLine "Usage: cd [path]"
          Builtin.printLine "Navigate between packages and modules."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  cd /                - Go to root"
          Builtin.printLine "  cd ..               - Go to parent"
          Builtin.printLine "  cd Stdlib           - Go to Stdlib owner"
          Builtin.printLine "  cd Stdlib/List      - Go to Stdlib.List module"
          Builtin.printLine "  cd /Darklang/Stdlib - Absolute path"
          Types.AppState { isExiting = state.isExiting; lastCommand = "help cd"; output = "cd help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

        let pwdHelp (state: Types.AppState) : Types.AppState =
          Builtin.printLine "Usage: pwd"
          Builtin.printLine "Show the current package path."
          Types.AppState { isExiting = state.isExiting; lastCommand = "help pwd"; output = "pwd help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

        let backHelp (state: Types.AppState) : Types.AppState =
          Builtin.printLine "Usage: back"
          Builtin.printLine "Navigate back to the previous location in history."
          Types.AppState { isExiting = state.isExiting; lastCommand = "help back"; output = "back help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

        // Completion functions
        let cdComplete (state: Types.AppState) (args: List<String>) : List<String> =
          match args with
          | [] ->
            // At root, suggest top-level packages
            match state.currentPath with
            | Root ->
              // Get top-level packages from the package manager
              let query =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = []
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Extract unique owners from module paths
              let owners =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  moduleList
                  |> Stdlib.List.filterMap (fun path ->
                    match path with
                    | owner :: _ -> Stdlib.Option.Option.Some owner
                    | [] -> Stdlib.Option.Option.None)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Add basic navigation options
              Stdlib.List.append ["/"; ".."] owners
            | Module owner moduleName ->
              // Inside a module, suggest submodules
              let currentModule = if Stdlib.String.isEmpty moduleName then [owner] else [owner; moduleName]
              let query =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = currentModule
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Extract submodule names - only direct children
              let submodules =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  // Filter to only direct children by checking path length
                  let expectedLength = (Stdlib.List.length currentModule) + 1L
                  moduleList
                  |> Stdlib.List.filter (fun path -> 
                    Stdlib.List.length path == expectedLength)
                  |> Stdlib.List.filterMap (fun path ->
                    // Get the last part of the path as the submodule name
                    Stdlib.List.last path)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Add basic navigation options
              Stdlib.List.append ["/"; ".."] submodules

          | [partialPath] ->
            // Get all available completions
            let allCompletions = cdComplete state []
            let lowerPartial = Stdlib.String.toLowercase partialPath
            // Filter by prefix match
            Stdlib.List.filter allCompletions (fun path ->
              Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
          | _ -> []

        let pwdComplete (state: Types.AppState) (args: List<String>) : List<String> = []

        let backComplete (state: Types.AppState) (args: List<String>) : List<String> = []