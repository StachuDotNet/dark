module Darklang =
  module Cli =
    module Packages =
      module Navigation =
        // Helper function to intelligently resolve navigation targets
        let resolveNavigationTarget (currentPath: Types.PackagePath) (target: String) : (Types.PackageLocation * String) =
          // Handle special navigation cases first
          if target == "/" then
            (Root, "/")
          else if target == ".." then
            // Go up one level
            match currentPath with
            | [] -> (Root, "/")
            | _ ->
              let parentPath = Stdlib.List.dropLast currentPath
              let parentLocation = Packages.Path.pathToLocation parentPath
              let parentStr = Packages.Path.formatLocation parentLocation
              (parentLocation, parentStr)
          else
            // Single or multi-part name - check if it's an entity first, then try as module path
            let searchQuery = Utils.createSearchQuery currentPath
            let searchResults = LanguageTools.PackageManager.Search.search searchQuery
            
            // Check if it's a function
            let foundFunction =
              searchResults.fns
              |> Stdlib.List.findFirst (fun fn ->
                let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                let shortName = Utils.extractEntityShortName name
                shortName == target)
            
            match foundFunction with
            | Some fn ->
              let fnLocation = Types.PackageLocation.Function (target, currentPath)
              let locationStr = Packages.Path.formatLocation fnLocation
              (fnLocation, locationStr)
            | None ->
              // Check if it's a type
              let foundType =
                searchResults.types
                |> Stdlib.List.findFirst (fun typ ->
                  let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                  let shortName = Utils.extractEntityShortName name
                  shortName == target)
              
              match foundType with
              | Some typ ->
                let typeLocation = Types.PackageLocation.Type (target, currentPath)
                let locationStr = Packages.Path.formatLocation typeLocation
                (typeLocation, locationStr)
              | None ->
                // Check if it's a constant
                let foundConstant =
                  searchResults.constants
                  |> Stdlib.List.findFirst (fun constant ->
                    let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                    let shortName = Utils.extractEntityShortName name
                    shortName == target)
                
                match foundConstant with
                | Some constant ->
                  let constLocation = Types.PackageLocation.Constant (target, currentPath)
                  let locationStr = Packages.Path.formatLocation constLocation
                  (constLocation, locationStr)
                | None ->
                  // Try as module path, but validate it exists
                  let newPath = Utils.resolvePath currentPath target
                  let query = Utils.createSearchQuery newPath
                  let searchResults = LanguageTools.PackageManager.Search.search query
                  
                  // Check if this path has any content (submodules, functions, types, constants)
                  let hasSubmodules = Stdlib.Bool.not (Stdlib.List.isEmpty searchResults.submodules)
                  let hasFunctions = Stdlib.Bool.not (Stdlib.List.isEmpty searchResults.fns)
                  let hasTypes = Stdlib.Bool.not (Stdlib.List.isEmpty searchResults.types)
                  let hasConstants = Stdlib.Bool.not (Stdlib.List.isEmpty searchResults.constants)
                  
                  if hasSubmodules || hasFunctions || hasTypes || hasConstants then
                    let newLocation = Packages.Path.pathToLocation newPath
                    let locationStr = Packages.Path.formatLocation newLocation
                    (newLocation, locationStr)
                  else
                    // Path doesn't exist - return a special error result that the caller can handle
                    // We'll use a special marker to indicate failure
                    let currentLocation = Packages.Path.pathToLocation currentPath
                    let errorMsg = $"Path '{target}' not found"
                    (currentLocation, errorMsg)

        // NAV command - navigate between packages, modules, and entities  
        let executeNAV (state: AppState) (args: List<String>) : AppState =
          match args with
          | [] ->
            // No args, show current path using pure function
            let currentPathStr = Commands.computePwdOutput state.currentLocation
            Builtin.printLine $"Current path: {currentPathStr}"
            { state with lastCommand = "nav"; output = "pwd displayed" }
          | [pathArg] ->
            // Use pure function to compute navigation result
            let (newLocation, locationStr) = Commands.computeNavigation state.currentLocation pathArg
            
            // Check if navigation failed (same location + error message)
            if newLocation == state.currentLocation && Stdlib.String.contains locationStr "not found" then
              // Navigation failed - show error and don't change location
              Builtin.printLine (Colors.error locationStr)
              { state with lastCommand = "nav"; output = "nav failed" }
            else
              // Navigation succeeded
              let newHistory = Stdlib.List.append state.locationHistory [state.currentLocation]
              Builtin.printLine (Colors.success $"Changed to: {locationStr}")

              { state with
                  lastCommand = "nav"
                  output = $"nav to {locationStr}"
                  needsFullRedraw = true
                  currentLocation = newLocation
                  locationHistory = newHistory }
          | _ ->
            Builtin.printLine "Usage: nav [path]"
            Builtin.printLine "  nav /             - Go to root"
            Builtin.printLine "  nav ..            - Go to parent"
            Builtin.printLine "  nav owner/module  - Go to module"
            Builtin.printLine "  nav functionName  - Go to function"
            Builtin.printLine "  nav TypeName      - Go to type"
            Builtin.printLine "  nav constantName  - Go to constant"
            { state with lastCommand = "nav"; output = "nav help displayed" }
            
        // CD command - alias for NAV
        let executeCD (state: AppState) (args: List<String>) : AppState =
          executeNAV state args

        // PWD command - show current path
        let executePWD (state: AppState) (args: List<String>) : AppState =
          let currentPathStr = Packages.Path.formatLocation state.currentLocation
          Builtin.printLine currentPathStr
          { state with lastCommand = "pwd"; output = "pwd displayed" }

        // BACK command - navigate back using history
        let executeBACK (state: AppState) (args: List<String>) : AppState =
          // Use pure function to compute back navigation target
          match Commands.computeBackNavigation state.locationHistory with
          | Some previousLocation ->
            let newHistory = Stdlib.List.dropLast state.locationHistory
            let pathStr = Packages.Path.formatLocation previousLocation
            Builtin.printLine (Colors.success $"Back to: {pathStr}")

            { state with
                lastCommand = "back"
                output = $"back to {pathStr}"
                needsFullRedraw = true
                currentLocation = previousLocation
                locationHistory = newHistory }
          | None ->
            Builtin.printLine "No previous location in history"
            { state with lastCommand = "back"; output = "no history" }

        // Help functions
        let navHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: nav [path]"
          Builtin.printLine "Navigate between packages, modules, and entities."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  nav /                - Go to root"
          Builtin.printLine "  nav ..               - Go to parent"
          Builtin.printLine "  nav Stdlib           - Go to Stdlib owner"
          Builtin.printLine "  nav Stdlib/List      - Go to Stdlib.List module"
          Builtin.printLine "  nav /Darklang/Stdlib - Absolute path"
          Builtin.printLine "  nav equals           - Go to equals function"
          Builtin.printLine "  nav Option           - Go to Option type"
          { state with lastCommand = "help nav"; output = "nav help displayed" }
          
        let cdHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: cd [path] (alias for nav)"
          Builtin.printLine "Navigate between packages, modules, and entities."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  cd /                - Go to root"
          Builtin.printLine "  cd ..               - Go to parent"
          Builtin.printLine "  cd Stdlib           - Go to Stdlib owner"
          Builtin.printLine "  cd Stdlib/List      - Go to Stdlib.List module"
          Builtin.printLine "  cd /Darklang/Stdlib - Absolute path"
          Builtin.printLine "  cd equals           - Go to equals function"
          Builtin.printLine "  cd Option           - Go to Option type"
          { state with lastCommand = "help cd"; output = "cd help displayed" }

        let pwdHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: pwd"
          Builtin.printLine "Show the current package path."
          { state with lastCommand = "help pwd"; output = "pwd help displayed" }

        let backHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: back"
          Builtin.printLine "Navigate back to the previous location in history."
          { state with lastCommand = "help back"; output = "back help displayed" }

        // Completion functions
        let navComplete (state: AppState) (args: List<String>) : List<String> =
          match args with
          | [] ->
            // At root, suggest top-level packages
            let currentPath = Packages.Path.locationToPath state.currentLocation
            if Stdlib.List.isEmpty currentPath then
              // Get top-level packages from the package manager
              let query = Utils.createSearchQuery []
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Extract unique owners from module paths
              let owners =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  moduleList
                  |> Stdlib.List.filterMap (fun path ->
                    match path with
                    | owner :: _ -> Stdlib.Option.Option.Some owner
                    | [] -> Stdlib.Option.Option.None)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Add basic navigation options
              Stdlib.List.append ["/"; ".."] owners
            else
              // Inside a module, suggest submodules AND entities (functions, types, constants)
              let query = Utils.createSearchQuery currentPath
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Extract submodule names - only direct children
              let submodules =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  // Filter to only direct children by checking path length
                  let expectedLength = (Stdlib.List.length currentPath) + 1L
                  moduleList
                  |> Stdlib.List.filter (fun path ->
                    Stdlib.List.length path == expectedLength)
                  |> Stdlib.List.filterMap (fun path ->
                    // Get the last part of the path as the submodule name
                    Stdlib.List.last path)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Extract entity names (functions, types, constants)
              let functionNames =
                searchResults.fns
                |> Stdlib.List.map (fun fn ->
                  let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                  Utils.extractEntityShortName name)

              let typeNames =
                searchResults.types
                |> Stdlib.List.map (fun typ ->
                  let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                  Utils.extractEntityShortName name)

              let constantNames =
                searchResults.constants
                |> Stdlib.List.map (fun constant ->
                  let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                  Utils.extractEntityShortName name)

              // Combine all navigation options
              let allOptions = 
                Stdlib.List.append ["/"; ".."] 
                  (Stdlib.List.append submodules 
                    (Stdlib.List.append functionNames 
                      (Stdlib.List.append typeNames constantNames)))
              
              allOptions |> Stdlib.List.unique |> Stdlib.List.sort

          | [partialPath] ->
            // Handle dot-notation completion like "Darklang.St"
            if Stdlib.String.contains partialPath "." then
              // Parse the partial path to understand context
              let pathParts = Stdlib.String.split partialPath "."
              match Stdlib.List.reverse pathParts with
              | [] -> []
              | [lastPart] ->
                // Single part with dot, shouldn't happen but handle gracefully
                let allCompletions = cdComplete state []
                let lowerPartial = Stdlib.String.toLowercase partialPath
                Stdlib.List.filter allCompletions (fun path ->
                  Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
              | lastPartial :: reversedPrefixParts ->
                // Multi-part dot notation like "Darklang.St"
                let prefixParts = Stdlib.List.reverse reversedPrefixParts
                let lowerLastPartial = Stdlib.String.toLowercase lastPartial

                // Search in the specified module context
                let query = Utils.createSearchQuery prefixParts
                let searchResults = LanguageTools.PackageManager.Search.search query

                // Extract submodule names that match the partial
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  let expectedLength = (Stdlib.List.length prefixParts) + 1L
                  let suggestions =
                    moduleList
                    |> Stdlib.List.filter (fun path -> Stdlib.List.length path == expectedLength)
                    |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
                    |> Stdlib.List.filter (fun name ->
                      Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerLastPartial)
                    |> Stdlib.List.map (fun name ->
                      let prefix = Stdlib.String.join prefixParts "."
                      $"{prefix}.{name}")
                    |> Stdlib.List.sort
                  suggestions
                | None -> []
            else
              // Regular prefix matching for simple paths
              let allCompletions = navComplete state []
              let lowerPartial = Stdlib.String.toLowercase partialPath
              Stdlib.List.filter allCompletions (fun path ->
                Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
          | _ -> []

        let cdComplete (state: AppState) (args: List<String>) : List<String> =
          navComplete state args

        let pwdComplete (state: AppState) (args: List<String>) : List<String> = []

        let backComplete (state: AppState) (args: List<String>) : List<String> = []