module Darklang =
  module Cli =
    module Packages =
      module Viewing =
        // Entity categories for viewing mode
        type EntityCategory =
          | Functions
          | Types
          | Constants
          | Submodules

        // Viewing state for interactive mode
        type ViewingState =
          { moduleContent: LanguageTools.ProgramTypes.Search.SearchResults
            entityName: String
            selectedCategory: EntityCategory
            selectedItemIndex: Int64
            expandedCategories: List<EntityCategory>
            entityDefinition: Stdlib.Option.Option<EntityDefinition>
            entityCache: List<(String * EntityDefinition)>
            viewportScrollPosition: Int64
            treeMode: Bool
            treeDepth: Int64
            selectedTreeIndex: Int64 }

        type EntityDefinition = String

        // VIEW command - view modules, functions, types, or constants
        let executeView (state: AppState) (args: List<String>) : AppState =
          match args with
          | [] ->
            Builtin.printLine "Usage: view <entityName> or view <moduleName>"
            Builtin.printLine "View details of functions, types, constants, or modules."
            { state with lastCommand = "view help"; output = "view help displayed" }
          | [fullPath] ->
            // Parse the path: could be "Option" or "Darklang.Stdlib.Option.Option"
            let pathParts = Stdlib.String.split fullPath "."

            // Try to find as a specific entity first
            let (modulePath, entityName) =
              match Stdlib.List.reverse pathParts with
              | [] -> ([], fullPath)  // Shouldn't happen, but handle gracefully
              | [singleName] ->
                // Single name like "Option" - search in current context
                (state.currentPath, singleName)
              | entityName :: reversedModuleParts ->
                // Multi-part path like "Darklang.Stdlib.Option.Option"
                let moduleParts = Stdlib.List.reverse reversedModuleParts
                (moduleParts, entityName)

            // Build search query to find the entity in the specified module
            let searchQuery =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = modulePath
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Fn
                                  LanguageTools.ProgramTypes.Search.EntityType.Type
                                  LanguageTools.ProgramTypes.Search.EntityType.Constant
                                  LanguageTools.ProgramTypes.Search.EntityType.Module ] }

            let searchResults = LanguageTools.PackageManager.Search.search searchQuery

            // Try to find the specific entity by exact name match
            let foundFunction =
              searchResults.fns
              |> Stdlib.List.findFirst (fun fn ->
                let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                let parts = Stdlib.String.split name "."
                match Stdlib.List.last parts with
                | Some lastPart -> lastPart == entityName
                | None -> name == entityName)

            let foundType =
              searchResults.types
              |> Stdlib.List.findFirst (fun typ ->
                let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                let parts = Stdlib.String.split name "."
                match Stdlib.List.last parts with
                | Some lastPart -> lastPart == entityName
                | None -> name == entityName)

            let foundConstant =
              searchResults.constants
              |> Stdlib.List.findFirst (fun constant ->
                let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                let parts = Stdlib.String.split name "."
                match Stdlib.List.last parts with
                | Some lastPart -> lastPart == entityName
                | None -> name == entityName)

            // Display the found entity
            match foundFunction with
            | Some fn ->
              viewSpecificFunction state fn
            | None ->
              match foundType with
              | Some typ ->
                viewSpecificType state typ
              | None ->
                match foundConstant with
                | Some constant ->
                  viewSpecificConstant state constant
                | None ->
                  // No entity found - try as a module using the full path
                  let fullModulePath = Stdlib.List.append modulePath [entityName]
                  let moduleSearchQuery =
                    LanguageTools.ProgramTypes.Search.SearchQuery
                      { currentModule = fullModulePath
                        text = ""
                        searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                        entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Fn
                                        LanguageTools.ProgramTypes.Search.EntityType.Type
                                        LanguageTools.ProgramTypes.Search.EntityType.Constant
                                        LanguageTools.ProgramTypes.Search.EntityType.Module ] }

                  let moduleSearchResults = LanguageTools.PackageManager.Search.search moduleSearchQuery
                  let hasModuleContents =
                    Stdlib.Bool.not (Stdlib.List.isEmpty moduleSearchResults.fns) ||
                    Stdlib.Bool.not (Stdlib.List.isEmpty moduleSearchResults.types) ||
                    Stdlib.Bool.not (Stdlib.List.isEmpty moduleSearchResults.constants) ||
                    Stdlib.Bool.not (Stdlib.List.isEmpty moduleSearchResults.submodules)

                  if hasModuleContents then
                    // Display as module 
                    viewAsModule state fullPath moduleSearchResults
                  else
                    // Nothing found
                    Builtin.printLine $"Entity '{fullPath}' not found."
                    Builtin.printLine "Use 'ls' to see available entities or 'cd' to navigate to a module."
                    { state with lastCommand = "view"; output = $"entity {fullPath} not found" }
          | _ ->
            Builtin.printLine "Usage: view <entityName>"
            Builtin.printLine "Too many arguments provided."
            { state with lastCommand = "view error"; output = "view error" }

        // Helper function to view a specific function
        let viewSpecificFunction (state: AppState) (fn: LanguageTools.ProgramTypes.PackageFn.PackageFn) : AppState =
          let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageFn fn
          Builtin.printLine prettyPrinted

          let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
          { state with lastCommand = "view"; output = $"viewed function {name}" }

        // Helper function to view a specific type
        let viewSpecificType (state: AppState) (typ: LanguageTools.ProgramTypes.PackageType.PackageType) : AppState =
          let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageType typ
          Builtin.printLine prettyPrinted

          let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
          { state with lastCommand = "view"; output = $"viewed type {name}" }

        // Helper function to view a specific constant
        let viewSpecificConstant (state: AppState) (constant: LanguageTools.ProgramTypes.PackageConstant.PackageConstant) : AppState =
          let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageConstant constant
          Builtin.printLine prettyPrinted

          let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
          { state with lastCommand = "view"; output = $"viewed constant {name}" }

        // Helper function to view as module
        let viewAsModule (state: AppState) (pathStr: String) (searchResults: LanguageTools.ProgramTypes.Search.SearchResults) : AppState =
          Builtin.printLine $"Module: {pathStr}"
          Builtin.printLine ""

          // Display submodules first
          if Stdlib.Bool.not (Stdlib.List.isEmpty searchResults.submodules) then
            match Stdlib.List.head searchResults.submodules with
            | Some moduleList ->
              let currentModule = Stdlib.String.split pathStr "."
              let expectedLength = (Stdlib.List.length currentModule) + 1L
              let directChildren =
                moduleList
                |> Stdlib.List.filter (fun path -> Stdlib.List.length path == expectedLength)
                |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
                |> Stdlib.List.unique
                |> Stdlib.List.sort

              if Stdlib.Bool.not (Stdlib.List.isEmpty directChildren) then
                Builtin.printLine $"Submodules ({Stdlib.Int64.toString (Stdlib.List.length directChildren)}):"
                directChildren
                |> Stdlib.List.iter (fun name -> Builtin.printLine $"  {name}/")
                Builtin.printLine ""
            | None -> ()

          // Display functions
          let fnCount = Stdlib.List.length searchResults.fns
          if fnCount > 0L then
            let fnNames =
              searchResults.fns
              |> Stdlib.List.map (fun fn ->
                let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                let parts = Stdlib.String.split name "."
                match Stdlib.List.last parts with
                | Some lastPart -> lastPart
                | None -> name)
              |> Stdlib.String.join ", "
            Builtin.printLine $"Functions ({Stdlib.Int64.toString fnCount}): {fnNames}"

          // Display types
          let typeCount = Stdlib.List.length searchResults.types
          if typeCount > 0L then
            let typeNames =
              searchResults.types
              |> Stdlib.List.map (fun typ ->
                let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                let parts = Stdlib.String.split name "."
                match Stdlib.List.last parts with
                | Some lastPart -> lastPart
                | None -> name)
              |> Stdlib.String.join ", "
            Builtin.printLine $"Types ({Stdlib.Int64.toString typeCount}): {typeNames}"

          // Display constants
          let constCount = Stdlib.List.length searchResults.constants
          if constCount > 0L then
            let constNames =
              searchResults.constants
              |> Stdlib.List.map (fun constant ->
                let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                let parts = Stdlib.String.split name "."
                match Stdlib.List.last parts with
                | Some lastPart -> lastPart
                | None -> name)
              |> Stdlib.String.join ", "
            Builtin.printLine $"Constants ({Stdlib.Int64.toString constCount}): {constNames}"


          { state with lastCommand = "view"; output = $"viewed module {pathStr}" }

        // Help function
        let viewHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: view <entityName>"
          Builtin.printLine "View detailed information about functions, types, constants, or modules."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  view List.head          - View the List.head function"
          Builtin.printLine "  view Option             - View the Option type"
          Builtin.printLine "  view Stdlib.List        - View contents of Stdlib.List module"
          { state with lastCommand = "help view"; output = "view help displayed" }

        // Completion function
        let viewComplete (state: AppState) (args: List<String>) : List<String> =
          match args with
          | [] ->
            // At root, suggest top-level packages plus entities
            if Stdlib.List.isEmpty state.currentPath then
              // Get top-level packages (same as cd completion)
              let moduleQuery =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = []
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
              let moduleResults = LanguageTools.PackageManager.Search.search moduleQuery

              // Extract unique owners from module paths
              let owners =
                match Stdlib.List.head moduleResults.submodules with
                | Some moduleList ->
                  moduleList
                  |> Stdlib.List.filterMap (fun path ->
                    match path with
                    | owner :: _ -> Stdlib.Option.Option.Some owner
                    | [] -> Stdlib.Option.Option.None)
                  |> Stdlib.List.unique
                  |> Stdlib.List.sort
                | None -> []

              // Also get any entities at root level
              let entityQuery =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = []
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Fn
                                    LanguageTools.ProgramTypes.Search.EntityType.Type
                                    LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
              let entityResults = LanguageTools.PackageManager.Search.search entityQuery

              let entityNames =
                let fnNames = entityResults.fns |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name)
                let typeNames = entityResults.types |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name)
                let constNames = entityResults.constants |> Stdlib.List.map (fun constant -> LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name)
                Stdlib.List.append (Stdlib.List.append fnNames typeNames) constNames

              (Stdlib.List.append owners entityNames)
              |> Stdlib.List.unique
              |> Stdlib.List.sort

            else
              // Inside a module, suggest submodules and entities
              let query =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = state.currentPath
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                    entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module
                                    LanguageTools.ProgramTypes.Search.EntityType.Fn
                                    LanguageTools.ProgramTypes.Search.EntityType.Type
                                    LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Get submodules
              let submodules =
                match Stdlib.List.head searchResults.submodules with
                | Some moduleList ->
                  let expectedLength = (Stdlib.List.length state.currentPath) + 1L
                  moduleList
                  |> Stdlib.List.filter (fun path -> Stdlib.List.length path == expectedLength)
                  |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
                  |> Stdlib.List.unique
                | None -> []

              // Get entities (extract just the last part of names)
              let functionNames =
                searchResults.fns
                |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name)
                |> Stdlib.List.filterMap (fun name ->
                  let parts = Stdlib.String.split name "."
                  match Stdlib.List.last parts with
                  | Some lastPart -> Stdlib.Option.Option.Some lastPart
                  | None -> Stdlib.Option.Option.None)

              let typeNames =
                searchResults.types
                |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name)
                |> Stdlib.List.filterMap (fun name ->
                  let parts = Stdlib.String.split name "."
                  match Stdlib.List.last parts with
                  | Some lastPart -> Stdlib.Option.Option.Some lastPart
                  | None -> Stdlib.Option.Option.None)

              let constantNames =
                searchResults.constants
                |> Stdlib.List.map (fun constant -> LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name)
                |> Stdlib.List.filterMap (fun name ->
                  let parts = Stdlib.String.split name "."
                  match Stdlib.List.last parts with
                  | Some lastPart -> Stdlib.Option.Option.Some lastPart
                  | None -> Stdlib.Option.Option.None)

              (Stdlib.List.append (Stdlib.List.append (Stdlib.List.append submodules functionNames) typeNames) constantNames)
              |> Stdlib.List.unique
              |> Stdlib.List.sort

          | [partial] ->
            // Handle dot-notation completion like "Stdlib.L" when in /Darklang
            if Stdlib.String.contains partial "." then
              // Parse the partial path to understand context
              let pathParts = Stdlib.String.split partial "."
              match Stdlib.List.reverse pathParts with
              | [] -> []
              | [lastPart] ->
                // Single part with dot, shouldn't happen but handle gracefully
                let allCompletions = viewComplete state []
                let lowerPartial = Stdlib.String.toLowercase partial
                allCompletions
                |> Stdlib.List.filter (fun name ->
                  Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerPartial)
              | lastPartial :: reversedPrefixParts ->
                // Multi-part dot notation like "Stdlib.L" when in /Darklang
                let prefixParts = Stdlib.List.reverse reversedPrefixParts
                let lowerLastPartial = Stdlib.String.toLowercase lastPartial

                // Build the full module path considering current context
                let fullModulePath =
                  if Stdlib.List.isEmpty state.currentPath then
                    prefixParts
                  else
                    // In module context, append current path to prefix
                    Stdlib.List.append state.currentPath prefixParts

                // Search for entities and submodules in that context
                let query =
                  LanguageTools.ProgramTypes.Search.SearchQuery
                    { currentModule = fullModulePath
                      text = ""
                      searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                      entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module
                                      LanguageTools.ProgramTypes.Search.EntityType.Fn
                                      LanguageTools.ProgramTypes.Search.EntityType.Type
                                      LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
                let searchResults = LanguageTools.PackageManager.Search.search query

                // Get submodules
                let submoduleSuggestions =
                  match Stdlib.List.head searchResults.submodules with
                  | Some moduleList ->
                    let expectedLength = (Stdlib.List.length fullModulePath) + 1L
                    moduleList
                    |> Stdlib.List.filter (fun path -> Stdlib.List.length path == expectedLength)
                    |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
                    |> Stdlib.List.filter (fun name ->
                      Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerLastPartial)
                  | None -> []

                // Get entities (functions, types, constants)
                let entitySuggestions =
                  let fnNames =
                    searchResults.fns
                    |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name)
                    |> Stdlib.List.filterMap (fun name ->
                      let parts = Stdlib.String.split name "."
                      match Stdlib.List.last parts with
                      | Some lastPart -> Stdlib.Option.Option.Some lastPart
                      | None -> Stdlib.Option.Option.None)

                  let typeNames =
                    searchResults.types
                    |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name)
                    |> Stdlib.List.filterMap (fun name ->
                      let parts = Stdlib.String.split name "."
                      match Stdlib.List.last parts with
                      | Some lastPart -> Stdlib.Option.Option.Some lastPart
                      | None -> Stdlib.Option.Option.None)

                  let constantNames =
                    searchResults.constants
                    |> Stdlib.List.map (fun constant -> LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name)
                    |> Stdlib.List.filterMap (fun name ->
                      let parts = Stdlib.String.split name "."
                      match Stdlib.List.last parts with
                      | Some lastPart -> Stdlib.Option.Option.Some lastPart
                      | None -> Stdlib.Option.Option.None)

                  (Stdlib.List.append (Stdlib.List.append fnNames typeNames) constantNames)
                  |> Stdlib.List.filter (fun name ->
                    Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerLastPartial)

                // Combine and format suggestions
                let allSuggestions = Stdlib.List.append submoduleSuggestions entitySuggestions
                let prefix = Stdlib.String.join prefixParts "."
                allSuggestions
                |> Stdlib.List.map (fun name -> $"{prefix}.{name}")
                |> Stdlib.List.unique
                |> Stdlib.List.sort
            else
              // Regular prefix matching for simple paths
              let allCompletions = viewComplete state []
              let lowerPartial = Stdlib.String.toLowercase partial
              allCompletions
              |> Stdlib.List.filter (fun name ->
                Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerPartial)

          | _ -> []

