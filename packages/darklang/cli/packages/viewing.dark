module Darklang =
  module Cli =
    module Packages =
      module Viewing =
        // Entity categories for viewing mode
        type EntityCategory =
          | Functions
          | Types
          | Constants
          | Submodules

        // Viewing state for interactive mode
        type ViewingState =
          { moduleContent: LanguageTools.ProgramTypes.Search.SearchResults
            entityName: String
            selectedCategory: EntityCategory
            selectedItemIndex: Int64
            expandedCategories: List<EntityCategory>
            entityDefinition: Stdlib.Option.Option<EntityDefinition>
            entityCache: List<(String * EntityDefinition)>
            viewportScrollPosition: Int64
            treeMode: Bool
            treeDepth: Int64
            selectedTreeIndex: Int64 }

        type EntityDefinition = String

        // VIEW command - view modules, functions, types, or constants
        let executeView (state: AppState) (args: List<String>) : AppState =
          match args with
          | [] ->
            Builtin.printLine "Usage: view <entityName> or view <moduleName>"
            Builtin.printLine "View details of functions, types, constants, or modules."
            { state with lastCommand = "view help"; output = "view help displayed" }
          | [fullPath] ->
            // Parse the path: could be "Option" or "Darklang.Stdlib.Option.Option"
            let pathParts = Stdlib.String.split fullPath "."

            // Try to find as a specific entity first
            let (modulePath, entityName) =
              match Stdlib.List.reverse pathParts with
              | [] -> ([], fullPath)  // Shouldn't happen, but handle gracefully
              | [singleName] ->
                // Single name like "Option" - search in current context
                (state.currentPath, singleName)
              | entityName :: reversedModuleParts ->
                // Multi-part path like "Darklang.Stdlib.Option.Option"
                let moduleParts = Stdlib.List.reverse reversedModuleParts
                (moduleParts, entityName)

            // Build search query to find the entity in the specified module
            let searchQuery = Utils.createFullSearchQuery modulePath

            let searchResults = LanguageTools.PackageManager.Search.search searchQuery

            // Try to find the specific entity by exact name match
            let foundFunction =
              searchResults.fns
              |> Stdlib.List.findFirst (fun fn ->
                let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                let shortName = Utils.extractEntityShortName name
                shortName == entityName)

            let foundType =
              searchResults.types
              |> Stdlib.List.findFirst (fun typ ->
                let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                let shortName = Utils.extractEntityShortName name
                shortName == entityName)

            let foundConstant =
              searchResults.constants
              |> Stdlib.List.findFirst (fun constant ->
                let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                let shortName = Utils.extractEntityShortName name
                shortName == entityName)

            // Display the found entity
            match foundFunction with
            | Some fn ->
              viewSpecificFunction state fn
            | None ->
              match foundType with
              | Some typ ->
                viewSpecificType state typ
              | None ->
                match foundConstant with
                | Some constant ->
                  viewSpecificConstant state constant
                | None ->
                  // No entity found - try as a module using the full path
                  let fullModulePath = Stdlib.List.append modulePath [entityName]
                  let moduleSearchQuery = Utils.createFullSearchQuery fullModulePath

                  let moduleSearchResults = LanguageTools.PackageManager.Search.search moduleSearchQuery
                  let hasModuleContents =
                    Stdlib.Bool.not (Stdlib.List.isEmpty moduleSearchResults.fns) ||
                    Stdlib.Bool.not (Stdlib.List.isEmpty moduleSearchResults.types) ||
                    Stdlib.Bool.not (Stdlib.List.isEmpty moduleSearchResults.constants) ||
                    Stdlib.Bool.not (Stdlib.List.isEmpty moduleSearchResults.submodules)

                  if hasModuleContents then
                    // Display as module
                    viewAsModule state fullPath moduleSearchResults
                  else
                    // Nothing found
                    Builtin.printLine $"Entity '{fullPath}' not found."
                    Builtin.printLine "Use 'ls' to see available entities or 'cd' to navigate to a module."
                    { state with lastCommand = "view"; output = $"entity {fullPath} not found" }
          | _ ->
            Builtin.printLine "Usage: view <entityName>"
            Builtin.printLine "Too many arguments provided."
            { state with lastCommand = "view error"; output = "view error" }

        // Helper function to view a specific function
        let viewSpecificFunction (state: AppState) (fn: LanguageTools.ProgramTypes.PackageFn.PackageFn) : AppState =
          let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageFn fn
          let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
          Builtin.printLine highlighted

          let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
          { state with lastCommand = "view"; output = $"viewed function {name}" }

        // Helper function to view a specific type
        let viewSpecificType (state: AppState) (typ: LanguageTools.ProgramTypes.PackageType.PackageType) : AppState =
          let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageType typ
          let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
          Builtin.printLine highlighted

          let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
          { state with lastCommand = "view"; output = $"viewed type {name}" }

        // Helper function to view a specific constant
        let viewSpecificConstant (state: AppState) (constant: LanguageTools.ProgramTypes.PackageConstant.PackageConstant) : AppState =
          let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageConstant constant
          let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
          Builtin.printLine highlighted

          let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
          { state with lastCommand = "view"; output = $"viewed constant {name}" }

        // Helper function to view as module
        let viewAsModule (state: AppState) (pathStr: String) (searchResults: LanguageTools.ProgramTypes.Search.SearchResults) : AppState =
          Builtin.printLine $"Module: {pathStr}"
          Builtin.printLine ""

          // Display submodules first
          // TEMPORARY: Commented out problematic submodules display due to type mismatch
          // TODO: Fix getDirectChildModuleNames usage

          // Display functions
          let fnCount = Stdlib.List.length searchResults.fns
          if fnCount > 0L then
            let fnNames =
              searchResults.fns
              |> Stdlib.List.map (fun fn ->
                let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                Utils.extractEntityShortName name)
              |> Stdlib.String.join ", "
            Builtin.printLine $"Functions ({Stdlib.Int64.toString fnCount}): {fnNames}"

          // Display types
          let typeCount = Stdlib.List.length searchResults.types
          if typeCount > 0L then
            let typeNames =
              searchResults.types
              |> Stdlib.List.map (fun typ ->
                let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                Utils.extractEntityShortName name)
              |> Stdlib.String.join ", "
            Builtin.printLine $"Types ({Stdlib.Int64.toString typeCount}): {typeNames}"

          // Display constants
          let constCount = Stdlib.List.length searchResults.constants
          if constCount > 0L then
            let constNames =
              searchResults.constants
              |> Stdlib.List.map (fun constant ->
                let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                Utils.extractEntityShortName name)
              |> Stdlib.String.join ", "
            Builtin.printLine $"Constants ({Stdlib.Int64.toString constCount}): {constNames}"


          { state with lastCommand = "view"; output = $"viewed module {pathStr}" }

        // Help function
        let viewHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: view <entityName>"
          Builtin.printLine "View detailed information about functions, types, constants, or modules."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  view List.head          - View the List.head function"
          Builtin.printLine "  view Option             - View the Option type"
          Builtin.printLine "  view Stdlib.List        - View contents of Stdlib.List module"
          { state with lastCommand = "help view"; output = "view help displayed" }

        // Completion function
        let viewComplete (state: AppState) (args: List<String>) : List<String> =
          match args with
          | [] ->
            // At root, suggest top-level packages plus entities
            if Stdlib.List.isEmpty state.currentPath then
              // Get top-level modules
              let moduleQuery = Utils.createModuleSearchQuery []
              let moduleResults = LanguageTools.PackageManager.Search.search moduleQuery

              // Get top-level modules
              let topLevelModules =
                // TEMPORARY: Disabled due to type mismatch issue
                []

              // Also get any entities at root level
              let entityQuery = Utils.createFullSearchQuery []
              let entityResults = LanguageTools.PackageManager.Search.search entityQuery

              let entityNames =
                let fnNames = entityResults.fns |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name)
                let typeNames = entityResults.types |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name)
                let constNames = entityResults.constants |> Stdlib.List.map (fun constant -> LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name)
                Stdlib.List.append (Stdlib.List.append fnNames typeNames) constNames

              (Stdlib.List.append topLevelModules entityNames)
              |> Stdlib.List.unique
              |> Stdlib.List.sort

            else
              // Inside a module, suggest submodules and entities
              let query = Utils.createFullSearchQuery state.currentPath
              let searchResults = LanguageTools.PackageManager.Search.search query

              // Get submodules
              // TEMPORARY: Disabled due to type mismatch issue
              let submodules = []

              // Get entities (extract just the last part of names)
              let functionNames =
                searchResults.fns
                |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name)
                |> Stdlib.List.map (fun name -> Utils.extractEntityShortName name)

              let typeNames =
                searchResults.types
                |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name)
                |> Stdlib.List.map (fun name -> Utils.extractEntityShortName name)

              let constantNames =
                searchResults.constants
                |> Stdlib.List.map (fun constant -> LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name)
                |> Stdlib.List.map (fun name -> Utils.extractEntityShortName name)

              (Stdlib.List.append (Stdlib.List.append (Stdlib.List.append submodules functionNames) typeNames) constantNames)
              |> Stdlib.List.unique
              |> Stdlib.List.sort

          | [partial] ->
            // Handle dot-notation completion like "Stdlib.L" when in /Darklang
            if Stdlib.String.contains partial "." then
              // Parse the partial path to understand context
              let pathParts = Stdlib.String.split partial "."
              match Stdlib.List.reverse pathParts with
              | [] -> []
              | [lastPart] ->
                // Single part with dot, shouldn't happen but handle gracefully
                let allCompletions = viewComplete state []
                let lowerPartial = Stdlib.String.toLowercase partial
                allCompletions
                |> Stdlib.List.filter (fun name ->
                  Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerPartial)
              | lastPartial :: reversedPrefixParts ->
                // Multi-part dot notation like "Stdlib.L" when in /Darklang
                let prefixParts = Stdlib.List.reverse reversedPrefixParts
                let lowerLastPartial = Stdlib.String.toLowercase lastPartial

                // Build the full module path considering current context
                let fullModulePath =
                  if Stdlib.List.isEmpty state.currentPath then
                    prefixParts
                  else
                    // In module context, append current path to prefix
                    Stdlib.List.append state.currentPath prefixParts

                // Search for entities and submodules in that context
                let query = Utils.createFullSearchQuery fullModulePath
                let searchResults = LanguageTools.PackageManager.Search.search query

                // Get submodules
                // TEMPORARY: Disabled due to type mismatch issue  
                let submoduleSuggestions = []

                // Get entities (functions, types, constants)
                let entitySuggestions =
                  let fnNames =
                    searchResults.fns
                    |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name)
                    |> Stdlib.List.map (fun name -> Utils.extractEntityShortName name)

                  let typeNames =
                    searchResults.types
                    |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name)
                    |> Stdlib.List.map (fun name -> Utils.extractEntityShortName name)

                  let constantNames =
                    searchResults.constants
                    |> Stdlib.List.map (fun constant -> LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name)
                    |> Stdlib.List.map (fun name -> Utils.extractEntityShortName name)

                  (Stdlib.List.append (Stdlib.List.append fnNames typeNames) constantNames)
                  |> Stdlib.List.filter (fun name ->
                    Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerLastPartial)

                // Combine and format suggestions
                let allSuggestions = Stdlib.List.append submoduleSuggestions entitySuggestions
                let prefix = Stdlib.String.join prefixParts "."
                allSuggestions
                |> Stdlib.List.map (fun name -> $"{prefix}.{name}")
                |> Stdlib.List.unique
                |> Stdlib.List.sort
            else
              // Regular prefix matching for simple paths
              let allCompletions = viewComplete state []
              let lowerPartial = Stdlib.String.toLowercase partial
              allCompletions
              |> Stdlib.List.filter (fun name ->
                Stdlib.String.startsWith (Stdlib.String.toLowercase name) lowerPartial)

          | _ -> []

