module Darklang =
  module Cli =
    module Packages =
      module Listing =
        // LS command - list contents
        let executeLS (state: AppState) (args: List<String>) : AppState =
          match args with
          | [] ->
            // No args - list current location
            listCurrentLocation state
          | [ pathArg ] -> 
            // With args - resolve and list that path
            let currentPath = Packages.Path.locationToPath state.currentLocation
            let path = Utils.resolvePath currentPath pathArg
            listModulePath state path
          | _ ->
            // Multiple args, just use current for now
            // CLEANUP error or something?
            listCurrentLocation state
            
        // Helper function to list current location (could be module, function, type, constant)
        let listCurrentLocation (state: AppState) : AppState =
          // Use pure function to compute listing output
          let output = Commands.computeListingOutput state.currentLocation
          Builtin.printLine output
          { state with lastCommand = "ls"; output = "ls displayed" }
            
        // Helper function to list a module path
        let listModulePath (state: AppState) (path: Types.PackagePath) : AppState =
          // Convert path to Module location and use pure function
          let location = 
            if Stdlib.List.isEmpty path then
              Types.PackageLocation.Root
            else
              Types.PackageLocation.Module path
          
          let output = Commands.computeListingOutput location
          Builtin.printLine output
          { state with lastCommand = "ls"; output = "ls displayed" }
            
        // Helper function to show details of a specific entity
        let listEntityDetails (state: AppState) (entityType: String) (entityName: String) (modulePath: Types.PackagePath) : AppState =
          let modulePathStr = if Stdlib.List.isEmpty modulePath then "" else $"/{Packages.Path.formatPath modulePath}"
          let fullPath = $"{modulePathStr}.{entityName}"
          
          Builtin.printLine $"{entityType}: {fullPath}"
          Builtin.printLine ""
          
          // Search for the specific entity to get its details
          let searchQuery = Utils.createSearchQuery modulePath
          let searchResults = LanguageTools.PackageManager.Search.search searchQuery
          
          match entityType with
          | "Function" ->
            // Find and display the function
            let foundFunction =
              searchResults.fns
              |> Stdlib.List.findFirst (fun fn ->
                let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                let shortName = Utils.extractEntityShortName name
                shortName == entityName)
            
            match foundFunction with
            | Some fn ->
              let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageFn fn
              let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
              Builtin.printLine highlighted
              { state with lastCommand = "ls"; output = $"ls function {entityName}" }
            | None ->
              Builtin.printLine $"Function '{entityName}' not found in current context."
              { state with lastCommand = "ls"; output = $"function {entityName} not found" }
              
          | "Type" ->
            // Find and display the type
            let foundType =
              searchResults.types
              |> Stdlib.List.findFirst (fun typ ->
                let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                let shortName = Utils.extractEntityShortName name
                shortName == entityName)
            
            match foundType with
            | Some typ ->
              let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageType typ
              let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
              Builtin.printLine highlighted
              { state with lastCommand = "ls"; output = $"ls type {entityName}" }
            | None ->
              Builtin.printLine $"Type '{entityName}' not found in current context."
              { state with lastCommand = "ls"; output = $"type {entityName} not found" }
              
          | "Constant" ->
            // Find and display the constant
            let foundConstant =
              searchResults.constants
              |> Stdlib.List.findFirst (fun constant ->
                let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                let shortName = Utils.extractEntityShortName name
                shortName == entityName)
            
            match foundConstant with
            | Some constant ->
              let prettyPrinted = Darklang.PrettyPrinter.ProgramTypes.packageConstant constant
              let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
              Builtin.printLine highlighted
              { state with lastCommand = "ls"; output = $"ls constant {entityName}" }
            | None ->
              Builtin.printLine $"Constant '{entityName}' not found in current context."
              { state with lastCommand = "ls"; output = $"constant {entityName} not found" }
              
          | _ ->
            Builtin.printLine $"Unknown entity type: {entityType}"
            { state with lastCommand = "ls"; output = "unknown entity type" }

        // Help function
        let lsHelp (state: AppState) : AppState =
          Builtin.printLine "Usage: ls [path]"
          Builtin.printLine "List contents of the current location or specified path."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  ls                - List current location"
          Builtin.printLine "  ls /              - List root packages"
          Builtin.printLine "  ls Darklang       - List Darklang package contents"
          Builtin.printLine "  ls ..             - List parent directory"
          { state with lastCommand = "help ls"; output = "ls help displayed" }

        // Completion function
        let lsComplete (state: AppState) (args: List<String>) : List<String> =
          Completion.noArgsCompletion state args