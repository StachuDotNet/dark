module Darklang =
  module Cli =
    module Packages =
      module Listing =
        // LS command - list contents
        let executeLS (state: Types.AppState) (args: List<String>) : Types.AppState =
          // Determine which path to list
          let pathToList =
            match args with
            | [] -> state.currentPath  // No args, list current location
            | [pathArg] ->
              // Parse the argument to get the path to list
              if pathArg == "/" then
                Types.PackagePath.Root
              else if pathArg == ".." then
                match state.currentPath with
                | Root -> Types.PackagePath.Root
                | Module owner moduleName -> Types.PackagePath.Root
              else
                Packages.Path.parsePath pathArg
            | _ -> state.currentPath  // Multiple args, just use current

          match pathToList with
          | Root ->
            // Get real top-level packages from the package manager
            let query =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = []
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
            let searchResults = LanguageTools.PackageManager.Search.search query

            // Extract unique owners from module paths
            let owners =
              match Stdlib.List.head searchResults.submodules with
              | Some moduleList ->
                moduleList
                |> Stdlib.List.filterMap (fun path ->
                  match path with
                  | owner :: _ -> Stdlib.Option.Option.Some owner
                  | [] -> Stdlib.Option.Option.None)
                |> Stdlib.List.unique
                |> Stdlib.List.sort
              | None -> []

            Builtin.printLine "Available packages:"
            owners |> Stdlib.List.iter (fun owner ->
              Builtin.printLine $"  {owner}/")

            if Stdlib.List.isEmpty owners then
              Builtin.printLine "  (No packages found)"
            else
              Builtin.printLine ""
              Builtin.printLine $"Use 'cd <package>' to explore a package"

            { state with lastCommand = "ls"; output = "ls root" }

          | Module owner moduleName ->
            let currentModule = if Stdlib.String.isEmpty moduleName then [owner] else [owner; moduleName]
            let query =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = currentModule
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module
                                  LanguageTools.ProgramTypes.Search.EntityType.Type
                                  LanguageTools.ProgramTypes.Search.EntityType.Fn
                                  LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
            let searchResults = LanguageTools.PackageManager.Search.search query

            let pathStr = Packages.Path.formatPath pathToList
            Builtin.printLine $"Contents of {pathStr}:"

            // List submodules - only direct children
            match Stdlib.List.head searchResults.submodules with
            | Some moduleList when Stdlib.Bool.not (Stdlib.List.isEmpty moduleList) ->
              // Filter to only direct children by checking path length
              let expectedLength = (Stdlib.List.length currentModule) + 1L
              let submoduleNames =
                moduleList
                |> Stdlib.List.filter (fun path ->
                  Stdlib.List.length path == expectedLength)
                |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
                |> Stdlib.List.unique
                |> Stdlib.List.sort
                |> Stdlib.List.map (fun name -> $"{name}/")
                |> Stdlib.String.join ", "
              let submoduleCount = 
                moduleList
                |> Stdlib.List.filter (fun path ->
                  Stdlib.List.length path == expectedLength)
                |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
                |> Stdlib.List.unique
                |> Stdlib.List.length
              Builtin.printLine ""
              Builtin.printLine $"  [Submodules] ({Stdlib.Int64.toString submoduleCount}): {submoduleNames}"
            | _ -> ()

            // List functions
            let fnCount = Stdlib.List.length searchResults.fns
            if fnCount > 0L then
              Builtin.printLine ""
              let fnNames =
                searchResults.fns
                |> Stdlib.List.map (fun fn ->
                  let name = LanguageTools.ProgramTypes.PackageFn.nameToString fn.name
                  let parts = Stdlib.String.split name "."
                  match Stdlib.List.last parts with
                  | Some lastPart -> lastPart
                  | None -> name)
                |> Stdlib.String.join ", "
              Builtin.printLine $"  [Functions] ({Stdlib.Int64.toString fnCount}): {fnNames}"

            // List types
            let typeCount = Stdlib.List.length searchResults.types
            if typeCount > 0L then
              Builtin.printLine ""
              let typeNames =
                searchResults.types
                |> Stdlib.List.map (fun typ ->
                  let name = LanguageTools.ProgramTypes.PackageType.nameToString typ.name
                  let parts = Stdlib.String.split name "."
                  match Stdlib.List.last parts with
                  | Some lastPart -> lastPart
                  | None -> name)
                |> Stdlib.String.join ", "
              Builtin.printLine $"  [Types] ({Stdlib.Int64.toString typeCount}): {typeNames}"

            // List constants
            let constCount = Stdlib.List.length searchResults.constants
            if constCount > 0L then
              Builtin.printLine ""
              let constNames =
                searchResults.constants
                |> Stdlib.List.map (fun constant ->
                  let name = LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name
                  let parts = Stdlib.String.split name "."
                  match Stdlib.List.last parts with
                  | Some lastPart -> lastPart
                  | None -> name)
                |> Stdlib.String.join ", "
              Builtin.printLine $"  [Constants] ({Stdlib.Int64.toString constCount}): {constNames}"

            Builtin.printLine ""
            Builtin.printLine "Use 'view' to see details of functions, types, and constants"

            { state with lastCommand = "ls"; output = "ls module" }

        // Help function
        let lsHelp (state: Types.AppState) : Types.AppState =
          Builtin.printLine "Usage: ls [path]"
          Builtin.printLine "List contents of the current location or specified path."
          Builtin.printLine ""
          Builtin.printLine "Examples:"
          Builtin.printLine "  ls                - List current location"
          Builtin.printLine "  ls /              - List root packages"
          Builtin.printLine "  ls Darklang       - List Darklang package contents"
          Builtin.printLine "  ls ..             - List parent directory"
          { state with lastCommand = "help ls"; output = "ls help displayed" }

        // Completion function
        let lsComplete (state: Types.AppState) (args: List<String>) : List<String> =
          Completion.noArgsCompletion state args