module Darklang.Cli.Tests


type TestResult =
  | Pass
  | Fail of message: String


let runWithCommand (args: List<String>): String =
  let escapedArgs =
    args
    |> Stdlib.List.map (fun arg ->
      if Stdlib.String.contains arg " " ||
          Stdlib.String.contains arg "|" ||
          Stdlib.String.contains arg "\""
      then
        let escapedArg = Stdlib.String.replaceAll arg "\"" "\\\""
        $"'{escapedArg}'"
      else arg)

  let argsString = Stdlib.String.join escapedArgs " "
  let command = $"./scripts/run-cli {argsString}"
  let result = Stdlib.Cli.Unix.executeInDirectoryWithOutput "." command

  if result.exitCode == 0L then
    Stdlib.String.trim result.stdout
  else
    $"ERROR: {result.stderr}"


let testHelpCommand (): TestResult =
  let output = runWithCommand ["help"]

  if Stdlib.String.contains output "Available commands:" &&
      Stdlib.String.contains output "help" &&
      Stdlib.String.contains output "version" &&
      Stdlib.String.contains output "status" then
      TestResult.Pass
  else
    TestResult.Fail "Expected help text with available commands"


let testVersionCommand (): TestResult =
  let output = runWithCommand ["version"]
  if Stdlib.String.contains output "Darklang CLI" &&
      Stdlib.String.contains output "alpha-" then
      TestResult.Pass
  else
    TestResult.Fail "Expected version string with 'Darklang CLI alpha-'"


let testStatusCommand (): TestResult =
  let output = runWithCommand ["status"]
  if Stdlib.String.contains output "Darklang CLI" &&
      Stdlib.String.contains output "Location:" &&
      Stdlib.String.contains output "Mode:" then
    TestResult.Pass
  else
    TestResult.Fail "Expected status output with CLI info, Location, and Mode"


let testRunBoolAnd (): TestResult =
  let output = runWithCommand ["run"; "@Stdlib.Bool.and true false"]
  if output == "false" then
    TestResult.Pass
  else
    TestResult.Fail $"Expected 'false', got '{output}'"


let testRunInt64Add (): TestResult =
  let output = runWithCommand ["run"; "@Stdlib.Int64.add 5L 3L"]
  if output == "8" then
    TestResult.Pass
  else
    TestResult.Fail $"Expected '8', got '{output}'"


let testEvalStringLength (): TestResult =
  let output = runWithCommand ["eval"; "Stdlib.String.length \"hello\""]
  if output == "5" then
    TestResult.Pass
  else
    TestResult.Fail $"Expected '5', got '{output}'"


let testEvalListLength (): TestResult =
  let output = runWithCommand ["eval"; "[1L; 2L; 3L] |> Stdlib.List.length"]
  if output == "3" then
    TestResult.Pass
  else
    TestResult.Fail $"Expected '3', got '{output}'"


let testListFunctions (): TestResult =
  let output = runWithCommand ["ls"; "Stdlib.List"]
  if Stdlib.String.contains output "Functions" &&
      Stdlib.String.contains output "head" then
      TestResult.Pass
  else
    TestResult.Fail "Expected directory listing with functions"


let testViewFunction (): TestResult =
  let output = runWithCommand ["view"; "Stdlib.List.head"]
  Builtin.debug "output" output
  if Stdlib.String.contains output "head"
    && Stdlib.String.contains output "Option"
    && Stdlib.String.contains output "->"
  then
      TestResult.Pass
  else
    TestResult.Fail "Expected function signature for List.head"


let testListTypes (): TestResult =
  let output = runWithCommand ["ls"; "Stdlib.Option"]
  if Stdlib.String.contains output "Types" &&
      Stdlib.String.contains output "Option" then
      TestResult.Pass
  else
    TestResult.Fail "Expected directory listing with types"


let testHelpForRun (): TestResult =
  let output = runWithCommand ["help"; "run"]
  if Stdlib.String.contains output "run" &&
      (Stdlib.String.contains output "function" || Stdlib.String.contains output "execute") then
      TestResult.Pass
  else
    TestResult.Fail "Expected help text for 'run' command"


let testHelpForLs (): TestResult =
  let output = runWithCommand ["help"; "ls"]
  if Stdlib.String.contains output "ls" &&
      (Stdlib.String.contains output "list" || Stdlib.String.contains output "List") then
      TestResult.Pass
  else
    TestResult.Fail "Expected help text for 'ls' command"


let testEvalSimpleExpression (): TestResult =
  let output = runWithCommand ["eval"; "2L + 3L"]
  if output == "5" then
    TestResult.Pass
  else
    TestResult.Fail $"Expected '5', got '{output}'"


let testEvalStringExpression (): TestResult =
  let output = runWithCommand ["eval"; "\"hello\" ++ \"world\""]
  if output == "helloworld" then
    TestResult.Pass
  else
    TestResult.Fail $"Expected 'helloworld', got '{output}'"


type TestFunction = Unit -> TestResult

let allTests (): List<String * TestFunction> =
  [ ("Help", fun () -> testHelpCommand ())
    ("Version", fun () -> testVersionCommand ())
    ("Status", fun () -> testStatusCommand ())

    ("Run Bool.and", fun () -> testRunBoolAnd ())
    ("Run Int64.add", fun () -> testRunInt64Add ())

    ("Eval String Length", fun () -> testEvalStringLength ())
    ("Eval List Length", fun () -> testEvalListLength ())

    ("List Functions", fun () -> testListFunctions ())
    ("View Function", fun () -> testViewFunction ())
    ("List Types", fun () -> testListTypes ())

    ("Help for Run", fun () -> testHelpForRun ())
    ("Help for Ls", fun () -> testHelpForLs ())

    ("Eval Simple Expression", fun () -> testEvalSimpleExpression ())
    ("Eval String Expression", fun () -> testEvalStringExpression ())
  ]

type TestSummary =
  { totalTests: Int64
    passedTests: Int64
    failedTests: Int64
    failedTestNames: List<String> }

// Sequential test execution - proven to be ~30-50% faster than parallel for CLI tests
// due to process startup overhead and resource contention
let runAllTests (): Int64 =
  let tests = allTests ()

  Stdlib.printLine ""
  Stdlib.printLine "Darklang CLI Tests"
  Stdlib.printLine "=================="

  let initialSummary =
    TestSummary
      { totalTests = 0L
        passedTests = 0L
        failedTests = 0L
        failedTestNames = [] }

  let finalSummary =
    tests
    |> Stdlib.List.fold initialSummary (fun summary (name, testFn) ->
      Stdlib.printLine ""
      Stdlib.printLine $"Running: {name} ..."

      let newSummary =
        { summary with totalTests = summary.totalTests + 1L }

      match testFn () with
      | Pass ->
        Stdlib.printLine $"âœ“ PASS - {name}"
        { newSummary with passedTests = newSummary.passedTests + 1L }
      | Fail message ->
        Stdlib.printLine $"âœ— FAIL - {name}"
        Stdlib.printLine $"  Reason: {message}"
        { newSummary with
            failedTests = newSummary.failedTests + 1L
            failedTestNames = Stdlib.List.push newSummary.failedTestNames name })

  Stdlib.printLine ""
  Stdlib.printLine "ðŸ“Š Test Results Summary"
  Stdlib.printLine "======================"
  Stdlib.printLine $"Total tests:  {Stdlib.Int64.toString finalSummary.totalTests}"
  Stdlib.printLine $"Passed:       {Stdlib.Int64.toString finalSummary.passedTests}"
  Stdlib.printLine $"Failed:       {Stdlib.Int64.toString finalSummary.failedTests}"

  if finalSummary.failedTests == 0L then
    Stdlib.printLine "ðŸŽ‰ All tests passed!"
    0L
  else
    Stdlib.printLine "ðŸš¨ Some tests failed!"
    if Stdlib.Bool.not (Stdlib.List.isEmpty finalSummary.failedTestNames) then
      Stdlib.printLine "Failed tests:"
      finalSummary.failedTestNames
      |> Stdlib.List.iter (fun testName ->
        Stdlib.printLine $"  âœ— {testName}")
    1L