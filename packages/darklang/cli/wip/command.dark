// Note: eventually, some commands might be things _besides_ user prompts
// (based on a timer, or async activity happening, or file system watcher, etc.)
module Command = 
	type Argument =
		{ name: String
		  type: string
		  required: Bool
		  defaultValue: Option<String> }

	// which to use -- above or below?
	
	type Argument = 
	  | Positional of name: String * description: String
	  | Named of short: String * long: String * description: String * isFlag: Bool
	
	
	type Example = 
	  { usage: String; description: String }


	type CommandDetails = 
	  { name: String
	  	description: String
	    arguments: List<Argument> 
	    help: String
	    parent: Uuid
	    //subcommands: List<Command> // or parent() and children() ?
	    example: List<Example>
		execute: List<String> -> Unit }


	type GeneralCommand = 
		| Status // if in the middle of something, will tell you
		| Quit

	// available when in an 'app'
	type AppCommand = 
		| GoToApp of appID: Uuid
		| GoToHttpHandlers of appID: Uuid
		| GoToKVs of appID: Uuid



	type AICommand =
		| Prompt
		| Chat
		| Assist // chat w/ bot that knows dark, available commands, and _helps you_
		| Listen
			//`listen` command -> listen to audio until you [stop somehow]
			//(say "stop listening"; hit some button"; etc)

	type NavCommand = 
		| GoToApp of appID: Uuid
		| ChangeDirectory
		| ListStuff
		| GoBack
		| Tree // alias 'matter'

	type AccountCommand = 
		| ShowAccountStatus
		| StartLogin
		| EnterUsernameAndPassword // TODO: collect
		| LogOut

	type LocalInstallCommand = 
		| ShowInstallInfo
		| Install // aliases "init", "setup"
		| Config
		| Uninstall

	type ConfigCommand = 
		| GoToConfig
		// TODO: show specific config values, adjust them, etc

	type MatterCommand = 
		| ShowDependencies
			// | `dependencies` and the other-direction equivalent (`usages`) should be available for types, fns, etc.
		| ShowUsages
		| Let
			// - let x = 1 places it in current context, but it can be moved _easily_ before commit
			//		in the REPL, if you type `let x =` without the RHS, it opens a dialog for you to fill in after?
			//or `let x = [1]`, and you step through the different 'fillable' boxes like that?
			//(you _could_ just type `let`, and have an interactive thing collect the name/LHS, in addition to the RHS)


	type DevToolsCommand = 
		| LanguageServer // "lang-server", alias ["lsp]. could accept a name/id
		

	type Command = 
		| General of GeneralCommand
		| App of AppCommand
		| Config of ConfigCommand
		| Matter of MatterCommand
		| DevTools of DevToolsCommand


	let cmdDetails (cmd: Command): CommandDetails = 
	  match cmd with
	  | General(Quit) -> 
		  CommandDetails
		    { name = "quit"
			  aliases = ["q"]
			  // arg-parser, with handle<> that respects the thing we parse into (?)
			  handle = _ -> [ Msg.Quit ] }
			  
	  | General(Status) ->
		  CommandDetails
			{ name = "status"
			  aliases = []
			  handle = _ -> [ Msg.ShowStatus ] }