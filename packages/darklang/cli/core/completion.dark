module Darklang =
  module Cli =
    module Completion =
      // Types for structured input parsing
      type ParsedInput =
        { commandName: String
          args: List<String>
          isCompletingCommand: Bool }

      // Parse an input string into structured form
      let parseInput (input: String) : ParsedInput =
        let trimmed = Stdlib.String.trim input

        if Stdlib.String.isEmpty trimmed then
          ParsedInput { commandName = ""; args = []; isCompletingCommand = true }
        else
          let words = Stdlib.String.split trimmed " "
          match words with
          | [] -> ParsedInput { commandName = ""; args = []; isCompletingCommand = true }
          | [command] -> ParsedInput { commandName = command; args = []; isCompletingCommand = true }
          | command :: args -> ParsedInput { commandName = command; args = args; isCompletingCommand = false }

      // Get the partial string being completed
      let getPartialCompletion (parsed: ParsedInput) : String =
        if parsed.isCompletingCommand then
          parsed.commandName
        else
          match Stdlib.List.last parsed.args with
          | Some lastArg -> lastArg
          | None -> ""

      // Build completed command string from parsed input and completion
      let buildCompletedCommand (parsed: ParsedInput) (completion: String) : String =
        if parsed.isCompletingCommand then
          completion
        else
          // Replace last argument with completion
          let argsWithoutLast = Stdlib.List.dropLast parsed.args
          let newArgs = Stdlib.List.append argsWithoutLast [completion]
          let fullCommand = Stdlib.List.append [parsed.commandName] newArgs
          Stdlib.String.join fullCommand " "

      // Generate completion hint from partial and completions
      let getHintFromCompletions (partial: String) (completions: List<String>) : String =
        match completions with
        | [] -> ""
        | [singleCompletion] ->
          if Stdlib.String.startsWith singleCompletion partial then
            Stdlib.String.dropFirst singleCompletion (Stdlib.String.length partial)
          else
            ""
        | multiple ->
          let commonPrefix = Registry.findCommonPrefix multiple
          if Stdlib.String.startsWith commonPrefix partial && Stdlib.String.length commonPrefix > Stdlib.String.length partial then
            Stdlib.String.dropFirst commonPrefix (Stdlib.String.length partial)
          else
            ""

      let noArgsCompletion (_state: AppState) (_args: List<String>) : List<String> =
        []

      // Standard completion for commands that complete with other command names
      // (right now, just `help`)
      let commandNamesCompletion (_state: AppState) (args: List<String>) : List<String> =
        match args with
        | [] ->
          // Suggest all command names and aliases
          let commands = Registry.allCommands ()
          let commandNames = Stdlib.List.map commands (fun cmd -> cmd.name)
          let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
          Stdlib.List.append commandNames allAliases
        | [partialArg] ->
          // Filter by partial match
          let commands = Registry.allCommands ()
          let commandNames = Stdlib.List.map commands (fun cmd -> cmd.name)
          let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
          let allOptions = Stdlib.List.append commandNames allAliases
          Stdlib.List.filter allOptions (fun name -> Stdlib.String.startsWith name partialArg)
        | _ ->
          // Only complete first argument
          []