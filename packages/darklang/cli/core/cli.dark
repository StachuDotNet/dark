module Darklang =
  module Cli =
    let runInteractiveLoop (state: AppState) : Int64 =
      if state.isExiting then
        0L
      else
        // Only display prompt when in PromptMode, not in TreeNavigationMode
        match state.uiMode with
        | PromptMode ->
          // Display prompt and current input with completion hints
          if state.needsFullRedraw then
            Builtin.printLine (View.formatPrompt ())
          else
            // Move cursor to beginning of line only, avoid clearing unless necessary
            Builtin.print Colors.carriageReturn
          Builtin.print (View.formatPromptWithInput state)

        // CLEANUP the specific 'tree' command has bled outside of its space...
        // we should abstract this to something that represents when a command
        // or sub-app "takes over" the rendering
        | TreeNavigationMode _ ->
          // Tree mode handles its own display, don't show prompt
          ()

        // Read keystroke input
        let keyInput = Stdlib.Cli.Stdin.readKey ()
        let keyPressedMsg = Msg.KeyPressed (keyInput.key, keyInput.modifiers, Stdlib.Option.Option.Some keyInput.keyChar)
        let newState = Update.updateAppState state keyPressedMsg
        runInteractiveLoop newState


    let executeCliCommand (args: List<String>) : Int64 =
      let initialState = initState ()

      match args with
      // If someone runs `dark` without args, start the interactive loop
      | [] ->
        Builtin.printLine (View.formatWelcome ())
        runInteractiveLoop initialState
      // Otherwise, just execute command, print result, and exit
      | _ ->
        let command = args |> Stdlib.String.join " "
        let finalState = Update.processInput initialState command
        0L