module Darklang =
  module Cli =
    module Update =
      let updateAppState (state: AppState) (msg: Msg) : AppState =
        match msg with
        | ProcessInput input ->
          Commands.parseAndExecute state input
        | KeyPressed (key, modifiers, keyChar) ->
          handleKeyInput state key modifiers keyChar
        | Exit ->
          { state with isExiting = true; lastCommand = "exit"; output = "exiting" }

      let handleKeyInput (state: AppState) (key: Stdlib.Cli.Stdin.Key.Key) (modifiers: Stdlib.Cli.Stdin.Modifiers.Modifiers) (keyChar: Stdlib.Option.Option<String>) : AppState =
        match state.uiMode with
        | TreeNavigationMode treeState ->
          // Tree navigation mode key handling
          handleTreeNavigationKeys state treeState key keyChar
        | PromptMode ->
          // Normal command mode key handling
          match key with
          | Enter ->
            // Execute the current command
            if Stdlib.String.isEmpty (Stdlib.String.trim state.mainPrompt) then
              Builtin.printLine ""
              { state with mainPrompt = ""; needsFullRedraw = false; historyIndex = -1L }
            else
              Builtin.printLine ""
              let commandToExecute = Stdlib.String.trim state.mainPrompt
              let newState = Commands.parseAndExecute state commandToExecute
              // Add command to history (avoiding duplicates)
              let updatedHistory =
                if Stdlib.List.isEmpty state.commandHistory || Stdlib.List.head state.commandHistory != Stdlib.Option.Option.Some commandToExecute then
                  Stdlib.List.append [commandToExecute] state.commandHistory
                else
                  state.commandHistory
              { newState with mainPrompt = ""; needsFullRedraw = false; commandHistory = updatedHistory; historyIndex = -1L }
          | Backspace ->
            // Remove last character from prompt
            if Stdlib.String.length state.mainPrompt > 0L then
              let newPrompt = Stdlib.String.dropLast state.mainPrompt 1L
              { state with mainPrompt = newPrompt; historyIndex = -1L }
            else
              state
          | Tab ->
            // Handle tab completion
            let completions = Registry.getCompletions state state.mainPrompt

            match completions with
            | [] ->
              // No completions available
              state
            | [singleCompletion] ->
              // Single completion - auto-complete it
              let parsed = Completion.parseInput state.mainPrompt
              let newPrompt = Completion.buildCompletedCommand parsed singleCompletion
              { state with mainPrompt = newPrompt }
            | multiple ->
              // Multiple completions - show them
              Builtin.printLine ""
              Builtin.printLine (Stdlib.String.join multiple " ")
              { state with needsFullRedraw = true }
          | UpArrow ->
            // Navigate to previous command in history
            if Stdlib.Bool.not (Stdlib.List.isEmpty state.commandHistory) then
              let historyLength = Stdlib.List.length state.commandHistory
              let newIndex =
                if state.historyIndex == -1L then
                  0L  // Start from the most recent command
                else
                  if state.historyIndex < (historyLength - 1L) then
                    state.historyIndex + 1L
                  else
                    state.historyIndex  // Stay at oldest command
              match Stdlib.List.getAt state.commandHistory newIndex with
              | Some command ->
                { state with mainPrompt = command; historyIndex = newIndex; needsFullRedraw = false }
              | None ->
                state
            else
              state
          | DownArrow ->
            // Navigate to next command in history
            if Stdlib.Bool.not (Stdlib.List.isEmpty state.commandHistory) && state.historyIndex >= 0L then
              let newIndex =
                if state.historyIndex > 0L then
                  state.historyIndex - 1L
                else
                  -1L  // Go back to empty prompt
              if newIndex == -1L then
                { state with mainPrompt = ""; historyIndex = newIndex; needsFullRedraw = false }
              else
                match Stdlib.List.getAt state.commandHistory newIndex with
                | Some command ->
                  { state with mainPrompt = command; historyIndex = newIndex; needsFullRedraw = false }
                | None ->
                  state
            else
              state
          | _ ->
            // Add character to prompt
            match keyChar with
            | Some char ->
              let newPrompt = state.mainPrompt ++ char
              { state with mainPrompt = newPrompt; historyIndex = -1L; needsFullRedraw = false }
            | None ->
              state

      // Handle keyboard navigation in tree mode
      let handleTreeNavigationKeys (state: AppState) (treeState: TreeNavState) (key: Stdlib.Cli.Stdin.Key.Key) (keyChar: Stdlib.Option.Option<String>) : AppState =
        match key with
        | UpArrow ->
          // Move selection up
          let totalNodes = Stdlib.List.length treeState.currentNodes
          let newIndex = 
            if treeState.selectedIndex > 0L then
              treeState.selectedIndex - 1L
            else
              totalNodes - 1L  // Wrap to bottom
          
          // Calculate new scroll offset to keep selection visible
          let newScrollOffset = Packages.Tree.calculateScrollOffset newIndex treeState.scrollOffset totalNodes
          
          let newTreeState =
            { treeState with
                selectedIndex = newIndex
                scrollOffset = newScrollOffset }
          let newUiMode = InteractiveUIMode.TreeNavigationMode newTreeState
          let newState =
            { state with
                uiMode = newUiMode
                needsFullRedraw = false }
          Packages.Tree.smartTreeUpdate newState newTreeState false
        | DownArrow ->
          // Move selection down
          let totalNodes = Stdlib.List.length treeState.currentNodes
          let newIndex = 
            if treeState.selectedIndex < (totalNodes - 1L) then
              treeState.selectedIndex + 1L
            else
              0L  // Wrap to top
          
          // Calculate new scroll offset to keep selection visible
          let newScrollOffset = Packages.Tree.calculateScrollOffset newIndex treeState.scrollOffset totalNodes
          
          let newTreeState =
            { treeState with
                selectedIndex = newIndex
                scrollOffset = newScrollOffset }
          let newUiMode = InteractiveUIMode.TreeNavigationMode newTreeState
          let newState =
            { state with
                uiMode = newUiMode
                needsFullRedraw = false }
          Packages.Tree.smartTreeUpdate newState newTreeState false
        | Enter ->
          // Expand/collapse node or view entity
          match Stdlib.List.getAt treeState.currentNodes treeState.selectedIndex with
          | Some selectedNode ->
            match selectedNode.nodeType with
            | ModuleNode ->
              // Toggle expansion for modules
              let newExpandedPaths = 
                if Stdlib.List.``member`` treeState.expandedPaths selectedNode.path then
                  Stdlib.List.filter treeState.expandedPaths (fun path -> path != selectedNode.path)
                else
                  Stdlib.List.append treeState.expandedPaths [selectedNode.path]
              let newTreeState =
                { treeState with
                    expandedPaths = newExpandedPaths }
              let newUiMode = InteractiveUIMode.TreeNavigationMode newTreeState
              let newState =
                { state with
                    uiMode = newUiMode
                    needsFullRedraw = true }
              Packages.Tree.rebuildAndRedrawTree newState newTreeState
            | FunctionNode | TypeNode | ConstantNode ->
              // View entity definition
              Packages.Tree.viewEntityFromTree state selectedNode
            | RootNode ->
              state  // Root nodes don't expand
          | None ->
            state
        | LeftArrow ->
          // Smart collapse: if current is expanded module, collapse it; otherwise collapse parent
          match Stdlib.List.getAt treeState.currentNodes treeState.selectedIndex with
          | Some selectedNode ->
            match selectedNode.nodeType with
            | ModuleNode ->
              if Stdlib.List.``member`` treeState.expandedPaths selectedNode.path then
                // Current module is expanded, collapse it
                let newExpandedPaths = 
                  Stdlib.List.filter treeState.expandedPaths (fun path -> path != selectedNode.path)
                let newTreeState =
                  { treeState with
                      expandedPaths = newExpandedPaths }
                let newUiMode = InteractiveUIMode.TreeNavigationMode newTreeState
                let newState =
                  { state with
                      uiMode = newUiMode
                      needsFullRedraw = true }
                Packages.Tree.rebuildAndRedrawTree newState newTreeState
              else
                // Current module not expanded, collapse parent if it exists
                if selectedNode.depth > 0L then
                  let parentPath = Stdlib.List.dropLast selectedNode.path
                  if Stdlib.List.``member`` treeState.expandedPaths parentPath then
                    let newExpandedPaths = 
                      Stdlib.List.filter treeState.expandedPaths (fun path -> path != parentPath)
                    let newTreeState =
                      { treeState with
                          expandedPaths = newExpandedPaths }
                    let newUiMode = InteractiveUIMode.TreeNavigationMode newTreeState
                    let newState =
                      { state with
                          uiMode = newUiMode
                          needsFullRedraw = true }
                    Packages.Tree.rebuildAndRedrawTree newState newTreeState
                  else
                    state
                else
                  state
            | _ ->
              // Non-module node, collapse parent if it exists
              if selectedNode.depth > 0L then
                let parentPath = Stdlib.List.dropLast selectedNode.path
                if Stdlib.List.``member`` treeState.expandedPaths parentPath then
                  let newExpandedPaths = 
                    Stdlib.List.filter treeState.expandedPaths (fun path -> path != parentPath)
                  let newTreeState =
                    { treeState with
                        expandedPaths = newExpandedPaths }
                  let newUiMode = InteractiveUIMode.TreeNavigationMode newTreeState
                  let newState =
                    { state with
                        uiMode = newUiMode
                        needsFullRedraw = true }
                  Packages.Tree.rebuildAndRedrawTree newState newTreeState
                else
                  state
              else
                state
          | None ->
            state
        | RightArrow ->
          // Expand current node if not expanded
          match Stdlib.List.getAt treeState.currentNodes treeState.selectedIndex with
          | Some selectedNode ->
            match selectedNode.nodeType with
            | ModuleNode ->
              if Stdlib.Bool.not (Stdlib.List.``member`` treeState.expandedPaths selectedNode.path) then
                let newExpandedPaths = 
                  Stdlib.List.append treeState.expandedPaths [selectedNode.path]
                let newTreeState =
                  { treeState with
                      expandedPaths = newExpandedPaths }
                let newUiMode = InteractiveUIMode.TreeNavigationMode newTreeState
                let newState =
                  { state with
                      uiMode = newUiMode
                      needsFullRedraw = true }
                Packages.Tree.rebuildAndRedrawTree newState newTreeState
              else
                state
            | _ ->
              state  // Non-module nodes can't be expanded
          | None ->
            state
        | _ ->
          // Handle 'q' or Escape to exit tree mode
          match keyChar with
          | Some "q" ->
            Builtin.printLine ""
            Builtin.printLine "Exited interactive tree mode"
            { state with
                uiMode = InteractiveUIMode.PromptMode
                needsFullRedraw = true }
          | _ ->
            state  // Ignore other keys

      let processInput (state: AppState) (input: String) : AppState =
        let trimmedInput = Stdlib.String.trim input
        if Stdlib.String.isEmpty trimmedInput then
          state
        else
          let msg = Msg.ProcessInput trimmedInput
          updateAppState state msg

