module Darklang =
  module Cli =
    module Update =
      let updateAppState (state: Types.AppState) (msg: Types.Msg) : Types.AppState =
        match msg with
        | ProcessInput input ->
          Commands.parseAndExecute state input
        | KeyPressed (key, modifiers, keyChar) ->
          handleKeyInput state key modifiers keyChar
        | Exit ->
          Types.AppState { isExiting = true; lastCommand = "exit"; output = "exiting"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      let handleKeyInput (state: Types.AppState) (key: Stdlib.Cli.Stdin.Key.Key) (modifiers: Stdlib.Cli.Stdin.Modifiers.Modifiers) (keyChar: Stdlib.Option.Option<String>) : Types.AppState =
        match key with
        | Enter ->
          // Execute the current command
          if Stdlib.String.isEmpty (Stdlib.String.trim state.mainPrompt) then
            Builtin.printLine ""
            Types.AppState { isExiting = state.isExiting; lastCommand = state.lastCommand; output = state.output; mainPrompt = ""; needsFullRedraw = true; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
          else
            Builtin.printLine ""
            let commandToExecute = Stdlib.String.trim state.mainPrompt
            let newState = Commands.parseAndExecute state commandToExecute
            Types.AppState { isExiting = newState.isExiting; lastCommand = newState.lastCommand; output = newState.output; mainPrompt = ""; needsFullRedraw = true; currentPath = newState.currentPath; pathHistory = newState.pathHistory; viewMode = newState.viewMode }
        | Backspace ->
          // Remove last character from prompt
          if Stdlib.String.length state.mainPrompt > 0L then
            let newPrompt = Stdlib.String.dropLast state.mainPrompt 1L
            Types.AppState { isExiting = state.isExiting; lastCommand = state.lastCommand; output = state.output; mainPrompt = newPrompt; needsFullRedraw = false; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
          else
            state
        | Tab ->
          // Handle tab completion
          let completions = Registry.getCompletions state state.mainPrompt
          
          match completions with
          | [] ->
            // No completions available
            state
          | [singleCompletion] ->
            // Single completion - auto-complete it
            let parsed = Completion.parseInput state.mainPrompt
            let newPrompt = Completion.buildCompletedCommand parsed singleCompletion
            Types.AppState { isExiting = state.isExiting; lastCommand = state.lastCommand; output = state.output; mainPrompt = newPrompt; needsFullRedraw = false; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
          | multiple ->
            // Multiple completions - show them
            Builtin.printLine ""
            Builtin.printLine (Stdlib.String.join multiple " ")
            Types.AppState { isExiting = state.isExiting; lastCommand = state.lastCommand; output = state.output; mainPrompt = state.mainPrompt; needsFullRedraw = true; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
        | _ ->
          // Add character to prompt
          match keyChar with
          | Some char ->
            let newPrompt = state.mainPrompt ++ char
            Types.AppState { isExiting = state.isExiting; lastCommand = state.lastCommand; output = state.output; mainPrompt = newPrompt; needsFullRedraw = false; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
          | None ->
            state

      let processInput (state: Types.AppState) (input: String) : Types.AppState =
        let trimmedInput = Stdlib.String.trim input
        if Stdlib.String.isEmpty trimmedInput then
          state
        else
          let msg = Types.Msg.ProcessInput trimmedInput
          updateAppState state msg