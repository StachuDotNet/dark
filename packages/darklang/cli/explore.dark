module Darklang =
  module Cli =
    module Explore =
      // Package path utilities
      let formatPath (path: Types.PackagePath) : String =
        match path with
        | Root -> "/"
        | Module owner moduleName -> $"/{owner}/{moduleName}"

      let parsePath (pathStr: String) : Types.PackagePath =
        let trimmed = Stdlib.String.trim pathStr
        if trimmed == "/" || Stdlib.String.isEmpty trimmed then
          Types.PackagePath.Root
        else
          let pathToSplit =
            if Stdlib.String.startsWith trimmed "/" then
              Stdlib.String.dropFirst trimmed 1L
            else
              trimmed
          let parts = Stdlib.String.split pathToSplit "/"
          match parts with
          | [owner; moduleName] -> Types.PackagePath.Module owner moduleName
          | [owner] -> Types.PackagePath.Module owner ""
          | _ -> Types.PackagePath.Root

      // CD command - change directory/module
      let executeCD (state: Types.AppState) (args: List<String>) : Types.AppState =
        match args with
        | [] ->
          // No args, show current path
          let currentPathStr = formatPath state.currentPath
          Builtin.printLine $"Current path: {currentPathStr}"
          Types.AppState { isExiting = state.isExiting; lastCommand = "cd"; output = "pwd displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
        | [pathArg] ->
          let newPath =
            if pathArg == ".." then
              // Go back to parent
              match state.currentPath with
              | Root -> Types.PackagePath.Root
              | Module owner moduleName -> Types.PackagePath.Root
            else if pathArg == "/" then
              Types.PackagePath.Root
            else
              parsePath pathArg

          let newHistory = Stdlib.List.append state.pathHistory [state.currentPath]
          let newPathStr = formatPath newPath
          Builtin.printLine $"Changed to: {newPathStr}"

          Types.AppState {
            isExiting = state.isExiting;
            lastCommand = "cd";
            output = $"cd to {newPathStr}";
            mainPrompt = state.mainPrompt;
            needsFullRedraw = true;
            currentPath = newPath;
            pathHistory = newHistory;
            viewMode = state.viewMode
          }
        | _ ->
          Builtin.printLine "Usage: cd [path]"
          Builtin.printLine "  cd /           - Go to root"
          Builtin.printLine "  cd ..          - Go to parent"
          Builtin.printLine "  cd owner/module - Go to module"
          Types.AppState { isExiting = state.isExiting; lastCommand = "cd error"; output = "cd error"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // LS command - list contents
      let executeLS (state: Types.AppState) (args: List<String>) : Types.AppState =
        match state.currentPath with
        | Root ->
          // Get real top-level packages from the package manager
          let query =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = []
                text = ""
                searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
          let searchResults = LanguageTools.PackageManager.Search.search query

          // Extract unique owners from module paths
          let owners =
            match Stdlib.List.head searchResults.submodules with
            | Some moduleList ->
              moduleList
              |> Stdlib.List.filterMap (fun path ->
                match path with
                | owner :: _ -> Stdlib.Option.Option.Some owner
                | [] -> Stdlib.Option.Option.None)
              |> Stdlib.List.unique
              |> Stdlib.List.sort
            | None -> []

          Builtin.printLine "Available packages:"
          owners |> Stdlib.List.iter (fun owner ->
            Builtin.printLine $"  {owner}/")

          if Stdlib.List.isEmpty owners then
            Builtin.printLine "  (No packages found)"
          else
            Builtin.printLine ""
            Builtin.printLine $"Use 'cd <package>' to explore a package"

          Types.AppState { isExiting = state.isExiting; lastCommand = "ls"; output = "ls root"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

        | Module owner moduleName ->
          let currentModule = if Stdlib.String.isEmpty moduleName then [owner] else [owner; moduleName]
          let query =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = currentModule
                text = ""
                searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module
                                LanguageTools.ProgramTypes.Search.EntityType.Type
                                LanguageTools.ProgramTypes.Search.EntityType.Fn
                                LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
          let searchResults = LanguageTools.PackageManager.Search.search query

          let pathStr = formatPath state.currentPath
          Builtin.printLine $"Contents of {pathStr}:"

          // List submodules - only direct children
          match Stdlib.List.head searchResults.submodules with
          | Some moduleList when Stdlib.Bool.not (Stdlib.List.isEmpty moduleList) ->
            Builtin.printLine ""
            Builtin.printLine "  [Submodules]"
            // Filter to only direct children by checking path length
            let expectedLength = (Stdlib.List.length currentModule) + 1L
            moduleList
            |> Stdlib.List.filter (fun path -> 
              Stdlib.List.length path == expectedLength)
            |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
            |> Stdlib.List.unique
            |> Stdlib.List.sort
            |> Stdlib.List.iter (fun name ->
              Builtin.printLine $"    {name}/")
          | _ -> ()

          // Count functions
          let fnCount = Stdlib.List.length searchResults.fns
          if fnCount > 0L then
            Builtin.printLine ""
            Builtin.printLine $"  [Functions] ({fnCount} items)"

          // Count types
          let typeCount = Stdlib.List.length searchResults.types
          if typeCount > 0L then
            Builtin.printLine ""
            Builtin.printLine $"  [Types] ({typeCount} items)"

          // Count constants
          let constCount = Stdlib.List.length searchResults.constants
          if constCount > 0L then
            Builtin.printLine ""
            Builtin.printLine $"  [Constants] ({constCount} items)"

          Builtin.printLine ""
          Builtin.printLine "Use 'view' to see details of functions, types, and constants"

          Types.AppState { isExiting = state.isExiting; lastCommand = "ls"; output = "ls module"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // PWD command - show current path
      let executePWD (state: Types.AppState) (args: List<String>) : Types.AppState =
        let currentPathStr = formatPath state.currentPath
        Builtin.printLine currentPathStr
        Types.AppState { isExiting = state.isExiting; lastCommand = "pwd"; output = "pwd displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // BACK command - navigate back using history
      let executeBACK (state: Types.AppState) (args: List<String>) : Types.AppState =
        match Stdlib.List.last state.pathHistory with
        | Some previousPath ->
          let newHistory = Stdlib.List.dropLast state.pathHistory
          let pathStr = formatPath previousPath
          Builtin.printLine $"Back to: {pathStr}"

          Types.AppState {
            isExiting = state.isExiting;
            lastCommand = "back";
            output = $"back to {pathStr}";
            mainPrompt = state.mainPrompt;
            needsFullRedraw = true;
            currentPath = previousPath;
            pathHistory = newHistory;
            viewMode = state.viewMode
          }
        | None ->
          Builtin.printLine "No previous location in history"
          Types.AppState { isExiting = state.isExiting; lastCommand = "back"; output = "no history"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // Help functions
      let cdHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: cd [path]"
        Builtin.printLine "Navigate to different packages and modules."
        Builtin.printLine ""
        Builtin.printLine "Examples:"
        Builtin.printLine "  cd /                  - Go to root directory"
        Builtin.printLine "  cd ..                 - Go to parent directory"
        Builtin.printLine "  cd darklang/stdlib    - Go to stdlib module"
        Types.AppState { isExiting = state.isExiting; lastCommand = "help cd"; output = "cd help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      let lsHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: ls"
        Builtin.printLine "List contents of the current package or module."
        Builtin.printLine ""
        Builtin.printLine "Shows available packages at root level, or module contents when inside a module."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help ls"; output = "ls help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      let pwdHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: pwd"
        Builtin.printLine "Print the current package path."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help pwd"; output = "pwd help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      let backHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: back"
        Builtin.printLine "Navigate back to the previous location using history."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help back"; output = "back help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // Completion functions
      let cdComplete (state: Types.AppState) (args: List<String>) : List<String> =
        match args with
        | [] ->
          // At root, suggest top-level packages
          match state.currentPath with
          | Root ->
            // Get top-level packages from the package manager
            let query =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = []
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
            let searchResults = LanguageTools.PackageManager.Search.search query

            // Extract unique owners from module paths
            let owners =
              match Stdlib.List.head searchResults.submodules with
              | Some moduleList ->
                moduleList
                |> Stdlib.List.filterMap (fun path ->
                  match path with
                  | owner :: _ -> Stdlib.Option.Option.Some owner
                  | [] -> Stdlib.Option.Option.None)
                |> Stdlib.List.unique
                |> Stdlib.List.sort
              | None -> []

            // Add basic navigation options
            Stdlib.List.append ["/"; ".."] owners
          | Module owner moduleName ->
            // Inside a module, suggest submodules
            let currentModule = if Stdlib.String.isEmpty moduleName then [owner] else [owner; moduleName]
            let query =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = currentModule
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
            let searchResults = LanguageTools.PackageManager.Search.search query

            // Extract submodule names - only direct children
            let submodules =
              match Stdlib.List.head searchResults.submodules with
              | Some moduleList ->
                // Filter to only direct children by checking path length
                let expectedLength = (Stdlib.List.length currentModule) + 1L
                moduleList
                |> Stdlib.List.filter (fun path -> 
                  Stdlib.List.length path == expectedLength)
                |> Stdlib.List.filterMap (fun path ->
                  // Get the last part of the path as the submodule name
                  Stdlib.List.last path)
                |> Stdlib.List.unique
                |> Stdlib.List.sort
              | None -> []

            // Add basic navigation options
            Stdlib.List.append ["/"; ".."] submodules

        | [partialPath] ->
          // Get all available completions
          let allCompletions = cdComplete state []
          let lowerPartial = Stdlib.String.toLowercase partialPath
          // Filter by prefix match
          Stdlib.List.filter allCompletions (fun path ->
            Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
        | _ -> []

      let lsComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

      let pwdComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

      let backComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args