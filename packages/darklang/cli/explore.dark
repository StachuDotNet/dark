module Darklang =
  module Cli =
    module Explore =
      // Package path utilities
      let formatPath (path: Types.PackagePath) : String =
        match path with
        | Root -> "/"
        | Module owner moduleName -> $"/{owner}/{moduleName}"

      let parsePath (pathStr: String) : Types.PackagePath =
        let trimmed = Stdlib.String.trim pathStr
        if trimmed == "/" || Stdlib.String.isEmpty trimmed then
          Types.PackagePath.Root
        else
          let pathToSplit = 
            if Stdlib.String.startsWith trimmed "/" then
              Stdlib.String.dropFirst trimmed 1L
            else
              trimmed
          let parts = Stdlib.String.split pathToSplit "/"
          match parts with
          | [owner; moduleName] -> Types.PackagePath.Module owner moduleName
          | [owner] -> Types.PackagePath.Module owner ""
          | _ -> Types.PackagePath.Root

      // CD command - change directory/module
      let executeCD (state: Types.AppState) (args: List<String>) : Types.AppState =
        match args with
        | [] ->
          // No args, show current path
          let currentPathStr = formatPath state.currentPath
          Builtin.printLine $"Current path: {currentPathStr}"
          Types.AppState { isExiting = state.isExiting; lastCommand = "cd"; output = "pwd displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
        | [pathArg] ->
          let newPath = 
            if pathArg == ".." then
              // Go back to parent
              match state.currentPath with
              | Root -> Types.PackagePath.Root
              | Module owner moduleName -> Types.PackagePath.Root
            else if pathArg == "/" then
              Types.PackagePath.Root
            else
              parsePath pathArg
          
          let newHistory = Stdlib.List.append state.pathHistory [state.currentPath]
          let newPathStr = formatPath newPath
          Builtin.printLine $"Changed to: {newPathStr}"
          
          Types.AppState { 
            isExiting = state.isExiting; 
            lastCommand = "cd"; 
            output = $"cd to {newPathStr}"; 
            mainPrompt = state.mainPrompt; 
            needsFullRedraw = true;
            currentPath = newPath;
            pathHistory = newHistory;
            viewMode = state.viewMode 
          }
        | _ ->
          Builtin.printLine "Usage: cd [path]"
          Builtin.printLine "  cd /           - Go to root"
          Builtin.printLine "  cd ..          - Go to parent"
          Builtin.printLine "  cd owner/module - Go to module"
          Types.AppState { isExiting = state.isExiting; lastCommand = "cd error"; output = "cd error"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // LS command - list contents
      let executeLS (state: Types.AppState) (args: List<String>) : Types.AppState =
        match state.currentPath with
        | Root ->
          Builtin.printLine "Available packages:"
          Builtin.printLine "  darklang/     - Core Dark language packages"
          Builtin.printLine "  stachu/       - User packages"
          Builtin.printLine "  internal/     - Internal packages"
          Builtin.printLine ""
          Builtin.printLine "Use 'cd darklang' to explore core packages"
          Types.AppState { isExiting = state.isExiting; lastCommand = "ls"; output = "ls root"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
        | Module owner moduleName ->
          let pathStr = formatPath state.currentPath
          Builtin.printLine $"Contents of {pathStr}:"
          Builtin.printLine "  [Functions]   - Module functions"
          Builtin.printLine "  [Types]       - Type definitions"  
          Builtin.printLine "  [Constants]   - Module constants"
          Builtin.printLine "  [Submodules]  - Nested modules"
          Builtin.printLine ""
          Builtin.printLine "Use 'view' to explore interactively"
          Types.AppState { isExiting = state.isExiting; lastCommand = "ls"; output = "ls module"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // PWD command - show current path
      let executePWD (state: Types.AppState) (args: List<String>) : Types.AppState =
        let currentPathStr = formatPath state.currentPath
        Builtin.printLine currentPathStr
        Types.AppState { isExiting = state.isExiting; lastCommand = "pwd"; output = "pwd displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // BACK command - navigate back using history
      let executeBACK (state: Types.AppState) (args: List<String>) : Types.AppState =
        match Stdlib.List.last state.pathHistory with
        | Some previousPath ->
          let newHistory = Stdlib.List.dropLast state.pathHistory
          let pathStr = formatPath previousPath
          Builtin.printLine $"Back to: {pathStr}"
          
          Types.AppState { 
            isExiting = state.isExiting; 
            lastCommand = "back"; 
            output = $"back to {pathStr}"; 
            mainPrompt = state.mainPrompt; 
            needsFullRedraw = true;
            currentPath = previousPath;
            pathHistory = newHistory;
            viewMode = state.viewMode 
          }
        | None ->
          Builtin.printLine "No previous location in history"
          Types.AppState { isExiting = state.isExiting; lastCommand = "back"; output = "no history"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // Help functions
      let cdHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: cd [path]"
        Builtin.printLine "Navigate to different packages and modules."
        Builtin.printLine ""
        Builtin.printLine "Examples:"
        Builtin.printLine "  cd /                  - Go to root directory"
        Builtin.printLine "  cd ..                 - Go to parent directory"
        Builtin.printLine "  cd darklang/stdlib    - Go to stdlib module"
        Types.AppState { isExiting = state.isExiting; lastCommand = "help cd"; output = "cd help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      let lsHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: ls"
        Builtin.printLine "List contents of the current package or module."
        Builtin.printLine ""
        Builtin.printLine "Shows available packages at root level, or module contents when inside a module."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help ls"; output = "ls help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      let pwdHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: pwd"
        Builtin.printLine "Print the current package path."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help pwd"; output = "pwd help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      let backHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: back"
        Builtin.printLine "Navigate back to the previous location using history."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help back"; output = "back help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // Completion functions
      let cdComplete (state: Types.AppState) (args: List<String>) : List<String> =
        match args with
        | [] ->
          // Suggest basic navigation paths only
          ["/"; ".."]
        | [partialPath] ->
          // Filter basic navigation paths by partial match
          let basicPaths = ["/"; ".."]
          let lowerPartial = Stdlib.String.toLowercase partialPath
          Stdlib.List.filter basicPaths (fun path -> Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
        | _ -> []

      let lsComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

      let pwdComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

      let backComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args