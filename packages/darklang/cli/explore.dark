module Darklang =
  module Cli =
    module Explore =
      // Package path utilities
      let formatPath (path: Types.PackagePath) : String =
        match path with
        | Root -> "/"
        | Module owner moduleName -> $"/{owner}/{moduleName}"

      let parsePath (pathStr: String) : Types.PackagePath =
        let trimmed = Stdlib.String.trim pathStr
        if trimmed == "/" || Stdlib.String.isEmpty trimmed then
          Types.PackagePath.Root
        else
          let pathToSplit =
            if Stdlib.String.startsWith trimmed "/" then
              Stdlib.String.dropFirst trimmed 1L
            else
              trimmed
          let parts = Stdlib.String.split pathToSplit "/"
          match parts with
          | [owner; moduleName] -> Types.PackagePath.Module owner moduleName
          | [owner] -> Types.PackagePath.Module owner ""
          | _ -> Types.PackagePath.Root

      // CD command - change directory/module
      let executeCD (state: Types.AppState) (args: List<String>) : Types.AppState =
        match args with
        | [] ->
          // No args, show current path
          let currentPathStr = formatPath state.currentPath
          Builtin.printLine $"Current path: {currentPathStr}"
          Types.AppState { isExiting = state.isExiting; lastCommand = "cd"; output = "pwd displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }
        | [pathArg] ->
          let newPath =
            // Handle special navigation patterns
            if pathArg == ".." then
              // Go back to parent
              match state.currentPath with
              | Root -> Types.PackagePath.Root
              | Module owner moduleName -> 
                if Stdlib.String.isEmpty moduleName then
                  // At owner level, go to root
                  Types.PackagePath.Root
                else
                  // At module level, go to owner
                  Types.PackagePath.Module owner ""
            else if pathArg == "../.." then
              // Go back two levels - always to root in our simple model
              Types.PackagePath.Root
            else if pathArg == "/" then
              Types.PackagePath.Root
            else if Stdlib.String.startsWith pathArg "/" then
              // Absolute path
              parsePath pathArg
            else if Stdlib.String.startsWith pathArg "../" then
              // Relative path starting with ../
              // Go up one level first, then navigate
              let afterDotDot = Stdlib.String.dropFirst pathArg 3L
              match state.currentPath with
              | Root -> parsePath afterDotDot
              | Module owner moduleName ->
                if Stdlib.String.isEmpty moduleName then
                  // At owner level, go to root then navigate
                  parsePath afterDotDot
                else
                  // At module level, go to owner then navigate
                  if Stdlib.String.isEmpty afterDotDot then
                    Types.PackagePath.Module owner ""
                  else
                    Types.PackagePath.Module owner afterDotDot
            else
              // Regular relative path - append to current path
              match state.currentPath with
              | Root -> 
                // From root, just parse as normal
                parsePath pathArg
              | Module owner moduleName ->
                // From inside a module, append the new segment
                if Stdlib.String.isEmpty moduleName then
                  // We're at owner level (e.g., /Darklang)
                  Types.PackagePath.Module owner pathArg
                else
                  // We're deeper, but our simple model only supports owner/module
                  // For now, just navigate to owner/pathArg
                  Types.PackagePath.Module owner pathArg

          let newHistory = Stdlib.List.append state.pathHistory [state.currentPath]
          let newPathStr = formatPath newPath
          Builtin.printLine $"Changed to: {newPathStr}"

          Types.AppState {
            isExiting = state.isExiting;
            lastCommand = "cd";
            output = $"cd to {newPathStr}";
            mainPrompt = state.mainPrompt;
            needsFullRedraw = true;
            currentPath = newPath;
            pathHistory = newHistory;
            viewMode = state.viewMode
          }
        | _ ->
          Builtin.printLine "Usage: cd [path]"
          Builtin.printLine "  cd /           - Go to root"
          Builtin.printLine "  cd ..          - Go to parent"
          Builtin.printLine "  cd owner/module - Go to module"
          Types.AppState { isExiting = state.isExiting; lastCommand = "cd error"; output = "cd error"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // LS command - list contents
      let executeLS (state: Types.AppState) (args: List<String>) : Types.AppState =
        // Determine which path to list
        let pathToList = 
          match args with
          | [] -> state.currentPath  // No args, list current location
          | [pathArg] -> 
            // Parse the argument to get the path to list
            if pathArg == "/" then
              Types.PackagePath.Root
            else if pathArg == ".." then
              match state.currentPath with
              | Root -> Types.PackagePath.Root
              | Module owner moduleName -> Types.PackagePath.Root
            else
              parsePath pathArg
          | _ -> state.currentPath  // Multiple args, just use current
        
        match pathToList with
        | Root ->
          // Get real top-level packages from the package manager
          let query =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = []
                text = ""
                searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
          let searchResults = LanguageTools.PackageManager.Search.search query

          // Extract unique owners from module paths
          let owners =
            match Stdlib.List.head searchResults.submodules with
            | Some moduleList ->
              moduleList
              |> Stdlib.List.filterMap (fun path ->
                match path with
                | owner :: _ -> Stdlib.Option.Option.Some owner
                | [] -> Stdlib.Option.Option.None)
              |> Stdlib.List.unique
              |> Stdlib.List.sort
            | None -> []

          Builtin.printLine "Available packages:"
          owners |> Stdlib.List.iter (fun owner ->
            Builtin.printLine $"  {owner}/")

          if Stdlib.List.isEmpty owners then
            Builtin.printLine "  (No packages found)"
          else
            Builtin.printLine ""
            Builtin.printLine $"Use 'cd <package>' to explore a package"

          Types.AppState { isExiting = state.isExiting; lastCommand = "ls"; output = "ls root"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

        | Module owner moduleName ->
          let currentModule = if Stdlib.String.isEmpty moduleName then [owner] else [owner; moduleName]
          let query =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = currentModule
                text = ""
                searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module
                                LanguageTools.ProgramTypes.Search.EntityType.Type
                                LanguageTools.ProgramTypes.Search.EntityType.Fn
                                LanguageTools.ProgramTypes.Search.EntityType.Constant ] }
          let searchResults = LanguageTools.PackageManager.Search.search query

          let pathStr = formatPath pathToList
          Builtin.printLine $"Contents of {pathStr}:"

          // List submodules - only direct children
          match Stdlib.List.head searchResults.submodules with
          | Some moduleList when Stdlib.Bool.not (Stdlib.List.isEmpty moduleList) ->
            Builtin.printLine ""
            Builtin.printLine "  [Submodules]"
            // Filter to only direct children by checking path length
            let expectedLength = (Stdlib.List.length currentModule) + 1L
            moduleList
            |> Stdlib.List.filter (fun path -> 
              Stdlib.List.length path == expectedLength)
            |> Stdlib.List.filterMap (fun path -> Stdlib.List.last path)
            |> Stdlib.List.unique
            |> Stdlib.List.sort
            |> Stdlib.List.iter (fun name ->
              Builtin.printLine $"    {name}/")
          | _ -> ()

          // Count functions
          let fnCount = Stdlib.List.length searchResults.fns
          if fnCount > 0L then
            Builtin.printLine ""
            Builtin.printLine $"  [Functions] ({Stdlib.Int64.toString fnCount} items)"

          // Count types
          let typeCount = Stdlib.List.length searchResults.types
          if typeCount > 0L then
            Builtin.printLine ""
            Builtin.printLine $"  [Types] ({Stdlib.Int64.toString typeCount} items)"

          // Count constants
          let constCount = Stdlib.List.length searchResults.constants
          if constCount > 0L then
            Builtin.printLine ""
            Builtin.printLine $"  [Constants] ({Stdlib.Int64.toString constCount} items)"

          Builtin.printLine ""
          Builtin.printLine "Use 'view' to see details of functions, types, and constants"

          Types.AppState { isExiting = state.isExiting; lastCommand = "ls"; output = "ls module"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // PWD command - show current path
      let executePWD (state: Types.AppState) (args: List<String>) : Types.AppState =
        let currentPathStr = formatPath state.currentPath
        Builtin.printLine currentPathStr
        Types.AppState { isExiting = state.isExiting; lastCommand = "pwd"; output = "pwd displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // BACK command - navigate back using history
      let executeBACK (state: Types.AppState) (args: List<String>) : Types.AppState =
        match Stdlib.List.last state.pathHistory with
        | Some previousPath ->
          let newHistory = Stdlib.List.dropLast state.pathHistory
          let pathStr = formatPath previousPath
          Builtin.printLine $"Back to: {pathStr}"

          Types.AppState {
            isExiting = state.isExiting;
            lastCommand = "back";
            output = $"back to {pathStr}";
            mainPrompt = state.mainPrompt;
            needsFullRedraw = true;
            currentPath = previousPath;
            pathHistory = newHistory;
            viewMode = state.viewMode
          }
        | None ->
          Builtin.printLine "No previous location in history"
          Types.AppState { isExiting = state.isExiting; lastCommand = "back"; output = "no history"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // Help functions
      let cdHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: cd [path]"
        Builtin.printLine "Navigate to different packages and modules."
        Builtin.printLine ""
        Builtin.printLine "Examples:"
        Builtin.printLine "  cd /                  - Go to root directory"
        Builtin.printLine "  cd ..                 - Go to parent directory"
        Builtin.printLine "  cd darklang/stdlib    - Go to stdlib module"
        Types.AppState { isExiting = state.isExiting; lastCommand = "help cd"; output = "cd help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      let lsHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: ls [path]"
        Builtin.printLine "List contents of the current location or specified path."
        Builtin.printLine ""
        Builtin.printLine "Examples:"
        Builtin.printLine "  ls                - List current location"
        Builtin.printLine "  ls /              - List root packages"
        Builtin.printLine "  ls Darklang       - List Darklang package contents"
        Builtin.printLine "  ls ..             - List parent directory"
        Types.AppState { isExiting = state.isExiting; lastCommand = "help ls"; output = "ls help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      let pwdHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: pwd"
        Builtin.printLine "Print the current package path."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help pwd"; output = "pwd help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      let backHelp (state: Types.AppState) : Types.AppState =
        Builtin.printLine "Usage: back"
        Builtin.printLine "Navigate back to the previous location using history."
        Types.AppState { isExiting = state.isExiting; lastCommand = "help back"; output = "back help displayed"; mainPrompt = state.mainPrompt; needsFullRedraw = state.needsFullRedraw; currentPath = state.currentPath; pathHistory = state.pathHistory; viewMode = state.viewMode }

      // Completion functions
      let cdComplete (state: Types.AppState) (args: List<String>) : List<String> =
        match args with
        | [] ->
          // At root, suggest top-level packages
          match state.currentPath with
          | Root ->
            // Get top-level packages from the package manager
            let query =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = []
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
            let searchResults = LanguageTools.PackageManager.Search.search query

            // Extract unique owners from module paths
            let owners =
              match Stdlib.List.head searchResults.submodules with
              | Some moduleList ->
                moduleList
                |> Stdlib.List.filterMap (fun path ->
                  match path with
                  | owner :: _ -> Stdlib.Option.Option.Some owner
                  | [] -> Stdlib.Option.Option.None)
                |> Stdlib.List.unique
                |> Stdlib.List.sort
              | None -> []

            // Add basic navigation options
            Stdlib.List.append ["/"; ".."] owners
          | Module owner moduleName ->
            // Inside a module, suggest submodules
            let currentModule = if Stdlib.String.isEmpty moduleName then [owner] else [owner; moduleName]
            let query =
              LanguageTools.ProgramTypes.Search.SearchQuery
                { currentModule = currentModule
                  text = ""
                  searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                  entityTypes = [ LanguageTools.ProgramTypes.Search.EntityType.Module ] }
            let searchResults = LanguageTools.PackageManager.Search.search query

            // Extract submodule names - only direct children
            let submodules =
              match Stdlib.List.head searchResults.submodules with
              | Some moduleList ->
                // Filter to only direct children by checking path length
                let expectedLength = (Stdlib.List.length currentModule) + 1L
                moduleList
                |> Stdlib.List.filter (fun path -> 
                  Stdlib.List.length path == expectedLength)
                |> Stdlib.List.filterMap (fun path ->
                  // Get the last part of the path as the submodule name
                  Stdlib.List.last path)
                |> Stdlib.List.unique
                |> Stdlib.List.sort
              | None -> []

            // Add basic navigation options
            Stdlib.List.append ["/"; ".."] submodules

        | [partialPath] ->
          // Get all available completions
          let allCompletions = cdComplete state []
          let lowerPartial = Stdlib.String.toLowercase partialPath
          // Filter by prefix match
          Stdlib.List.filter allCompletions (fun path ->
            Stdlib.String.startsWith (Stdlib.String.toLowercase path) lowerPartial)
        | _ -> []

      let lsComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

      let pwdComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args

      let backComplete (state: Types.AppState) (args: List<String>) : List<String> =
        Completion.noArgsCompletion state args