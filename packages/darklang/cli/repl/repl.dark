module Darklang =
  module Cli =
    module REPL =
      // Helper function that processes a list of messages
      let processMessages (state: State) (msgs: List<Msg>) : State =
        match msgs with
        | [] -> state
        | msg :: remainingMsgs ->
            // Process this message
            let (updatedState, newMsgs) = update state msg

            // First process any new messages generated by this update
            let stateAfterNewMsgs =
              if Stdlib.List.isEmpty newMsgs then
                updatedState
              else
                processMessages updatedState newMsgs

            // Then continue with the remaining messages
            processMessages stateAfterNewMsgs remainingMsgs

      let replInternal (state: State): Int64 =
        // Handle rendering based on the interaction mode
        let stateAfterRender =
          match state.interactionMode with
          // In NonInteractive mode, only render when there's a command result
          | NonInteractive ->
            if state.needsFullRedraw then
              Builtin.print (render state)
              { state with needsFullRedraw = false }
            else
              state

          // In Regular mode, don't clear the screen, just print the prompt
          | Regular ->
            if state.needsFullRedraw then
              // For command results, print the full render
              Builtin.print (render state)
              { state with needsFullRedraw = false }
            else
              // For regular key input, just update the prompt line in-place
              // Clear the current prompt line and reprint it
              Builtin.print "\r\u001b[K"
              Builtin.print (renderPromptOnly state)
              state

          // In RefreshScreen mode, clear the screen and redraw everything
          | RefreshScreen ->
            if state.needsFullRedraw then
              Builtin.stdoutClear()
              Builtin.print (render state)
              { state with needsFullRedraw = false }
            else
              // For regular key input, just update the prompt line in-place
              Builtin.print "\r\u001b[K"
              Builtin.print (renderPromptOnly state)
              state

        let keyRead = Stdlib.Cli.Stdin.readKey ()
        let msg = Msg.KeyPressed(keyRead.key, keyRead.modifiers, keyRead.keyChar)
        let (newState, messages) = update stateAfterRender msg

        // Process all messages
        let finalState = processMessages newState messages

        // Check if we should exit
        if keyRead.key == Stdlib.Cli.Stdin.Key.Key.Escape || finalState.isExiting then
          0L
        else
          // Continue the REPL loop with the updated state
          replInternal finalState

      /// Starts the REPL with the initial state
      let repl () : Int64 =
        let state, initialMsgs = init ()

        // Use the same message processing for initialization
        replInternal state
