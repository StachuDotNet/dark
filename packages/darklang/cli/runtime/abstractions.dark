module Darklang.CLI.Runtime

/// Screen control utilities for terminal manipulation
module Screen =
  let clear () : Unit =
    Stdlib.print "\u001b[2J\u001b[H"

  let clearLine () : Unit =
    Stdlib.print "\u001b[2K\r"

  let moveCursor (x: Int64) (y: Int64) : Unit =
    Stdlib.print ("\u001b[" ++ Stdlib.Int64.toString y ++ ";" ++ Stdlib.Int64.toString x ++ "H")

  let saveCursor () : Unit =
    Stdlib.print "\u001b[s"

  let restoreCursor () : Unit =
    Stdlib.print "\u001b[u"

  let hideCursor () : Unit =
    Stdlib.print "\u001b[?25l"

  let showCursor () : Unit =
    Stdlib.print "\u001b[?25h"

  let getSize () : (Int64 * Int64) =
    (Stdlib.Cli.Terminal.getWidth (), Stdlib.Cli.Terminal.getHeight ())


/// Interactive input utilities
module Input =
  type InputResult = { text: String; cancelled: Bool }

  let readLineLoop (current: String) : InputResult =
    let key = Stdlib.Cli.Stdin.readKey ()
    match key.key with
    | Enter -> InputResult { text = current; cancelled = false }
    | Escape -> InputResult { text = ""; cancelled = true }
    | Backspace ->
        if Stdlib.String.length current > 0L then
          let newText = Stdlib.String.slice current 0L (Stdlib.String.length current - 1L)
          Stdlib.print "\b \b"
          readLineLoop newText
        else
          readLineLoop current
    | _ ->
        if key.keyChar != "" then
          Stdlib.print key.keyChar
          readLineLoop (current ++ key.keyChar)
        else
          readLineLoop current

  let readLine (prompt: String) : InputResult =
    Stdlib.print prompt
    readLineLoop ""

  let readPasswordLoop (current: String) : InputResult =
    let key = Stdlib.Cli.Stdin.readKey ()
    match key.key with
    | Enter -> InputResult { text = current; cancelled = false }
    | Escape -> InputResult { text = ""; cancelled = true }
    | Backspace ->
        if Stdlib.String.length current > 0L then
          let newText = Stdlib.String.slice current 0L (Stdlib.String.length current - 1L)
          Stdlib.print "\b \b"
          readPasswordLoop newText
        else
          readPasswordLoop current
    | _ ->
        if key.keyChar != "" then
          Stdlib.print "*"
          readPasswordLoop (current ++ key.keyChar)
        else
          readPasswordLoop current

  let readPassword (prompt: String) : InputResult =
    Stdlib.print prompt
    readPasswordLoop ""

  let confirm (message: String) : Bool =
    Stdlib.print (message ++ " (y/N): ")
    let key = Stdlib.Cli.Stdin.readKey ()
    if key.keyChar == "y" || key.keyChar == "Y" then
      Stdlib.printLine "y"
      true
    else
      Stdlib.printLine "n"
      false


/// Live progress bar that renders directly to terminal
module LiveProgress =
  type ProgressBar = { current: Int64; total: Int64; width: Int64; message: String }

  let create (total: Int64) (width: Int64) (message: String) : ProgressBar =
    ProgressBar { current = 0L; total = total; width = width; message = message }

  let update (bar: ProgressBar) (current: Int64) : ProgressBar =
    ProgressBar { bar with current = current }

  let render (bar: ProgressBar) : Unit =
    let percentage = if bar.total == 0L then 0L else Stdlib.Int64.divide (bar.current * 100L) bar.total
    let filled = if bar.total == 0L then 0L else Stdlib.Int64.divide (bar.current * bar.width) bar.total
    let empty = bar.width - filled

    let progressStr = "[" ++ Stdlib.String.repeat "█" filled ++ Stdlib.String.repeat "░" empty ++ "]"
    let statusStr = " " ++ Stdlib.Int64.toString bar.current ++ "/" ++ Stdlib.Int64.toString bar.total ++ " (" ++ Stdlib.Int64.toString percentage ++ "%)"

    Screen.clearLine ()
    Stdlib.print (bar.message ++ " " ++ progressStr ++ statusStr)

  let finish (bar: ProgressBar) : Unit =
    render (update bar bar.total)
    Stdlib.printLine ""


/// Live animated spinner that renders directly to terminal
module LiveSpinner =
  type Spinner = { frames: List<String>; current: Int64; message: String }

  let create (message: String) : Spinner =
    Spinner { frames = ["⠋"; "⠙"; "⠹"; "⠸"; "⠼"; "⠴"; "⠦"; "⠧"; "⠇"; "⠏"]; current = 0L; message = message }

  let next (spinner: Spinner) : Spinner =
    let frameCount = Stdlib.List.length spinner.frames
    let newCurrent =
      match Stdlib.Int64.remainder (spinner.current + 1L) frameCount with
      | Ok idx -> idx
      | Error _ -> 0L
    Spinner { spinner with current = newCurrent }

  let render (spinner: Spinner) : Unit =
    match Stdlib.List.getAt spinner.frames spinner.current with
    | Some frame ->
        Screen.clearLine ()
        Stdlib.print (frame ++ " " ++ spinner.message)
    | None -> ()

  let stop (spinner: Spinner) (finalMessage: String) : Unit =
    Screen.clearLine ()
    Stdlib.printLine ("✓ " ++ finalMessage)


/// Interactive menu with keyboard navigation
module InteractiveMenu =
  type MenuItem = { label: String; value: String; enabled: Bool }
  type MenuResult = { selectedValue: String; cancelled: Bool }

  let menuLoop (title: String) (items: List<MenuItem>) (selectedIndex: Int64) : MenuResult =
    Screen.clear ()
    Stdlib.printLine (UI.Core.Rendering.bold title)
    Stdlib.printLine ""

    items
    |> Stdlib.List.indexedMap (fun i item ->
      let marker = if i == selectedIndex then "▶ " else "  "
      let text = if item.enabled then item.label else UI.Core.Rendering.dim item.label
      let display =
        if i == selectedIndex then
          UI.Core.Rendering.bold (UI.Core.Rendering.colorize UI.Core.Types.Color.Info text)
        else
          text
      Stdlib.printLine (marker ++ display))

    Stdlib.printLine ""
    Stdlib.printLine (UI.Core.Rendering.dim "Use ↑/↓ to navigate, Enter to select, Esc to cancel")

    let key = Stdlib.Cli.Stdin.readKey ()
    match key.key with
    | UpArrow ->
        let newIndex = if selectedIndex > 0L then selectedIndex - 1L else Stdlib.List.length items - 1L
        menuLoop title items newIndex
    | DownArrow ->
        let newIndex = if selectedIndex < Stdlib.List.length items - 1L then selectedIndex + 1L else 0L
        menuLoop title items newIndex
    | Enter ->
        match Stdlib.List.getAt items selectedIndex with
        | Some item ->
            if item.enabled then
              MenuResult { selectedValue = item.value; cancelled = false }
            else
              menuLoop title items selectedIndex
        | None -> menuLoop title items selectedIndex
    | Escape ->
        MenuResult { selectedValue = ""; cancelled = true }
    | _ -> menuLoop title items selectedIndex

  let show (title: String) (items: List<MenuItem>) : MenuResult =
    menuLoop title items 0L


/// Command line argument parsing
module Args =
  type ArgValue =
    | StringValue of String
    | IntValue of Int64
    | BoolValue of Bool

  type ParsedArgs = List<(String * ArgValue)>

  let parseArgsLoop (remaining: List<String>) (result: ParsedArgs) : ParsedArgs =
    match remaining with
    | [] -> result
    | flag :: value :: rest when Stdlib.String.startsWith flag "--" ->
        let key = Stdlib.String.dropFirst flag 2L
        let parsedValue =
          if value == "true" then
            ArgValue.BoolValue true
          else if value == "false" then
            ArgValue.BoolValue false
          else
            match Stdlib.Int64.parse value with
            | Ok intVal -> ArgValue.IntValue intVal
            | Error _ -> ArgValue.StringValue value
        parseArgsLoop rest (Stdlib.List.append result [(key, parsedValue)])
    | flag :: rest when Stdlib.String.startsWith flag "--" ->
        let key = Stdlib.String.dropFirst flag 2L
        parseArgsLoop rest (Stdlib.List.append result [(key, ArgValue.BoolValue true)])
    | _ :: rest ->
        parseArgsLoop rest result

  let parse (args: List<String>) : ParsedArgs =
    parseArgsLoop args []

  let getString (args: ParsedArgs) (key: String) (defaultValue: String) : String =
    match Stdlib.List.findFirst args (fun (k, _) -> k == key) with
    | Some (_, StringValue value) -> value
    | _ -> defaultValue

  let getInt (args: ParsedArgs) (key: String) (defaultValue: Int64) : Int64 =
    match Stdlib.List.findFirst args (fun (k, _) -> k == key) with
    | Some (_, IntValue value) -> value
    | _ -> defaultValue

  let getBool (args: ParsedArgs) (key: String) (defaultValue: Bool) : Bool =
    match Stdlib.List.findFirst args (fun (k, _) -> k == key) with
    | Some (_, BoolValue value) -> value
    | _ -> defaultValue
