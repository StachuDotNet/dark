module Darklang =
  module LanguageTools =
    module PrettyPrinter =
      let packageModule (m: ProgramTypes.Packages.Module) : String =
        let headerPart = $"module {m.name} =\n"

        let typesPart =
          match m.types with
          | [] -> Stdlib.Option.Option.None
          | types ->
            m.types
            |> Stdlib.List.map (fun t -> PrettyPrinter.ProgramTypes.packageType t)
            |> Stdlib.String.join "\n\n"
            |> Stdlib.Option.Option.Some

        let fnsPart =
          match m.fns with
          | [] -> Stdlib.Option.Option.None
          | fns ->
            m.fns
            |> Stdlib.List.map (fun f -> PrettyPrinter.ProgramTypes.packageFn f)
            |> Stdlib.String.join "\n\n"
            |> Stdlib.Option.Option.Some

        let constantsPart =
          match m.constants with
          | [] -> Stdlib.Option.Option.None
          | constants ->
            m.constants
            |> Stdlib.List.map (fun c ->
              PrettyPrinter.ProgramTypes.packageConstant c)
            |> Stdlib.String.join "\n\n"
            |> Stdlib.Option.Option.Some

        let submodulesPart =
          match m.submodules with
          | [] -> Stdlib.Option.Option.None
          | submodules ->
            submodules
            |> Stdlib.List.map (fun m -> PrettyPrinter.packageModule m)
            |> Stdlib.String.join "\n\n"
            |> Stdlib.Option.Option.Some

        let parts =
          [ typesPart; fnsPart; constantsPart; submodulesPart ]
          |> Stdlib.List.filterMap (fun s -> s)

        match parts with
        | [] ->
          // CLEANUP: actually error
          "Error - module defined somehow without parts"
        | parts ->
          let bodyPart = (Stdlib.String.join parts "\n\n") |> PrettyPrinter.indent

          $"module {m.name} =\n{bodyPart}"

      let packages (p: LanguageTools.ProgramTypes.Packages.Packages) : String =
        let withOwnerStuffRepresentedAsRootLevelModule =
          LanguageTools.ProgramTypes.Packages.Packages
            { types =
                p.types
                |> Stdlib.List.map (fun t ->
                  { t with
                      name =
                        { t.name with
                            modules =
                              Stdlib.List.append [ t.name.owner ] t.name.modules
                            owner = "(redacted)" } })
              fns =
                p.fns
                |> Stdlib.List.map (fun f ->
                  { f with
                      name =
                        { f.name with
                            modules =
                              Stdlib.List.append [ f.name.owner ] f.name.modules
                            owner = "(redacted)" } })

              constants =
                p.constants
                |> Stdlib.List.map (fun c ->
                  { c with
                      name =
                        { c.name with
                            modules =
                              Stdlib.List.append [ c.name.owner ] c.name.modules
                            owner = "(redacted)" } }) }

        let modules =
          ProgramTypes.Packages.toModules withOwnerStuffRepresentedAsRootLevelModule

        // CLEANUP make ordering 'better' in some way
        modules
        |> Stdlib.List.map (fun m -> PrettyPrinter.packageModule m)
        |> Stdlib.String.join "\n\n"