// Resource-related functionality for the Model Context Protocol

module Darklang =
  module ModelContextProtocol =
    module Resources =
      /// Schema for the listResources request
      module ListResourcesRequest =
        type ListResourcesParams =
          { cursor: Stdlib.Option.Option<String> }

        let fromJson (json: Json) : Stdlib.Result.Result<ListResourcesParams, String> =
          match json with
          | Object fields ->
            let cursorResult =
              match Stdlib.List.findFirst fields (fun (k, _) -> k == "cursor") with
              | Some ((_, String cursor)) -> Stdlib.Result.Result.Ok (Stdlib.Option.Option.Some cursor)
              | Some ((_, Null)) -> Stdlib.Result.Result.Ok Stdlib.Option.Option.None
              | Some ((_, _)) -> Stdlib.Result.Result.Error "cursor must be a string or null"
              | None -> Stdlib.Result.Result.Ok Stdlib.Option.Option.None

            match cursorResult with
            | Ok cursor ->
                Stdlib.Result.Result.Ok (ListResourcesParams { cursor = cursor })
            | Error err ->
                Stdlib.Result.Result.Error err
          | _ ->
            Stdlib.Result.Result.Error "params must be an object"

      module ListResourcesResponse =
        type ResourceDescription =
          { uri: ResourceUri
            name: String
            description: Stdlib.Option.Option<String>
            mimeType: Stdlib.Option.Option<String> }

        type ListResourcesResponse =
          { resources: List<ResourceDescription>
            nextCursor: Stdlib.Option.Option<String> }

        let toJson (response: ListResourcesResponse) : Json =
          let resourcesJson =
            response.resources
            |> Stdlib.List.map (fun resource ->
              let fields = [
                ("uri", Json.String resource.uri)
                ("name", Json.String resource.name)
              ]

              let fieldsWithDescription =
                match resource.description with
                | Some desc ->
                  Stdlib.List.append fields [("description", Json.String desc)]
                | None -> fields

              let fieldsWithMimeType =
                match resource.mimeType with
                | Some mime ->
                  Stdlib.List.append fieldsWithDescription [("mimeType", Json.String mime)]
                | None -> fieldsWithDescription

              Json.Object fieldsWithMimeType
            )

          let nextCursorJson =
            match response.nextCursor with
            | Some cursor -> Json.String cursor
            | None -> Json.Null

          Json.Object [
            ("resources", Json.Array resourcesJson);
            ("nextCursor", nextCursorJson)
          ]


      /// Schema for the readResource request
      module ReadResourceRequest =
        type ReadResourceResponse =
          { uri: ResourceUri }

        let toJson (response: ReadResourceResponse) : Json =
          Json.Object [
            ("uri", Json.String response.uri);
          ]

      module ReadResourceResponse =
        type ResourceContent =
          { uri: ResourceUri
            mimeType: MimeType
            text: String }

        let toJson (content: ResourceContent) : Json =
          Json.Object [
            ("uri", Json.String content.uri);
            ("mimeType", Json.String content.mimeType);
            ("text", Json.String content.text)
          ]


      /// Schema for the listResourceTemplates request
      module ListResourceTemplatesRequest =
        type ListResourceTemplatesParams =
          { method: String }

        let fromJson (json: Json) : Stdlib.Result.Result<ListResourceTemplatesParams, String> =
          match json with
          | Object fields ->
            match Stdlib.List.findFirst fields (fun (k, _) -> k == "method") with
            | Some (_, String method) ->
                Stdlib.Result.Result.Ok (ListResourceTemplatesParams { method = method })
            | Some (_, _) ->
                Stdlib.Result.Result.Error "method must be a string"
            | None ->
                Stdlib.Result.Result.Error "method is required"
          | _ ->
              Stdlib.Result.Result.Error "params must be an object"


      module ListResourceTemplatesResponse =
        type ResourceUriTemplate = String
        type ResourceTemplateDescription =
          { uriTemplate: ResourceUriTemplate
            name: String
            description: Stdlib.Option.Option<String>
            mimeType: Stdlib.Option.Option<String> }

        type ListResourceTemplatesResponse =
          { resourceTemplates: List<ResourceTemplateDescription> }

        let toJson (response: ListResourceTemplatesResponse) : Json =
          let templatesJson =
            response.resourceTemplates
            |> Stdlib.List.map (fun template ->
              let fields = [
                ("uriTemplate", Json.String template.uriTemplate);
                ("name", Json.String template.name)
              ]

              let fieldsWithDescription =
                match template.description with
                | Some desc ->
                  Stdlib.List.append fields [("description", Json.String desc)]
                | None -> fields

              let fieldsWithMimeType =
                match template.mimeType with
                | Some mime ->
                  Stdlib.List.append fieldsWithDescription [("mimeType", Json.String mime)]
                | None -> fieldsWithDescription

              Json.Object fieldsWithMimeType
            )

          Json.Object [
            ("resourceTemplates", Json.Array templatesJson)
          ]


      /// Helper functions for working with resources
      module Helpers =
        /// Check if a URI matches a URI template
        let uriMatchesTemplate (uri: ResourceUri) (template: ResourceUriTemplate) : Bool =
          // Simple implementation - just checks if the URI starts with the template
          // A more sophisticated implementation would handle URI template variables
          Stdlib.String.startsWith uri template

        /// Extract variables from a URI based on a template
        let extractUriVariables (uri: ResourceUri) (template: ResourceUriTemplate) : Stdlib.Option.Option<Dict<String>> =
          // This is a simplified implementation that assumes templates use {varName} syntax
          // A more complete implementation would handle more complex URI template syntax

          // Split both the URI and template into segments
          let uriSegments = Stdlib.String.split uri "/"
          let templateSegments = Stdlib.String.split template "/"

          // If they have different lengths, they don't match
          if Stdlib.List.length uriSegments != Stdlib.List.length templateSegments then
            Stdlib.Option.Option.None
          else
            // Extract variables from each segment
            let variablePairs =
              (Stdlib.List.zip uriSegments templateSegments)
              |> Stdlib.List.filterMap (fun (uriSeg, templateSeg) ->
                // Check if this segment is a variable (enclosed in {})
                if Stdlib.String.startsWith templateSeg "{" && Stdlib.String.endsWith templateSeg "}" then
                  // Extract the variable name (remove the {})
                  let varName =
                    templateSeg
                    |> Stdlib.String.dropFirst 1L
                    |> Stdlib.String.dropLast 1L

                  Stdlib.Option.Option.Some (varName, uriSeg)
                else if uriSeg == templateSeg then
                  // This is a static segment that matches
                  Stdlib.Option.Option.None
                else
                  // This is a static segment that doesn't match
                  Stdlib.Option.Option.None
              )

            // Convert the list of pairs to a dictionary
            (Stdlib.Dict.fromList variablePairs)
            |> Stdlib.Option.Option.Some