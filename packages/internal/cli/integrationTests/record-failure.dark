module Darklang =
  module Internal =
    module Cli =
      module IntegrationTests =
        module FailureRecorder =
          type RecordingResult =
            | Success of logPath: String
            | Failed of error: String

          let cleanupPreviousFailures () : Unit =
            let logsDir = TestConfig.getFailureLogsDir ()
            
            // Remove all failure logs from previous runs
            let cleanLogs = Stdlib.Cli.Unix.removeDirectory logsDir
            
            match cleanLogs with
            | Ok _ -> ()
            | Error e -> TestUtils.printlnError $"Failed to clean failure logs: {e}"


          let recordFailure (testName: String) (command: String) (interactiveSteps: List<String>) : RecordingResult =
            match TestUtils.ensureDirectoryExists (TestConfig.getFailureLogsDir ()) with
            | Error e -> RecordingResult.Failed e
            | Ok _ ->
              let timestamp = TestUtils.generateTimestamp ()
              let safeTestName = TestUtils.safeFileName testName
              
              let logFileName = $"failure-{safeTestName}-{timestamp}.log"
              let logPath = $"{TestConfig.getFailureLogsDir ()}/{logFileName}"
              
              let logContent = 
                $"Test Failure Report\n" ++
                $"==================\n" ++
                $"Test Name: {testName}\n" ++
                $"Command: {command}\n" ++
                $"Timestamp: {timestamp}\n"
              
              let interactiveStepsContent = 
                if Stdlib.List.isEmpty interactiveSteps then
                  ""
                else
                  $"Interactive Steps:\n" ++
                  (interactiveSteps 
                   |> Stdlib.List.map (fun step -> $"  - {step}")
                   |> Stdlib.String.join "\n") ++
                  $"\n"
              
              let fullContent = logContent ++ interactiveStepsContent
              
              match TestUtils.writeFileContent logPath fullContent with
              | Error e -> RecordingResult.Failed $"Failed to write failure log: {e}"
              | Ok _ ->
                Builtin.printLine $"📝 Failure log recorded at: {logPath}"
                RecordingResult.Success logPath


          let recordFailureForTest (testName: String) (command: String) (interactiveSteps: List<String>) : Bool =
            match recordFailure testName command interactiveSteps with
            | Success _ -> true
            | Failed _ -> false
