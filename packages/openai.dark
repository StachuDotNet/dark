module OpenAI =

  module Config =
    let getHeaders (apiKey: String) : List<(String * String)> =
      [ ("authorization", "Bearer " ++ apiKey)
        ("content-type", "application/json") ]

  module Completion =
    type Request =
      { model: String
        prompt: String
        max_tokens: Int64
        temperature: Float }

    type ResponseChoice = { text: String }

    type Response =
      { id: String
        object: String
        created: Int64
        model: String
        choices: List<ResponseChoice> }

    let completion (apiKey: String) (prompt: String) : Darklang.Stdlib.Result.Result<String, String> =
      let request =
        Request
          { model = "text-davinci-003"
            prompt = prompt
            max_tokens = 700L
            temperature = 0.7 }
      let reqBody = Builtin.jsonSerialize<Request> openAIRequest
      let reqHeaders = Config.getHeaders apiKey
      
      let httpResponse =
        Darklang.Stdlib.HttpClient.postString "https://api.openai.com/v1/completions" reqHeaders reqBody

      match httpResponse with
      | Ok r ->
        let parsedResponseBody =
          r.body |> Darklang.Stdlib.String.fromBytesWithReplacement |> Builtin.jsonParse<Response>
        	
        match parsedResponseBody with
        | Ok r ->
          match Darklang.Stdlib.List.head r.choices with
          | Some c -> Darklang.Stdlib.Result.Result.Ok c.text
          | None -> Darklang.Stdlib.Result.Result.Error "No choices returned"
        | Error err -> Darklang.Stdlib.Result.Result.Error "Couldn't parse HTTP response"
      | Error err ->
        Darklang.Stdlib.Result.Result.Error(
          "Couldn't parse OpenAI completion response - " ++ err
        )


  module ChatCompletion =
    type RequestMessage = { role: String; content: String }

    type Request =
      { model: String
        max_tokens: Int64
        temperature: Float
        messages: List<RequestMessage> }

    type ResponseChoiceMessage = { content: String }
    type ResponseChoice = { message: ResponseChoiceMessage }
    type Response = { choices: List<ResponseChoice> }


    module CompletionOptions =
      type CompletionOptions =
        { model: String
          messages: List<RequestMessage>
          temperature: Float
          max_tokens: Int64
          top_p: Float
          n: Int64
          stream: Bool }

      let simple (content: String): CompletionOptions =
        CompletionOptions
          { model = "gpt-3.5-turbo"
            messages = [ RequestMessage { role = "user"; content = content } ]
            temperature = 0.7
            max_tokens = 700L
            top_p = 1.0
            n = 1L
            stream = false }


    let completion (apiKey: String) (req: CompletionOptions.CompletionOptions)
      : Darklang.Stdlib.Result.Result<String, String> =
      let httpResponse =
        Darklang.Stdlib.HttpClient.postString
          "https://api.openai.com/v1/chat/completions"
          (Config.getHeaders apiKey)
          (Builtin.jsonSerialize<CompletionOptions.CompletionOptions> req)

      match openAIResponse with
      | Ok r ->
        match
          Builtin.jsonParse<Response> (
            Darklang.Stdlib.String.fromBytesWithReplacement r.body
          )
        with
        | Ok r ->
          match Darklang.Stdlib.List.head r.choices with
          | Some c -> Darklang.Stdlib.Result.Result.Ok c.message.content
          | None -> Darklang.Stdlib.Result.Result.Error "No choices returned"
        | Error err ->
          Darklang.Stdlib.Result.Result.Error $"Couldn't parse OpenAI completion response - {err}"
      | Error e ->
        Darklang.Stdlib.Result.Result.Error $"OpenAI API request failed\n{e}"


  module ImageGeneration =
    type Request = { prompt: String; size: String }

    type ResponseData = { url: String }
    type Response = { data: List<ResponseData> }

    /// Returns a url to the image
    ///
    /// CLEANUP should it return the image itself instead?
    let imageGeneration
      (prompt: String)
      : Darklang.Stdlib.Result.Result<String, String> =

      let openAIRequest = Request { prompt = prompt; size = "256x256" }

      let reqBody = Builtin.jsonSerialize<Request> openAIRequest

      let headers = Config.getHeaders ()

      let openAIResponse =
        Darklang.Stdlib.HttpClient.request
          "POST"
          "https://api.openai.com/v1/images/generations"
          headers
          (Darklang.Stdlib.String.toBytes reqBody)

      match openAIResponse with
      | Ok r ->
        match
          Builtin.jsonParse<Response> (
            Darklang.Stdlib.String.fromBytesWithReplacement r.body
          )
        with
        | Ok r ->
          match Darklang.Stdlib.List.head r.data with
          | Some d -> Darklang.Stdlib.Result.Result.Ok d.url
          | None -> Darklang.Stdlib.Result.Result.Error "No data returned"
        | Error err ->
          Darklang.Stdlib.Result.Result.Error(
            "Couldn't parse open ai image generation response - " ++ err
          )
      | Error e ->
        Darklang.Stdlib.Result.Result.Error("OpenAI API request failed\n" ++ e)


  module Model =
    type Request = { model: String }

    type Response =
      { id: String
        object: String
        created: Int64
        model: String }


    let retrieveModel (apiKey: String) (model: String): Darklang.Stdlib.Result.Result<String, String> =
      let httpResponse =
        Darklang.Stdlib.HttpClient.get
          $"https://api.openai.com/v1/models/{model}"
          (Config.getHeaders apiKey)
          []

      match httpResponse with
      | Ok r ->
        r.body
        |> Darklang.Stdlib.String.fromBytesWithReplacement
        |> Darklang.Stdlib.Result.Result.Ok
      | Error e ->
        Darklang.Stdlib.Result.Result.Error $"OpenAI API request failed\n{e}"


    let getListOfModels (apiKey: String): Darklang.Stdlib.Result.Result<List<String>, String> =
      let httpResponse =
        Darklang.Stdlib.HttpClient.get
          "https://api.openai.com/v1/models"
          (Config.getHeaders apiKey)
          []

      match httpResponse with
      | Ok r ->
        r.body
        |> Darklang.Stdlib.String.fromBytesWithReplacement
        |> Darklang.Stdlib.Result.Result.Ok
      | Error e ->
        Darklang.Stdlib.Result.Result.Error $"OpenAI API request failed\n{e}"

