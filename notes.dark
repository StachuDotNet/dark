module Darklang =
module LanguageTools =
// It's worth noting that all RTE is provided paired with a context
// of where that error happened.
// "RuntimeErrorContext"?
module RuntimeErrors =

      module NameResolution =
        type ErrorType =
          | NotFound of names: List<String>
          | ExpectedEnumButNot of packageTypeID: uuid
          | ExpectedRecordButNot of packageTypeID: uuid
          | MissingEnumModuleName of caseName: String
          | InvalidPackageName of names: List<String>

        type NameType = | Function | Type | Constant

        type Error = { errorType: ErrorType nameType: NameType }







      module TypeChecker =
        type Context =
          | FunctionCallParameter of fnName: FQFnName * parameter: RTParam * paramIndex: Int64
          | FunctionCallResult of fnName: FQFnName * returnType: TypeReference
          | RecordField of recordTypeName: FQTypeName * fieldName: String * fieldType: TypeReference
          | DictKey of key: String * typ: TypeReference
          | EnumField of enumTypeName: FQTypeName * caseName: String * fieldIndex: Int64 * fieldCount: Int64 * fieldType: TypeReference
          | DBQueryVariable of varName: String * expected: TypeReference
          | DBSchemaType of name: String * expectedType: TypeReference
          | ListIndex of index: Int64 * listTyp: TypeReference * parent: Context
          | TupleIndex of index: Int64 * elementType: TypeReference * parent: Context
          | FnValResult of returnType: TypeReference

        type ErrorType =
          | ValueNotExpectedType of actualValue: Dval * expectedType: TypeReference
          | TypeDoesntExist of FQTypeName

        type Error = { errorType: ErrorType context: Context }


      module Cli =
        type Error =
          | NoExpressionsToExecute
          | UncaughtException of String * List<String * String>
          | NonIntReturned of actuallyReturned: Dval.Dval


      module Json =
        type Error = UnsupportedType of RuntimeTypes.TypeReference


      module Int =
        type Error =
          | DivideByZeroError
          | OutOfRange
          | NegativeExponent
          | NegativeModulus
          | ZeroModulus


      module Execution =
        type Error =
          | MatchExprUnmatched of RuntimeTypes.Dval.Dval
          | NonStringInStringInterpolation of RuntimeTypes.Dval.Dval
          | ConstDoesntExist of RuntimeTypes.FQConstantName.FQConstantName
          | EnumConstructionCaseNotFound of typeName: RuntimeTypes.FQTypeName * caseName: String
          | WrongNumberOfFnArgs of fn: RuntimeTypes.FQFnName * expectedTypeArgs: Int64 * expectedArgs: Int64 * actualTypeArgs: Int64 * actualArgs: Int64

          // TODO: Record submodule
          | RecordConstructionFieldDoesntExist of typeName: RuntimeTypes.FQTypeName * fieldName: String
          | RecordConstructionMissingField of RuntimeTypes.FQTypeName * missingFieldName: String
          | RecordConstructionDuplicateField of RuntimeTypes.FQTypeName * duplicateFieldName: String
          | FieldAccessFieldDoesntExist of typeName: RuntimeTypes.FQTypeName * invalidFieldName: String
          | FieldAccessNotRecord of RuntimeTypes.ValueType * String

      module Unwrap =
        type Error =
          | GotNone
          | GotError of Dval
          | NonOptionOrResult of Dval



      // TODO: this needs a way to be extensible
      // users should have _some_ way to add their own RuntimeErrors
      // and we don't want to have to rebuild everything to add a new RTE
      type Error =
        // reframe as "Encountered unresolved name"
        | NameResolution of NameResolution.Error

        | Int of Int.Error
        | Json of Json.Error

        | Record of Record.Error
        | Enum of Enum.Error

        | List of List.Error

        | Unwrap of Unwrap.Error

        // probably break this down..
        | TypeChecker of TypeChecker.Error

        | ExpectedBoolInCondition of Dval
        | VariableNotFound of attemptedVarName : String


        | SqlCompiler of Error // -- or maybe this should happen during PT2RT? hmm.

        // lol aren't they all execution errors?
        // remove this level...
        | Execution of Execution.Error

        | Cli of Cli.Error

        | OldStringTODO of String



        /// Sometimes, very-unexpected things happen. This is a catch-all for those.
        /// For local/private runtimes+hosting, allow users to see the details,
        /// but for _our_ hosting, users shouldn't see the whole call stack or
        /// whatever, for (our) safety. But, they can use the error ID to refer to
        /// the error in a support ticket.
        | UncaughtException of reference: Uuid

backend/src/BuiltinExecution/Libs/NoModule.fs:
413 // $"unwrap called with multiple arguments: {multipleArgs}"
414: // |> RuntimeError.oldError

backend/src/LibCloud/SqlCompiler.fs:
1220 let err = RuntimeError.sqlCompilerRuntimeError internalError
1221 return Error err
1222
1223: | SqlCompilerException errStr -> return Error(RuntimeError.oldError errStr)
1224: // return Error(RuntimeError.oldError (errStr + $"\n\nIn body: {body}"))
1225 }

backend/src/LibExecution/Interpreter.fs:
263: "Let Pattern did not match"

265: | Fail \_rte -> rte <- Some(RuntimeError.oldError "TODO")

351 $"Function {FQFnName.toString fnName} is not found")

backend/src/LibExecution/Interpreter.Old.fs:
123: RuntimeError.oldError "TODO"

161: $"Invalid const name: {msg}")

904 $"Expected {expectedLength} arguments, got {actualLength}")

988 $"Function {FQFnName.toString fnToCall} is not found")

1044: "Unknown error"

backend/src/LibExecution/NameResolutionError.fs:
105 let toRuntimeError (\_e : Error) : RT.RuntimeError =
107: "TODO" |> RT.RuntimeError.oldError

backend/src/LibExecution/ProgramTypesToRuntimeTypes.fs:
411 // It's ok to _reference_ a bad name, so long as we don't try to `apply` it.
412 // maybe the 'value' here is (still) some unresolved name?
413 // (which should fail when we apply it)
414: (rc, [ RT.Fail(RT.RuntimeError.oldError "Couldn't find fn") ], rc)

591: // // RT.RuntimeError.oldError "Record must have at least one field",

673: // // RT.RuntimeError.oldError "Match must have at least one case",

backend/src/LibExecution/RuntimeTypes.fs:
813
814
815 // TODO remove all usages of this in favor of better error cases
816: let oldError (msg : string) : RuntimeError =
817 //case "OldStringErrorTODO" [ DString msg ]
818 RuntimeError(DString msg)
819

839
840 // TODO remove all usages of this in favor of better error cases
841 let raiseUntargetedString (s : string) : 'a =
842: raiseUntargetedRTE (RuntimeError.oldError s)
843
844 /// Internally in the runtime, we allow throwing RuntimeErrorExceptions. At the
845 /// boundary, typically in Execution.fs, we will catch the exception, and return this

backend/src/LibExecution/TypeChecker.fs:
130 RuntimeError.oldError "TODO"

552 $"Could not merge types {ValueType.toString (VT.list typ)} and {ValueType.toString (VT.list dvalType)}"

604 $"Could not merge types {ValueType.toString (VT.customType typeName [ innerType ])} and {ValueType.toString (VT.customType typeName [ dvalType ])}"

645 $"Could not merge types {ValueType.toString (VT.customType Dval.resultType [ okType; errorType ])} and {ValueType.toString (VT.customType Dval.resultType [ dvalType; errorType ])}"

666 $"Could not merge types {ValueType.toString (VT.customType Dval.resultType [ okType; errorType ])} and {ValueType.toString (VT.customType Dval.resultType [ okType; dvalType ])}"

695: "Empty key"

699: $"Duplicate key: {k}")

backend/tests/TestUtils/LibTest.fs:
71 // previewable = Pure
72 // deprecated = NotDeprecated }
73
74: // // CLEANUP consider renaming to `oldError` or something more clear
75 // { name = fn "testRuntimeError" 0
76 // typeParams = []
77 // parameters = [ Param.make "errorString" TString "" ]

80 // fn =
81 // (function
82 // | _, _, [ DString errorString ] ->
83: // raiseUntargetedRTE (RuntimeError.oldError errorString)
84 // | \_ -> incorrectArgs ())
85 // sqlSpec = NotQueryable
86 // previewable = Pure

backend/src/LibCloud/SqlCompiler.fs:
1221 return Error err
1222
1223: | SqlCompilerException errStr -> return Error(RuntimeError.oldError errStr)
1224: // return Error(RuntimeError.oldError (errStr + $"\n\nIn body: {body}"))
1225 }
1226
1227 /home/dark/app/backend/src/LibExecution/Interpreter.Old.fs
1228: 177,10: // let errStr msg : 'a = raiseRTE callStack (RuntimeError.oldError msg)
1229: 184,40: // | LPUnit _ -> if dv <> DUnit then errStr "Unit pattern does not match" else []
1230: 198,12: // errStr "Tuple pattern has wrong number of elements"
1231: 199,15: // | _ -> errStr "Tuple pattern does not match"
1232: 343,7: let errStr callStack msg : 'a = raiseRTE callStack (RuntimeError.oldError msg)
1233: 480,41: // | _, "", _ -> return errStr callStack $"Empty key for value `{dv}`"
1234: 503,24: // errStr
1235: 508,24: // | _ -> return errStr callStack "Expected a record in record update"
1236: 529,11: errStr
1237: 538,19: // return errStr callStack "Field name is empty"
1238: 554,21: // return errStr callStack msg
1239: 775,34: // | _ -> return errStr callStack "When condition should be a boolean"
1240: 795,24: // | _ -> return errStr callStack "If only supports Booleans"
1241: 804,26: // | _ -> return errStr callStack "|| only supports Booleans"
1242: "|| only supports Booleans"
1243: "&& only supports Booleans"
1244: "&& only supports Booleans"

backend/src/LibExecution/Interpreter.Old.fs:
184: "Unit pattern does not match"

198: "Tuple pattern has wrong number of elements"

199: "Tuple pattern does not match"

480: $"Empty key for value `{dv}`"

505 $"Expected a record but {typeStr} is something else"

508: "Expected a record in record update"

531 $"Expected a function value, got something else: {DvalReprDeveloper.toRepr other}"

538: "Field name is empty"

552 "(use `DB.*` standard library functions to interact with Datastores. "
553 + "Field access only work with records)"

775: "When condition should be a boolean"

795: "If only supports Booleans"

804: "|| only supports Booleans"

814: "&& only supports Booleans"

834 $"Case `{caseName}` expected {case.fields.Length} fields but got {fields.Length}"

incorrectArgs
