[<DB>]
type PackageTypeDB = PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType.T

[<DB>]
type PackageFnDB = PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.T

[<DB>]
type PackageConstantDB =
  PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant.T


[<HttpHandler("POST", "/types")>]
let _handler _req =
  let typ =
    request.body
    |> String.fromBytes
    |> Json.parse<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType.T>
    |> unwrap

  let typeToSave =
    PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType.T
      { tlid = typ.tlid
        id = typ.id
        name = typ.name
        declaration = typ.declaration
        description = typ.description
        deprecated = typ.deprecated }

  let key = DB.generateKey_v0 () // TODO: use id instead
  DB.set typeToSave key PackageTypeDB

  PACKAGE.Darklang.Stdlib.Http.response (String.toBytes "added") 200


[<HttpHandler("POST", "/functions")>]
let _handler _req =
  let fn =
    request.body
    |> String.fromBytes
    |> Json.parse<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.T>
    |> unwrap

  let fnToSave =
    PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.T
      { tlid = fn.tlid
        id = fn.id
        name = fn.name
        body = fn.body
        typeParams = fn.typeParams
        parameters = fn.parameters
        returnType = fn.returnType
        description = fn.description
        deprecated = fn.deprecated }

  let key = DB.generateKey_v0 () // TODO: use id instead
  DB.set fnToSave key PackageFnDB

  PACKAGE.Darklang.Stdlib.Http.response (String.toBytes "added") 200

[<HttpHandler("POST", "/constants")>]
let _handler _req =
  let c =
    request.body
    |> String.fromBytes
    |> Json.parse<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant.T>
    |> unwrap

  let constantToSave =
    PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant.T
      { tlid = c.tlid
        id = c.id
        name = c.name
        body = c.body
        description = fn.description
        deprecated = fn.deprecated }

  let key = DB.generateKey_v0 () // TODO: use id instead
  DB.set constantToSave key PackageConstantDB

  PACKAGE.Darklang.Stdlib.Http.response (String.toBytes "added") 200


[<HttpHandler("GET", "/stats")>]
let _handler _req =
  let stats =
    [ ("types", (DB.getAll PackageTypeDB) |> List.length)
      ("constants", (DB.getAll PackageFnDB) |> List.length)
      ("fns", (DB.getAll PackageConstantDB) |> List.length) ]
    |> Dict.fromListOverwritingDuplicates_v0

  let body = (Json.serialize<Dict<Int>> stats) |> unwrap |> String.toBytes

  PACKAGE.Darklang.Stdlib.Http.response body 200


[<HttpHandler("GET", "/types")>]
let _handler _req =
  let respBody =
    (DB.getAll PackageTypeDB)
    |> Json.serialize<List<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType.T>>
    |> unwrap
    |> String.toBytes

  PACKAGE.Darklang.Stdlib.Http.response respBody 200

[<HttpHandler("GET", "/constants")>]
let _handler _req =
  let respBody =
    (DB.getAll PackageConstantDB)
    |> Json.serialize<List<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant.T>>
    |> unwrap
    |> String.toBytes

  PACKAGE.Darklang.Stdlib.Http.response respBody 200

[<HttpHandler("GET", "/functions")>]
let _handler _req =
  let respBody =
    (DB.getAll PackageFnDB)
    |> Json.serialize<List<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.T>>
    |> unwrap
    |> String.toBytes

  PACKAGE.Darklang.Stdlib.Http.response respBody 200


// WIP
type ParsedName =
  { owner: String
    modules: List<String>
    name: String
    version: Int }

let parseName
  (name: String)
  : PACKAGE.Darklang.Stdlib.Result.Result<ParsedName, Unit> =
  let parts = String.split name "."
  print "1"

  match parts with
  // at least 3 parts: owner | name | version
  | ownerName :: firstModuleName :: theRest ->
    print "2"

    match List.reverse theRest with
    | moduleNameAndMaybeVersion :: modulesAfterTheFirstInReverse ->
      print "3"

      let modules =
        List.append [ firstModuleName ] (List.reverse modulesAfterTheFirstInReverse)

      print "4"

      let parsed =
        ParsedName
          { owner = ownerName
            modules = modules
            name = moduleNameAndMaybeVersion
            version = 0 }

      print "4.5"

      PACKAGE.Darklang.Stdlib.Result.Result.Ok parsed

[<HttpHandler("GET", "/type/by-name/:name")>]
let _handler _req =
  let parsedName = (parseName name) |> unwrap
  print "5"

  print ((Json.serialize<ParsedName> parsedName) |> unwrap)

  let foundType =
    DB.query PackageTypeDB (fun typ ->
      (typ.name.owner == parsedName.owner)
      && (typ.name.modules == parsedName.modules)
      && (typ.name.name == parsedName.name)
      && (typ.name.version == parsedName.version))

  print ("found" ++ (foundType |> List.length |> Int.toString))

  match foundType with
  | [] -> PACKAGE.Darklang.Stdlib.Http.response (String.toBytes "not found") 404

  | [ single ] ->
    let response =
      (Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType.T>
        single)
      |> unwrap

    PACKAGE.Darklang.Stdlib.Http.response (String.toBytes response) 200

  | _multiple ->
    PACKAGE.Darklang.Stdlib.Http.response (String.toBytes "multiple found") 409
