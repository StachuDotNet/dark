type Prompt = | Prompt of String

type EditorConversationState =
  | WaitingForFirstInput
  | WaitingForUserInput
  | BotIsThinking

type Author = | User | Bot

type ChatHistoryItem =
  { Author : Author; Prompt : Prompt }

type Model =
  { State : EditorConversationState
    SystemPrompt: Prompt
    ChatHistory: List<ChatHistoryItem> }

type Msg =
  | UserGavePrompt of prompt: Prompt
  | BotResponded of Prompt

let update (model: State) (msg: Msg) : Model =
  match msg with
  | UserGavePrompt prompt ->
    { SystemPrompt = model.SystemPrompt
      State = BotIsThinking
      ChatHistory =
        let newItem = { Author = Author.User; Prompt = Prompt prompt }
        List.append model.ChatHistory [ newItem ] }

  | BotResponded response ->
    { SystemPrompt = model.SystemPrompt
      State = WaitingForUserInput
      ChatHistory =
        let newItem = { Author = Author.Bot; Prompt = Prompt response }
        List.append model.ChatHistory [ newItem ] }



let init() =
  setState // TODO: make setState return the state set
    { SystemPrompt = Prompt "TODO: import blurb about Dark"
      State = WaitingForFirstInput
      ChatHistory = [] }



// Models to interop with JS host
// (TODO: wrap this in `module JS = `)

type ChatHistoryItemJS = { author : string; prompt : String  }

type ModelForJS =
  // should be 1:1 with Model, but nice and serializeable
  { systemPrompt : string
    state : string
    chatHistory: List<ChatHistoryItemJS> }

// TODO: result
let modelForJS (model: Model) : ModelForJS =
  { systemPrompt = match model.SystemPrompt with Prompt p -> p
    state = match model.State with
            | WaitingForFirstInput -> "WaitingForFirstInput"
            | WaitingForUserInput -> "WaitingForUserInput"
            | BotIsThinking -> "BotIsThinking"
    chatHistory =
      model.ChatHistory
      |> List.map (fun item ->
           { author = match item.Author with User -> "User" | Bot -> "Bot"
             prompt = item.Text }) }

// TODO: result
let modelFromJS (model: ModelForJS) : Model =
  { SystemPrompt = Prompt model.systemPrompt
    State =
      match model.state with
      | "WaitingForFirstInput" -> WaitingForFirstInput
      | "WaitingForUserInput" -> WaitingForUserInput
      | "BotIsThinking" -> BotIsThinking
    ChatHistory =
      model.chatHistory
      |> List.map (fun item ->
           { Author = match item.author with "User" -> User | "Bot" -> Bot
             Prompt = item.text }) }


type EventJS = { eventName: String; data: String }

let msgOfJS (msg: EventJS) : Msg =
  match msg.eventName with
  | "userGavePrompt" -> UserGavePrompt (Prompt msg.data)
  | "botResponded" -> BotResponded (Prompt msg.data)
  | _ -> failwith "Couldn't parse event name"

let msgToJS (msg: Msg) : EventJS =
  match msg with
  | UserGavePrompt prompt ->
    { eventName = "userGavePrompt"
      data = match prompt with Prompt p -> p }
  | BotResponded prompt ->
    { eventName = "botResponded"
      data = match prompt with Prompt p -> p }


// Exposed to JS
let handleRawEvent (evt: String): Result<String, String> =
  match Json.parse<EventJS> evt with
  | Ok rawEvent ->
    match msgOfJS rawEvent with
    | Ok msg ->
      let currentState = WASM.getState<Model>

      let newState = update currentState msg

      // returns result, but let's assume it worked...
      let _ = setState newState

      let updatedJSModel = modelForJS newState

      match Json.serialize<ModelForJS> updatedJSModel with
      | Ok serialized -> WASM.callJSFunction "window.stateUpdated" [serialized]
      | Error err -> Error "Couldn't serialize updated state"

    | Error err -> Error "Couldn't parse msg from raw event"
  | Error err -> Error "Couldn't parse raw msg"


// things to run on startup
init()






// TODO
// type OpenAICompletionRequest = {
//   model: String
//   max_tokens: Int
//   temperature: Float
//   prompt : String
// }

// [<HttpHandler("POST", "/api/handle-user-prompt")>]
// let _handler _req =
//   let openAIRequest =
//     OpenAICompletionRequest
//       { model = "text-davinci-003"
//         max_tokens = 700
//         temperature = 0.7
//         prompt = String.fromBytes request.body }

//   match Json.serialize<OpenAICompletionRequest> openAIRequest with
//   | Ok reqBody ->
//     let headers =
//       [
//         ("Authorization", "Bearer " ++ OPENAI_API_KEY)
//         ("Content-Type", "application/json")
//       ]

//     let openAIResponse =
//       HttpClient.request "POST" "https://api.openai.com/v1/completions" headers (String.toBytes reqBody)

//     match openAIResponse with
//     | Ok r -> Http.response (r.body) 200
//     | Error e -> Http.response (String.toBytes "OpenAI API request failed") 500

//   | Error _e -> Http.response (String.toBytes "Couldn't serialize request") 400