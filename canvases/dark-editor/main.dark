[<HttpHandler("GET", "/")>]
let _handler _req =
  let filePath =  "dark-editor-vue/dist/index.html"
  let file = Experiments.readFromCanvases filePath
  let body =
    match file with
    | Ok f ->  f
    | Error _ -> Bytes.empty

  Http.responseWithHeaders
    (body)
    (Dict.fromListOverwritingDuplicates [ ("Content-Type", "text/html") ])
    200

[<HttpHandler("GET", "/assets/:path")>]
let _handler _req =
  match Experiments.readFromCanvases ("dark-editor-vue/dist/assets/" ++ path) with
  | Ok fileContents ->
    let contentType =
      match (String.split_v1 path ".") |> List.last_v2 |> Option.withDefault "" with
      | "js" -> "application/javascript"
      | "json" -> "application/json"
      | "css" -> "text/css"
      | _ -> "text/plain"

    let headers =
      Dict.fromListOverwritingDuplicates [ ("content-type", contentType) ]

    Http.responseWithHeaders fileContents headers 200

  | Error _e -> Http.response (String.toBytes "Couldn't load asset") 400



// TODO: remove once a parser can run in WASM runtime
[<HttpHandler("POST", "/get-program-json")>]
let _handler _req =
  let sourceInBytes = request.body
  let program =
    Experiments.parseAndSerializeProgram (String.fromBytes sourceInBytes) "user-code.dark"

  match program with
  | Ok program ->
    let types = Option.withDefault (Dict.get_v2 program "types") "[]"
    let fns = Option.withDefault (Dict.get_v2 program "fns") "[]"
    let exprs = Option.withDefault (Dict.get_v2 program "exprs") "[]"

    let json = "{ \"types\": " ++ types ++ ", \"fns\": " ++ fns ++ ", \"exprs\": " ++ exprs ++ "}"

    Http.responseWithHeaders
      (String.toBytes json)
      (Dict.fromListOverwritingDuplicates [ ("content-type", "application-json")])
      200

  | Error err -> Http.response (String.toBytes ("Couldn't parse the program \n" ++ err)) 400


[<HttpHandler("GET", "/system-prompt")>]
let _handler _req =
  match Experiments.readFromCanvases "dark-editor/system-prompt.txt" with
  | Ok prompt ->  Http.response prompt 200
  | Error _e -> Http.response (String.toBytes "Couldn't load prompt from disk") 500




// TODO: eventually this should all live in client.dark

type OpenAICompletionRequest = {
  model: String
  max_tokens: Int
  temperature: Float
  prompt : String
}

[<HttpHandler("POST", "/api/handle-user-prompt")>]
let _handler _req =
  let openAIRequest =
    OpenAICompletionRequest
      { model = "text-davinci-003"
        max_tokens = 700
        temperature = 0.7
        prompt = String.fromBytes request.body }

  match Json.serialize<OpenAICompletionRequest> openAIRequest with
  | Ok reqBody ->
    let headers =
      [
        ("Authorization", "Bearer " ++ OPENAI_API_KEY)
        ("Content-Type", "application/json")
      ]

    let openAIResponse =
      HttpClient.request "POST" "https://api.openai.com/v1/completions" headers (String.toBytes reqBody)

    match openAIResponse with
    | Ok r -> Http.response (r.body) 200
    | Error e -> Http.response (String.toBytes "OpenAI API request failed") 500

  | Error _e -> Http.response (String.toBytes "Couldn't serialize request") 400