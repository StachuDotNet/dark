// TODO: consider moving all of this to package space

let listDirectoryRecursive (dir: String) : List<String> =
  let contents = Builtin.directoryList dir

  let (files, dirs) =
    contents
    |> PACKAGE.Darklang.Stdlib.List.partition (fun x -> Builtin.fileIsNormal x)

  let nested =
    dirs
    |> PACKAGE.Darklang.Stdlib.List.map (fun d -> listDirectoryRecursive d)
    |> Builtin.localExecBuiltInsListFlatten

  dirs
  |> PACKAGE.Darklang.Stdlib.List.append files
  |> PACKAGE.Darklang.Stdlib.List.append nested


// Packages
let listPackageFilesOnDisk (dir: String) : List<String> =
  dir
  |> listDirectoryRecursive
  |> PACKAGE.Darklang.Stdlib.List.filter (fun x ->
    x |> Builtin.localExecBuiltInsStringEndsWith ".dark")


type SourceFile = { path: String; contents: String }



// let printPackageFunction
//   (p: PACKAGE.Darklang.LocalExec.Packages.FunctionName)
//   : Unit =
//   let modules = p.modules |> PACKAGE.Darklang.Stdlib.String.join "."

//   Builtin.printLine
//     $"Package Function {p.owner}.{modules}.{p.name}_v{PACKAGE.Darklang.Stdlib.Int64.toString_v0 p.version}"

// let printPackageType (p: PACKAGE.Darklang.LocalExec.Packages.TypeName) : Unit =
//   let modules = p.modules |> PACKAGE.Darklang.Stdlib.String.join "."

//   Builtin.printLine
//     $"Package Type {p.owner}.{modules}.{p.name}_v{PACKAGE.Darklang.Stdlib.Int64.toString_v0 p.version}"

// let printPackageConstant
//   (p: PACKAGE.Darklang.LocalExec.Packages.ConstantName)
//   : Unit =
//   let modules = p.modules |> PACKAGE.Darklang.Stdlib.String.join "."

//   Builtin.printLine
//     $"Package Constant {p.owner}.{modules}.{p.name}_v{PACKAGE.Darklang.Stdlib.Int64.toString_v0 p.version}"

let printAllPackagesInDb () : Unit =
  // let functions = Builtin.localExecPackagesListFunctions ()

  // functions |> Builtin.localExecBuiltInsListIter (fun p -> printPackageFunction p)

  // let types = Builtin.localExecPackagesListTypes ()
  // types |> Builtin.localExecBuiltInsListIter (fun p -> printPackageType p)

  // let constants = Builtin.localExecPackagesListConstants ()

  // constants |> Builtin.localExecBuiltInsListIter (fun p -> printPackageConstant p)
  Builtin.printLine "TODO: printAllPackagesInDb (I don't think anyone used this)"
  ()


// parse args and execute
type CliOptions =
  | Help
  | LoadPackagesIntoDarkCanvas of String * String
  | ListPackagesInDb
  | BadOption of String

let usage () : String =
  "Usage: LocalExec [options]

    Options:
      -h, --help          Show this help message and exit
      load-packages-dlio  Load packages from disk into local dark packages canvas
      load-packages-darklang-com PASSWORD Load packages from disk into production packages canvas
      list-packages       List packages
  "


let parseArgs (args: List<String>) : CliOptions =
  match args with
  | [] -> CliOptions.Help
  | [ "-h" ] -> CliOptions.Help
  | [ "--help" ] -> CliOptions.Help

  | [ "list-packages" ] -> CliOptions.ListPackagesInDb

  | [ "load-packages" ] ->
    CliOptions.BadOption
      "`load-packages` now executes in F# (not sure how you got here)"

  | [ "load-packages-dlio" ] ->
    CliOptions.LoadPackagesIntoDarkCanvas(
      "http://dark-packages.dlio.localhost:11001",
      "password"
    )

  | [ "load-packages-darklang-com"; password ] ->
    CliOptions.LoadPackagesIntoDarkCanvas("https://packages.darklang.com", password)

  | _ ->
    let argString = PACKAGE.Darklang.Stdlib.String.join args " "
    CliOptions.BadOption $"Invalid arguments: {argString}"


let getHealthCheckResult
  (host: String)
  : PACKAGE.Darklang.Stdlib.Result.Result<Unit, String> =
  PACKAGE.Darklang.Stdlib.List.fold
    (PACKAGE.Darklang.Stdlib.List.range 0L 10L)
    (PACKAGE.Darklang.Stdlib.Result.Result.Error "Not started")
    (fun found num ->
      match found with
      | Ok() -> PACKAGE.Darklang.Stdlib.Result.Result.Ok()
      | Error _ ->
        let httpRequestResult =
          PACKAGE.Darklang.Stdlib.HttpClient.request "GET" $"{host}/health" [] []

        match httpRequestResult with
        | Ok _ -> PACKAGE.Darklang.Stdlib.Result.Result.Ok()
        | Error err ->
          let errMsg = PACKAGE.Darklang.Stdlib.HttpClient.toString err
          Builtin.printLine $"Error: {errMsg}"
          Builtin.timeSleep 1000.0
          $"Error waiting for dark packages canvas: {errMsg}")


let parseAllFiles
  (sourceFiles: List<SourceFile>)
  : PACKAGE.Darklang.Stdlib.Result.Result<PACKAGE.Darklang.Stdlib.Packages, String> =
  let init =
    (PACKAGE.Darklang.Stdlib.Packages { types = []; fns = []; constants = [] })
    |> PACKAGE.Darklang.Stdlib.Result.Result.Ok

  sourceFiles
  |> PACKAGE.Darklang.Stdlib.List.fold init (fun acc f ->
    match acc with
    | Error _err -> acc
    | Ok acc ->
      match Builtin.parseLocalPackageSourceFile f.contents f.path with
      | Error err ->
        $"Failed to parse file {f.path}:\n{err}"
        |> PACKAGE.Darklang.Stdlib.Result.Result.Error

      | Ok newItems ->
        (PACKAGE.Darklang.Stdlib.Packages
          { types = PACKAGE.Darklang.Stdlib.List.append acc.types newItems.types
            fns = PACKAGE.Darklang.Stdlib.List.append acc.fns newItems.fns
            constants =
              PACKAGE.Darklang.Stdlib.List.append acc.constants newItems.constants })
        |> PACKAGE.Darklang.Stdlib.Result.Result.Ok)


let main (args: List<String>) : Int64 =
  match parseArgs args with
  | Help ->
    Builtin.printLine (usage ())
    0L

  | ListPackagesInDb ->
    printAllPackagesInDb ()
    0L

  | LoadPackagesIntoDarkCanvas(host, password) ->
    let result = // Result<Unit, String>
      Builtin.printLine "1. Checking if canvas is ready"

      (getHealthCheckResult host)

      |> PACKAGE.Darklang.Stdlib.Result.andThen (fun () ->
        Builtin.printLine "2. Reading all .dark files in `packages` dir"

        (listPackageFilesOnDisk "/home/dark/app/packages")
        |> PACKAGE.Darklang.Stdlib.List.sort
        |> PACKAGE.Darklang.Stdlib.List.map (fun f ->
          let contents =
            (Builtin.fileRead f)
            |> Builtin.unwrap
            |> PACKAGE.Darklang.Stdlib.String.fromBytesWithReplacement

          SourceFile { path = f; contents = contents })
        |> PACKAGE.Darklang.Stdlib.Result.Result.Ok)

      |> PACKAGE.Darklang.Stdlib.Result.map (fun sourceFiles ->
        Builtin.printLine "3. Parsing all read files"
        parseAllFiles sourceFiles)

      |> PACKAGE.Darklang.Stdlib.Result.andThen (fun parsed ->
        Builtin.printLine "4. Serializing parsed packages to JSON"

        match Builtin.jsonSerialize<PACKAGE.Darklang.Stdlib.Packages> parsed with
        | Ok serialized -> PACKAGE.Darklang.Stdlib.Result.Result.Ok serialized
        | Error err ->
          $"Failed to serialize parsed packages to JSON:\n{err}"
          |> PACKAGE.Darklang.Stdlib.Result.Result.Error)

      |> PACKAGE.Darklang.Stdlib.Result.andThen (fun serialized ->
        Builtin.printLine "5. Replacing package items at {host} with updated items"

        let response =
          PACKAGE.Darklang.Stdlib.HttpClient.request
            "POST"
            $"{host}/all"
            [ PACKAGE.Darklang.Stdlib.HttpClient.bearerToken password ]
            (PACKAGE.Darklang.Stdlib.String.toBytes serialized)

        match response with
        | Ok response ->
          match response.statusCode with
          | 200L -> PACKAGE.Darklang.Stdlib.Result.Result.Ok()
          | _ ->
            let errMsg =
              $"Failed to replace package items at {host}\n"
              ++ $"Status: {PACKAGE.Darklang.Stdlib.Int64.toString response.statusCode}\n"
              ++ $"Body: {response.body |> PACKAGE.Darklang.Stdlib.String.fromBytesWithReplacement}"

            PACKAGE.Darklang.Stdlib.Result.Result.Error errMsg
        | Error err ->
          (PACKAGE.Darklang.Stdlib.HttpClient.toString err)
          |> PACKAGE.Darklang.Stdlib.Result.Result.Error)

    match result with
    | Error err ->
      Builtin.printLine err
      1L
    | Ok() ->
      Builtin.printLine
        $"Done loading packages from source files to canvas at {host}"
      //printAllPackagesInDb ()
      0L


  | BadOption msg ->
    Builtin.printLine ("Error: " ++ msg)
    1L

main args