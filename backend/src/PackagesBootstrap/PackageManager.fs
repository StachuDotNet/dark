/// Bootstrap Package Manager - loads packages from a binary blob for CLI bootstrapping
///
/// This module provides an in-memory package manager implementation that loads
/// packages from a pre-compiled binary blob. This is used to bootstrap the
/// CLI without needing the full LibPackageManager stack.
///
/// The blob file is generated by an export script from the main branch.
module PackagesBootstrap.PackageManager

open System
open System.IO
open System.Collections.Generic
open System.Reflection

open Prelude

module PT = LibExecution.ProgramTypes
module RT = LibExecution.RuntimeTypes
module PT2RT = LibExecution.ProgramTypesToRuntimeTypes

open PackagesBootstrap.BinaryFormat
open PackagesBootstrap.Serializers.Common


// -------
// In-memory storage
// -------

type PackageStore =
  { types : Dictionary<PT.FQTypeName.Package, PT.PackageType.PackageType>
    values : Dictionary<PT.FQValueName.Package, PT.PackageValue.PackageValue>
    fns : Dictionary<PT.FQFnName.Package, PT.PackageFn.PackageFn>

    // Location lookups
    typeIdToLocation : Dictionary<PT.FQTypeName.Package, PT.PackageLocation>
    valueIdToLocation : Dictionary<PT.FQValueName.Package, PT.PackageLocation>
    fnIdToLocation : Dictionary<PT.FQFnName.Package, PT.PackageLocation>

    typeLocationToId : Dictionary<PT.PackageLocation, PT.FQTypeName.Package>
    valueLocationToId : Dictionary<PT.PackageLocation, PT.FQValueName.Package>
    fnLocationToId : Dictionary<PT.PackageLocation, PT.FQFnName.Package> }

  static member empty () =
    { types = Dictionary()
      values = Dictionary()
      fns = Dictionary()
      typeIdToLocation = Dictionary()
      valueIdToLocation = Dictionary()
      fnIdToLocation = Dictionary()
      typeLocationToId = Dictionary()
      valueLocationToId = Dictionary()
      fnLocationToId = Dictionary() }


// -------
// Blob loading
// -------

/// Parse a location string like "owner.module1.module2.name" into PackageLocation
let parseLocation (locStr : string) : PT.PackageLocation =
  let parts = locStr.Split('.')
  if parts.Length < 2 then
    Exception.raiseInternal $"Invalid location format: {locStr}" []
  let owner = parts[0]
  let name = parts[parts.Length - 1]
  let modules = parts[1 .. parts.Length - 2] |> Array.toList
  { owner = owner; modules = modules; name = name }


/// Load all packages from a binary blob into memory
let loadFromBlob (blobData : byte[]) : PackageStore =
  let store = PackageStore.empty ()

  use stream = new MemoryStream(blobData)
  use r = new BinaryReader(stream)

  // Read counts from header
  let typeCount = r.ReadInt32()
  let valueCount = r.ReadInt32()
  let fnCount = r.ReadInt32()

  let readItem () =
    let idLen = r.ReadInt32()
    let id = System.Text.Encoding.UTF8.GetString(r.ReadBytes(idLen))
    let locLen = r.ReadInt32()
    let loc = System.Text.Encoding.UTF8.GetString(r.ReadBytes(locLen))
    let dataLen = r.ReadInt32()
    let data = r.ReadBytes(dataLen)
    (id, loc, data)

  // Read and deserialize types
  for _ in 1..typeCount do
    let (idStr, locStr, data) = readItem ()
    let guid = Guid.Parse(idStr)
    let location = parseLocation locStr

    // Deserialize using our PT deserializer
    use dataStream = new MemoryStream(data)
    use dataReader = new BinaryReader(dataStream)

    // Read header
    let _header = Header.read dataReader

    // Read package type
    let packageType = Serializers.PT.PackageType.read dataReader

    store.types[guid] <- packageType
    store.typeIdToLocation[guid] <- location
    store.typeLocationToId[location] <- guid

  // Read and deserialize values
  for _ in 1..valueCount do
    let (idStr, locStr, data) = readItem ()
    let guid = Guid.Parse(idStr)
    let location = parseLocation locStr

    use dataStream = new MemoryStream(data)
    use dataReader = new BinaryReader(dataStream)
    let _header = Header.read dataReader
    let packageValue = Serializers.PT.PackageValue.read dataReader

    store.values[guid] <- packageValue
    store.valueIdToLocation[guid] <- location
    store.valueLocationToId[location] <- guid

  // Read and deserialize functions
  for _ in 1..fnCount do
    let (idStr, locStr, data) = readItem ()
    let guid = Guid.Parse(idStr)
    let location = parseLocation locStr

    use dataStream = new MemoryStream(data)
    use dataReader = new BinaryReader(dataStream)
    let _header = Header.read dataReader
    let packageFn = Serializers.PT.PackageFn.read dataReader

    store.fns[guid] <- packageFn
    store.fnIdToLocation[guid] <- location
    store.fnLocationToId[location] <- guid

  store


// -------
// PT.PackageManager implementation
// -------

/// Create a PT.PackageManager from a PackageStore
let createPT (store : PackageStore) : PT.PackageManager =
  { findType =
      fun (_accountId, _branchId, location) ->
        match store.typeLocationToId.TryGetValue(location) with
        | true, id -> Ply(Some id)
        | false, _ -> Ply None

    findValue =
      fun (_accountId, _branchId, location) ->
        match store.valueLocationToId.TryGetValue(location) with
        | true, id -> Ply(Some id)
        | false, _ -> Ply None

    findFn =
      fun (_accountId, _branchId, location) ->
        match store.fnLocationToId.TryGetValue(location) with
        | true, id -> Ply(Some id)
        | false, _ -> Ply None

    search =
      fun (_accountId, _branchId, _query) ->
        // TODO: Implement search if needed for CLI
        Ply { submodules = []; types = []; values = []; fns = [] }

    getType =
      fun id ->
        match store.types.TryGetValue(id) with
        | true, t -> Ply(Some t)
        | false, _ -> Ply None

    getValue =
      fun id ->
        match store.values.TryGetValue(id) with
        | true, v -> Ply(Some v)
        | false, _ -> Ply None

    getFn =
      fun id ->
        match store.fns.TryGetValue(id) with
        | true, f -> Ply(Some f)
        | false, _ -> Ply None

    getTypeLocation =
      fun (_accountId, _branchId, id) ->
        match store.typeIdToLocation.TryGetValue(id) with
        | true, loc -> Ply(Some loc)
        | false, _ -> Ply None

    getValueLocation =
      fun (_accountId, _branchId, id) ->
        match store.valueIdToLocation.TryGetValue(id) with
        | true, loc -> Ply(Some loc)
        | false, _ -> Ply None

    getFnLocation =
      fun (_accountId, _branchId, id) ->
        match store.fnIdToLocation.TryGetValue(id) with
        | true, loc -> Ply(Some loc)
        | false, _ -> Ply None

    init = uply { return () } }


/// Create an RT.PackageManager from a PackageStore
let createRT (store : PackageStore) : RT.PackageManager =
  store |> createPT |> PT2RT.PackageManager.toRT


// -------
// Main entry points
// -------

/// Initialize the bootstrap package manager from a blob file path
let initFromFile (blobPath : string) : PT.PackageManager * RT.PackageManager =
  let blobData = File.ReadAllBytes(blobPath)
  let store = loadFromBlob blobData
  (createPT store, createRT store)


/// Initialize from embedded resource (for compiled CLI)
let initFromEmbeddedResource () : PT.PackageManager * RT.PackageManager =
  let assembly = Assembly.GetExecutingAssembly()
  let resourceName = "PackagesBootstrap.data.packages-bootstrap.blob"

  use stream = assembly.GetManifestResourceStream(resourceName)
  if isNull stream then
    Exception.raiseInternal $"Embedded resource not found: {resourceName}" []

  use ms = new MemoryStream()
  stream.CopyTo(ms)
  let blobData = ms.ToArray()

  let store = loadFromBlob blobData
  (createPT store, createRT store)


/// Initialize an empty package manager (for testing or when no packages needed)
let initEmpty () : PT.PackageManager * RT.PackageManager =
  let store = PackageStore.empty ()
  (createPT store, createRT store)


// -------
// Module-level singletons (like LibPackageManager)
// -------

/// Lazily initialized store from embedded resource
let private lazyStore =
  lazy (
    let assembly = Assembly.GetExecutingAssembly()
    let resourceName = "PackagesBootstrap.data.packages-bootstrap.blob"

    use stream = assembly.GetManifestResourceStream(resourceName)
    if isNull stream then
      Exception.raiseInternal $"Embedded resource not found: {resourceName}" []

    use ms = new MemoryStream()
    stream.CopyTo(ms)
    loadFromBlob (ms.ToArray())
  )

/// PT PackageManager singleton
let pt : PT.PackageManager = createPT (lazyStore.Force())

/// RT PackageManager singleton
let rt : RT.PackageManager = createRT (lazyStore.Force())
