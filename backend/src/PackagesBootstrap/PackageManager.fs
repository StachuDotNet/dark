/// Bootstrap Package Manager - loads packages from SQLite for CLI bootstrapping
///
/// This module provides an in-memory package manager implementation that loads
/// packages from a pre-compiled SQLite database. This is used to bootstrap the
/// CLI without needing the full LibPackageManager/LibBinarySerialization stack.
///
/// The SQLite database is generated by an export script from the main branch.
module PackagesBootstrap.PackageManager

open System.Collections.Generic

open Prelude

module PT = LibExecution.ProgramTypes
module RT = LibExecution.RuntimeTypes
module PT2RT = LibExecution.ProgramTypesToRuntimeTypes

open LibDB.Db


// -------
// In-memory storage
// -------

type PackageStore =
  { types : Dictionary<PT.FQTypeName.Package, PT.PackageType.PackageType>
    values : Dictionary<PT.FQValueName.Package, PT.PackageValue.PackageValue>
    fns : Dictionary<PT.FQFnName.Package, PT.PackageFn.PackageFn>

    // Location lookups
    typeIdToLocation : Dictionary<PT.FQTypeName.Package, PT.PackageLocation>
    valueIdToLocation : Dictionary<PT.FQValueName.Package, PT.PackageLocation>
    fnIdToLocation : Dictionary<PT.FQFnName.Package, PT.PackageLocation>

    typeLocationToId : Dictionary<PT.PackageLocation, PT.FQTypeName.Package>
    valueLocationToId : Dictionary<PT.PackageLocation, PT.FQValueName.Package>
    fnLocationToId : Dictionary<PT.PackageLocation, PT.FQFnName.Package> }

  static member empty () =
    { types = Dictionary()
      values = Dictionary()
      fns = Dictionary()
      typeIdToLocation = Dictionary()
      valueIdToLocation = Dictionary()
      fnIdToLocation = Dictionary()
      typeLocationToId = Dictionary()
      valueLocationToId = Dictionary()
      fnLocationToId = Dictionary() }


// -------
// SQLite loading - placeholder for now
// The export script (to be written) will define the schema.
// -------

/// Load all packages from SQLite database into memory
let loadFromSqlite (_conn : Connection) : PackageStore =
  // TODO: Implement once we have the export script and know the schema
  // For now, return empty store
  PackageStore.empty ()


// -------
// PT.PackageManager implementation
// -------

/// Create a PT.PackageManager from a PackageStore
let createPT (store : PackageStore) : PT.PackageManager =
  { findType =
      fun (_accountId, _branchId, location) ->
        match store.typeLocationToId.TryGetValue(location) with
        | true, id -> Ply(Some id)
        | false, _ -> Ply None

    findValue =
      fun (_accountId, _branchId, location) ->
        match store.valueLocationToId.TryGetValue(location) with
        | true, id -> Ply(Some id)
        | false, _ -> Ply None

    findFn =
      fun (_accountId, _branchId, location) ->
        match store.fnLocationToId.TryGetValue(location) with
        | true, id -> Ply(Some id)
        | false, _ -> Ply None

    search =
      fun (_accountId, _branchId, _query) ->
        // TODO: Implement search if needed for CLI
        Ply { submodules = []; types = []; values = []; fns = [] }

    getType =
      fun id ->
        match store.types.TryGetValue(id) with
        | true, t -> Ply(Some t)
        | false, _ -> Ply None

    getValue =
      fun id ->
        match store.values.TryGetValue(id) with
        | true, v -> Ply(Some v)
        | false, _ -> Ply None

    getFn =
      fun id ->
        match store.fns.TryGetValue(id) with
        | true, f -> Ply(Some f)
        | false, _ -> Ply None

    getTypeLocation =
      fun (_accountId, _branchId, id) ->
        match store.typeIdToLocation.TryGetValue(id) with
        | true, loc -> Ply(Some loc)
        | false, _ -> Ply None

    getValueLocation =
      fun (_accountId, _branchId, id) ->
        match store.valueIdToLocation.TryGetValue(id) with
        | true, loc -> Ply(Some loc)
        | false, _ -> Ply None

    getFnLocation =
      fun (_accountId, _branchId, id) ->
        match store.fnIdToLocation.TryGetValue(id) with
        | true, loc -> Ply(Some loc)
        | false, _ -> Ply None

    init = uply { return () } }


/// Create an RT.PackageManager from a PackageStore
let createRT (store : PackageStore) : RT.PackageManager =
  store |> createPT |> PT2RT.PackageManager.toRT


// -------
// Main entry point
// -------

/// Initialize the bootstrap package manager from a SQLite database file
let init (dbPath : string) : PT.PackageManager * RT.PackageManager =
  let connString =
    $"Data Source={dbPath};Mode=ReadOnly;Cache=Private;Pooling=true"
  let conn = createConnection connString
  let store = loadFromSqlite conn
  (createPT store, createRT store)


/// Initialize an empty package manager (for testing or when no packages needed)
let initEmpty () : PT.PackageManager * RT.PackageManager =
  let store = PackageStore.empty ()
  (createPT store, createRT store)
