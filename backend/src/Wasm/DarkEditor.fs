module Wasm.DarkEditor

open System
open System.Net.Http
open System.Threading.Tasks

open Microsoft.JSInterop

open Prelude
open Tablecloth

open LibExecution.RuntimeTypes

let debug (arg : string) = WasmHelpers.callJSFunction "console.log" [ arg ]


let getStateForEval
  (types : List<UserType.T>)
  (fns : List<UserFunction.T>)
  : ExecutionState =
  let packageFns = Map.empty // TODO

  let libraries : Libraries =
    let stdlibFns, stdlibTypes =
      LibExecution.StdLib.combine
        [ StdLibExecution.StdLib.contents; Wasm.StdLib.contents ]
        []
        []

    { stdlibTypes = stdlibTypes |> List.map (fun typ -> typ.name, typ) |> Map

      stdlibFns = stdlibFns |> List.map (fun fn -> fn.name, fn) |> Map

      packageFns = packageFns }

  let program : ProgramContext =
    { canvasID = CanvasID.Empty
      internalFnsAllowed = true
      dbs = Map.empty
      userFns = Map.fromListBy (fun fn -> fn.name) fns
      userTypes = Map.fromListBy (fun typ -> typ.name) types
      secrets = List.empty }

  { libraries = libraries
    tracing = LibExecution.Execution.noTracing Real
    program = program
    test = LibExecution.Execution.noTestContext
    reportException = consoleReporter
    notify = consoleNotifier
    tlid = gid ()
    callstack = Set.empty
    onExecutionPath = true
    executingFnName = None }



/// Any 'loose' exprs in the source are mapped without context of previous/later exprs
/// so, a binding set in one 'let' will be unavailable in the next expr if evaluated one by one.
///
/// e.g. given these separated exprs:
///   - `let x = 1`
///   - `1+1`
///   - `x+2`
/// when evaluating `x+2`, `x` wouldn't normally exist in the symtable.
///
/// So, this fn reduces the exprs to one expr ensuring bindings are available appropriately
///   `let x = 1 in (let _ = 1+1 in x+2)`
///
/// `1+1` here may just as well be something like
///   `WASM.callJSFunction "console.log" ["X is " ++ (Int.toString x)])`
///
/// (There's no way to read the symtable from `state`, otherwise I'd eval expr by expr, and
/// update the symtable as I go.)
let exprsCollapsedIntoOne (exprs : List<Expr>) : Expr =
  exprs
  |> List.rev
  |> List.fold (EUnit(gid ())) (fun agg expr ->
    match agg with
    | EUnit (_) -> expr
    | _ ->
      match expr with
      | ELet (id, lp, expr, _) -> ELet(id, lp, expr, agg)
      | other -> ELet(gid (), LPVariable(gid (), "_"), other, agg))


/// Source of the editor
/// (types, functions, and exprs to run on start to set the initial value)
type EditorSource =
  { types : List<UserType.T>
    fns : List<UserFunction.T>
    exprs : List<Expr> }


/// Load the Darklang program that manages the state of and interactions with
/// the JS side of the editor.
[<JSInvokable>]
let LoadClient (sourceURL : string) : Task<string> =
  task {
    let httpClient = new HttpClient()
    let! response = httpClient.GetAsync sourceURL |> Async.AwaitTask
    let! responseBody = response.Content.ReadAsStringAsync() |> Async.AwaitTask
    let clientSource = Json.Vanilla.deserialize<EditorSource> responseBody


    let expr = exprsCollapsedIntoOne clientSource.exprs

    let! initialState =
      let state = getStateForEval clientSource.types clientSource.fns
      let inputVars = Map.empty
      LibExecution.Execution.executeExpr state inputVars expr

    Libs.Editor.editor <-
      { Types = clientSource.types
        Functions = clientSource.fns
        CurrentState = initialState }

    return LibExecution.DvalReprDeveloper.toRepr initialState
  }


[<JSInvokable>]
let HandleEvent (serializedEvent : string) : Ply<string> =
  uply {
    let state = getStateForEval Libs.Editor.editor.Types Libs.Editor.editor.Functions

    let! result =
      LibExecution.Interpreter.callFn
        state
        (gid ())
        (FQFnName.User { modules = []; function_ = "handleEvent"; version = 0 })
        []
        [ DString serializedEvent ]

    return LibExecution.DvalReprDeveloper.toRepr result
  }


/// A "user program" that can be executed by the interpreter
/// (probably generated by AI).
type UserProgramSource =
  { types : List<UserType.T>
    fns : List<UserFunction.T>
    exprs : List<Expr> }

/// Eval a user program (probably generated by AI)
///
/// Note: Pretty soon, this should be remove-able in favor
/// of the Darklang WASM runtime directly evaluating based on the state it maintains.
[<JSInvokable>]
let EvalUserProgram (sourceJson : string) : Task<string> =
  task {
    let source = Json.Vanilla.deserialize<UserProgramSource> sourceJson

    let! initialState =
      let expr = exprsCollapsedIntoOne source.exprs
      let state = getStateForEval source.types source.fns
      let inputVars = Map.empty
      LibExecution.Execution.executeExpr state inputVars expr

    return LibExecution.DvalReprDeveloper.toRepr initialState
  }
