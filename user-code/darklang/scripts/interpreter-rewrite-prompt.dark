let apiKey = "TODO: get from secret"

// let allCodeFromFileBeforeChanges (filePath: String) : String =
//   let fileContents = $"git show main:{filePath}"
//   $"// {filePath}\n\n{fileContents}"

let allCodeFromFile (filePath: String) : String =
  let fileContents = Builtin.fileRead filePath
  $"// {filePath}\n\n{fileContents}"

(Stdlib.Cli.executeWithUnitOrStdErr "cd ~/dark") |> Builtin.unwrap // OK?

[ "I'd like help in refactoring some code in a project I'm working on. In this document, I'll:
  - provide a preamble about the project, Darklang
  - describe the specific problems I'm facing
  - provide a rough tree of the project structure, so you know how these things fit together
  - provide a few files along the way, of relevant code
  - ask you for advice on the problems"

  "Darklang is a holistic tool for writing software, including: language, runtime, package manager, editor"
  "Darklang's backend is written in F#, which (as a reminder) is built in-order, file by file. as such there are particular dependencies between files"

  "Core to the project are a few key modules, presented in the order they compile (per the .fsproj):
  - RuntimeTypes.fs, the AST-based representation of the things in the language, _for the interpreter_
  - Interpreter.fs, the interpreter itself, that runs on RuntimeTypes
  - Execution.fs, which largely wraps the interpreter
  - ProgramTypes.fs, an AST representation of the things in Darklang, directly mapping to how a user should think about them
  - ProgramTypesToRuntimeTypes.fs, a mapping from ProgramTypes to RuntimeTypes

  For shorthand, you can refer to some of these as RT, PT, and PT2RT."

  "We've started to face a problem with our AST-based interpreter: stack overflows.
  So, it's time to rewrite the interpreter to be bytecode-based rather than AST-based.
  This will involve a few steps:
  - updating RuntimeTypes quite a bit
  - updating the Interpreter even more
  - updating ProgramTypeToRuntimeTypes appropriately"

  "We have some specific ideas in mind for the intereter:
  - instruction/bytecode-based (let's call them Instructions in RT)
  - use a virtual machine with _registers_
  - don't use globals in the interpreter"

  "I'm going to now include the source of the mentioned files"

  allCodeFromFile "backend/src/LibExecution/RuntimeTypes.fs"
  allCodeFromFile "backend/src/LibExecution/Interpreter.fs"
  allCodeFromFile "backend/src/LibExecution/Execution.fs"
  allCodeFromFile "backend/src/LibExecution/ProgramTypes.fs"
  allCodeFromFile "backend/src/LibExecution/ProgramTypesToRuntimeTypes.fs"

  "Could you provide a sketch of updated RuntimeTypes, Interpreter, and Execution?" ]
|> Stdlib.String.join "\n-----\n"

let result = (OpenAI.Completion.simple apiKey promptText) |> Builtin.unwrap

Builtin.printLine result


// Note: maybe, when building this kinda thing up in Dark, for Darklang code, we reference things not by incomplete file names,
// but by some ("type-")checked reference (kinda like TDB references) - maybe @Stdib.Cli to get the context of that whole module, for example